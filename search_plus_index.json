{"./":{"url":"./","title":"阅读须知","keywords":"","body":"阅读说明书写格式这本书旨在总结我在linux学习过程中遇到的知识，以供我和大家参考。 阅读说明 说明比较简略，基础知识请自行参考其他书籍 软件的不同版本可能有差异，请以实际的为准 有些并未实践过，建议读者自己尝试后再确认 有些东西未深入，更多有用的信息见参考部分 可能会有错别字，阅读时需要注意有没有问题 有些地方写的比较乱或者有错误，会持续改进 书写格式 方括号的内容代表可选，尖括号的内容需要替换为实际值 表格中全部大写的单词，需要替换为对应的实际的参数值 参数中的三个点代表参数可以有多个，单独的 n 表示数字 单词由字母数字和下划线组成，至少两个字符以上 github和个人博客，请猛戳图标 如果各位看官觉得有所帮助，记得扫二维码打赏一下 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"tip-chapter/linuxgai-shu.html":{"url":"tip-chapter/linuxgai-shu.html","title":"Linux概述","keywords":"","body":"Linux介绍Linux历史GNU计划Linux史上的重要人物Linux发行版软件授权模式Linux内核的功能Linux内核版本号Linux相关概念参考Linux介绍 Linux是一套能够免费使用和自由传播的类Unix操作系统，由一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统内核和众多开源软件组成。 它能运行主要的UNIX工具软件、应用程序和网络协议，可以运行于32位和64位硬件之上。 Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux历史 Unix一开始是开源的，后来AT&T收回版权，并且宣布不再公开源代码。 Unix是用90%的C语言和10%汇编语言混合编写的，移植到不同硬件平台时需要更改代码，因此各个公司都推出了针对自家机型的Unix系统。 AT&T System V 第七版时，终于推出了针对X86的Unix，因此能够在个人计算机上安装Unix了，但有一条规定：“不能向学生公开源代码”。 为了教学，Tanebaum教授编写了兼容Unix的针对X86的Minix操作系统。因为Minix只是教学使用，因此功能并不强。 后来Linus Torvalds用GNU的bash当做开发环境，gcc当做编译工具，编写了Linux内核。 一开始Linux内核并不能兼容Unix，即Unix上跑的应用程序不能不加修改的在Linux上跑，因为Unix应用程序与Linux内核之间的接口并不一致。 因为Unix是遵循POSIX（Portable Operating System Interface）规范的，后来Torvalds修改了Linux内核，遵循了POSIX规范。 一开始Linux只适用于386，后来经过全世界的网友的帮助，最终能够兼容多种硬件。 GNU计划 70年代出现了两位针锋相对的领袖人物，来自哈佛大学的比尔·盖茨（Bill Gates）和 同样来自哈佛大学的理查德·斯托曼（Richard M.Stallman）。 前者宣布了版权（Copyright）时代的到来，并构建了辉煌的微软帝国。后者创立自由软件体系GNU（GNU is Not Unix），拟定了GNU通用公共许可协议（General Public License，简称GPL）。 所有GPL协议下的自由软件都遵循着Richard M. Stallman的非版权（Copyleft）原则：即自由软件允许用户自由拷贝、修改和销售，但是对其源代码的任何修改都必须向所有用户公开。 GNU计划和自由软件基金会FSF(the Free Software Foundation)是由Richard M. Stallman于1984年一手创办的，旨在开发一个类似UNIX并且是自由软件的完整操作系统：GNU系统（GNU 是\"GNU's Not Unix\"的递归缩写，它的发音为\"guh-NEW\"）。 各种使用Linux作为核心的GNU操作系统正在被广泛的使用，虽然这些系统通常被称作\"Linux\"，但是Stallman认为：严格地说，它们应该被称为GNU/Linux系统。 到上世纪90 年代初，GNU项目已经开发出许多高质量的免费软件，其中包括有名的emacs编辑系统、bash shell程序、gcc 系列编译程序、gdb 调试程序等等。这些软件为Linux操作系统的开发创造了一个合适的环境。 GNU计划是Linux操作系统能够诞生的基础之一，以至于目前许多人都将Linux操作系统称为“GNU/Linux”操作系统 Linux史上的重要人物 Ken Thompson：C语言之父和Unix之父 Dennis Ritchie：C语言之父和Unix之父 Stallman：著名黑客，GNU创始人 Bill Joy：BSD开发者 Tanenbaum：Minix开发者 Linus Torvalds：Linux之父 Linux发行版 Linux内核和众多开源软件一起构成了Linux操作系统。 Linux发行版本是指软件发行商提供的包含linux内核和众多软件的集成套件。 Linux的发行版本可以大体分为两类，一类是商业公司维护的发行版本，一类是社区组织维护的发行版本。 前者以著名的Redhat（RHEL）为代表，后者以Debian为代表。 Redhat，应该称为Redhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费)、Fedora Core(由原来的Redhat桌面版本发展而来的，免费)、CentOS(RHEL的社区克隆版本，免费) Debian，或者称Debian系列，包括Debian和Ubuntu等。Debian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统 对于个人用户，一般服务器操作系统选择centos，桌面操作系统选择ubuntu 软件授权模式 Open Source：开放源代码； Close Source：不开放源代码； Freeware：免费但不开源； Shareware：一开始免费试用，经过一段时间后收费； Linux内核的功能 进程管理 内存管理 文件管理 设备管理 网络管理 Linux内核版本号 查看命令：uname -r 版本：3.2.0-23 组成：主版本.次版本.释放版本-修订版本 Linux的内核版本分为稳定版本和开发版本。 次版本如果是偶数，则为稳定版本，如果是奇数，则为开发版本。 释放版本为对次版本的改动，即加入一些功能。 修改版本为编译的次数，每次加一。 Linux相关概念 类Unix操作系统： Unix Like，类Unix的操作系统是指借鉴Unix发展而来的操作系统，例如mac操作系统和linux操作系统 POSIX规范: Portable Operating System Interface，可移植操作系统接口，是对应用程序和系统调用之间的接口的规范 SELinux Security-Enhanced Linux，美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统 参考 Linux发行版：CentOS、Ubuntu、RedHat、Android、Tizen、MeeGoLinux各发行版介绍Linux下查看系统版本号信息的方法inux各种发行版本概述（Redhat系 | Debian系）Suse linux和OpenSuse的区别和联系一个时代的结束：Solaris 系统的那些年，那些事AIX 介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"tip-chapter/shellgai-shu.html":{"url":"tip-chapter/shellgai-shu.html","title":"Shell概述","keywords":"","body":"shellshell的分类查看shellshell与终端的区别shell快捷键描述shell快捷键（linux）shell快捷键（mac）shell 在计算机科学中，Shell俗称外壳（用来区别于内核），它类似于Windows的DOS，够接收用户的命令并翻译给操作系统执行，是用户与操作系统（内核）之间的桥梁。 shell的分类 bash 现在大多数linux系统默认使用的shell。 是 Bourne shell（最早的Unix shell）的一个免费版本。 可以通过help命令来查看帮助 csh C shell 使用的是“类C”语法，具有C语言风格 目前使用的并不多，已经被/bin/tcsh所取代 内部有52个命令，较为庞大 ksh Korn shell 的语法与 Bourne shell 相同 同时具备了 C shell 的易用特点。许多安装脚本都使用 ksh 内部有42条命令 tcsh tcsh是csh的增强版，与 C shell 完全兼容 zsh 传说中的终极shell sh sh 通常是指向 bash 的快捷方式 查看shell 查看系统支持哪些shell cat /etc/shells 查看正在使用的shell echo $SHELL shell与终端的区别 终端：接收用户的输入，并传递给shell程序，接收程序输出并展示到屏幕 shell： 接收并解析用户的命令给操作系统执行，将结果输出到终端 shell快捷键描述 快捷键描述（不区分大小写） 说明 Ctrl control 键 Shift shift 键 Alt alt 键 Tab tab 键 Esc esc 键 Backspace 退格键 Enter 回车键 [Page]Up 向上（翻页）键 [Page]Down 向下（翻页）键 Left 方向左键 Right 方向右键 快捷键后面的加号(+)或减号(-)表示组合快捷键的意思，不需要输入 类似Ctrl + W的形式，有时候也会表达为C-W的简写形式 快捷键在Mac和Linux系统上会有部分差异，需要注意 shell快捷键（linux） 综合操作快捷键 快捷键 说明 Ctrl + c 终止程序的执行 Ctrl + l 清空屏幕 Ctrl + n 下一个历史命令。n -> next Ctrl + p 上一个历史命令。p -> previous Ctrl + r 搜索包含该字符串的命令，继续按Ctrl + r搜索上一条匹配的命令，按Ctrl + g 退出。r -> reverse search Ctrl + s 挂起当前shell，停止向屏幕输出 Ctrl + q 恢复挂起的shell，继续向屏幕删除 Ctrl + v 插入特殊字符，如Ctrl + v + Tab插入Tab字符键 Alt + . 补全上一次的最后一个参数 !! 执行上一次执行的的命令 !$ 补全上一次的最后一个参数，和Alt + .一样 !* 补全上一次的所有参数 移动操作快捷键 快捷键 说明 Ctrl + a 移动到当前行的开头。a -> first letter Ctrl + e 移动到当前行的末尾。e -> end Ctrl + b 向后移动一个字符。b -> backward Ctrl + f 向前移动一个字符。f -> forward Alt + b 移动到当前单词的开头。b -> backward Alt + f 移动到当前单词的结尾。f -> forward 删除操作快捷键 快捷键 说明 Ctrl + d 删除光标所在的字符 Ctrl + h 删除光标的前一个字符 剪切操作快捷键 快捷键 说明 Ctrl + u 剪切命令行中光标所在处之前的所有字符（不包括自身） Ctrl + k 剪切命令行中光标所在处之后的所有字符（包括自身） Ctrl + w 剪切光标之前的词（以空格、标点等分隔，不包括自身） Alt + d 剪切光标之后的词（以空格、标点等分隔，包括自身） 粘贴操作快捷键 快捷键 说明 Ctrl + y 粘贴刚才所删除的字符 撤销操作快捷键 快捷键 说明 Ctrl + (x u) 按住Ctrl的同时再先后按x和u，撤销刚才的操作 大小写操作快捷键 快捷键 说明 Alt + u 把光标后的词转化为大写。u -> upper Alt + l 把光标后的词转化为小写。l -> lower Alt + c 把光标后的词汇变成首字符大写。c -> capital shell快捷键（mac） 和linux差不多，部分有区别 快捷键 说明 Ctrl + r 搜索包含该字符传的命令，继续按Ctrl+r搜索上一条匹配的命令，按Ctrl + s搜索下一条匹配的命令，按Ctrl + g或Ctrl + q退出。r -> reverse search Ctrl + s 正向搜索历史记录。s -> search Ctrl + u 剪切整行 Ctrl + l 会插入ls，然后回车 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"tip-chapter/bang-zhu-ming-ling.html":{"url":"tip-chapter/bang-zhu-ming-ling.html","title":"帮助命令","keywords":"","body":"linux帮助命令whatismaninfohelp选项帮助linux帮助命令 linux有非常多的命令，如果不熟悉那个命令的使用，可以使用帮助命令查询 whatis 查询一个命令执行什么功能，并将查询结果打印到终端上。进入后可输入命令或快捷键进行交互 格式如下 whatis man 命令的详细帮助文档，分区参数可以指定查看的章节 格式如下 man [选项] [分区] 选项如下 选项 说明 -f 查看命令拥有哪个级别的帮助，相当于whatis 其他 自行查阅 分区如下 分区 说明 1 查看普通命令的帮助 2 查看可被内核调用的函数的帮助 3 查看函数和函数库的帮助 4 查看特殊文件的帮助(主要是/dev目录下的文件) 5 查看配置文件的帮助 6 查看游戏的帮助 7 查看其他杂项的帮助 8 查看系统管理员可用命令的帮助 9 查看和内核相关文件的帮助 交互如下(ctrl表示control键) 命令 说明 Enter 进入子帮助页面(带有*号标记) ctrl + f 往前移动一屏，f是forward的缩写 ctrl + b 往后移动一屏，b是backward的缩写 ctrl + d 往前移动半屏 info 更全的帮助信息，进入后可输入命令或快捷键进行交互 格式如下 info [选项] 交互如下 命令 说明 回车 进入子帮助页面(带有*号标记) ? 查看帮助 m 菜单 u 进入上层页面 n 进入下一个帮助小节 p 进入上一个帮助小节 q 退出 help help命令可以获取shell内部命令的帮助，例如pwd，cd等 选项帮助 很多命令都可以指定 -h 或 --help 选项来查看帮助 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"tip-chapter/mo-hu-pi-pei.html":{"url":"tip-chapter/mo-hu-pi-pei.html","title":"模糊匹配","keywords":"","body":"模糊匹配glob匹配regex匹配POSIX正则表达式支持情况BRE（basic regex expression）ERE（extended regex expression）POSIX字符集ARE（advanced regex expression）ARE对ERE的扩展支持\"懒惰匹配\"（也叫\"非贪婪匹配\"或\"最短匹配\"）支持子表达式的向前引用匹配支持无名子表达式向前预判支持模式切换前缀Perl风格字符类换码序列glob和regex的区别针对对象不同通配符有差异通配符和shell展开参考模糊匹配 linux中有两种模糊匹配，很多命令都会用到 glob： 用于对文件名的模糊匹配，如ls，find，tar等命令 regex： 用于对文件内容的模糊匹配，如grep，sed，awk等命令 glob匹配 glob匹配是指参数为文件名时，可以使用通配符来进行模糊匹配 如果匹配，shell会将文件参数展开为多个参数 如果想要通配符表达字符原本的含义，需要用反斜杠（\\）转义 通配符 说明 * 任意长度的字符 ? 任意的单个字符 [] 指定范围内的任意单个字符 [^] 指定范围外的任意单个字符，范围里取反 [0-9] 所有的数字 [a-z] 所有的小写字母 [A-Z] 所有的大写字母 [a-zA-Z] 所有的字母 [0-9a-zA-Z] 所有的数字和字母 代表集合的POSIX通配符 通配符 说明 [:digit:] 所有数字, 相当于0-9 [:lower:] 所有的小写字母 [:upper:] 所有的大写字母 [:alpha:] 所有的字母 [:alnum:] 相当于[0-9a-zA-Z] [:space:] 空白字符 [:punct:] 所有标点符号 如果[A-Z]匹配了小写字母，原因参考这里 regex匹配 POSIX正则表达式 POSIX定义了两种正则表达式语法 基本正则表达式（BRE） 扩展正则表达式（ERE） 大多数linux程序至少要符合BRE规范 支持情况 linux中不同的程序支持的正则也不同 grep支持ERE，不过要使用-E选项 sed只支持BRE的大部分 awk则使用BRE sed只支持BRE的大部分，主要是因为sed要尽可能快的处理数据流 BRE（basic regex expression） BRE定义的语法符号 符号 说明 . 匹配任意一个字符 [] 字符集匹配，匹配方括号中定义的字符集之一 [^] 字符集否定匹配，匹配没有在方括号中定义的字符 ^ 匹配字符串的开始位置 $ 匹配字符串的结束位置 \\(\\) 定义子表达式 \\n 子表达式向前引用，n为1-9之间的数字 * 任意次匹配（零次或多次匹配） \\{n\\} 正好n次匹配 \\{m,n\\} 至少m次，至多n次匹配 \\{m,\\} 至少m次匹配 \\{,n\\} 至多n次匹配 子表达式向前引用，由于此功能已超出正则语义，需要在字符串中回溯，因此需要使用 NFA 算法进行匹配 ERE（extended regex expression） ERE 修改了 BRE 中的部分语法 ERE 取消了子表达式 \"()\" 和 次数匹配 \"{m,n}\" 语法符号的转义符 ERE 也取消了非正则语义的子表达式向前引用能力 ERE 增加了更多的匹配量词 新增的匹配量词 符号 说明 ? 最多一次匹配（零次或一次匹配） + 至少一次匹配（一次或更多次匹配） | 或运算，其左右操作数均可以为一个子表达式 POSIX字符集 BRE 和 ERE 共享同样的 POSIX 字符类定义 它们还支持字符类比较操作 \"[. .]\"和字符类等于操作 \"[= =]\" ，但很少被使用 大多数语言的正则都是从perl借鉴来的，和linux的正则很不一样 f / fr / wfr / bwfr 等工具默认使用 ERE 模式，同时支持以下 perl 风格的字符 POSIX类 perl类 描述 [:alpha:] \\a 字母 [:lower:] \\l 小写字母 [:upper:] \\u 大写字母 [:digit:] \\d 十进制数字 [:xdigit:] \\x 十六进制数字 [:alnum:] 字母和数字 [:word:] \\w 字母数字和下划线 [:blank:] 空格和制表符 [:space:] \\s 所有空白符（空格，制表符，换行，回车，垂直制表符，换页） [:cntrl:] 不可打印的控制字符（退格、删除、警铃...） [:graph:] 可打印的非空白字符 [:print:] \\p 可打印字符 [:punct:] 标点符号 blank 和 space 的区别参考这里 此外，还有以下特殊字符类 perl类 POSIX类 描述 \\o [0-7] 八进制数字 \\O [^0-7] 非八进制数字 \\w [[:alnum:]_] 字母数字下划线构成字符 \\W [^[:alnum:]_] 非字母数字下划线构成字符 \\a [:alpha:] 字母 \\A [^[:alpha:]] 非字母 \\l [:lower:] 小写字母 \\L [^[:lower:]] 非小写字母 \\u [:upper:] 大写字母 \\U [^[:upper:]] 非大写字母 \\s [:space:] 空格符 \\S [^[:space:]] 非空格符 \\d [:digit:] 非数字 \\D [^[:digit:]] 非数字 \\x [:xdigit:] 十六进制数字 \\X [^[:xdigit:]] 非十六进制数字 \\p [:print:] 可打印字符 \\P [^[:print:]] 非可打印字符 还可以使用以下特殊字符换码序列 换码序列 描述 \\r 回车 \\n 换行 \\b 退格 \\t 制表符 \\v 垂直制表符 \\' 单引号 \\\" 双引号 ARE（advanced regex expression） 除了 POSIX BRE 和 ERE 之外，libutilitis 还支持与TCL 8.2兼容的高级正则表达式语法（ARE），通过为 stRegEx 参数增加前缀 \"*:\" 就可以开启 ARE 模式，这个前缀覆盖 bExtended 选项 ARE对ERE的扩展 基本上讲，ARE 是 ERE 的超集，和编程语言中的正则非常接近，它在 ERE 的基础上进行了如下几项扩展 支持\"懒惰匹配\"（也叫\"非贪婪匹配\"或\"最短匹配\"） 在 '?', '*', '+' 或 '{m,n}'后追加 '?' 符号就可以启用最短匹配，使得该正则表达式子句在满足条件的前提下匹配尽可能少的字符（默认是匹配尽可能多的字符）。 例如：将 \"a.b\" 作用于 \"abab\"时，将匹配整个串（\"abab\"），若使用 \"a.?b\"，则将只匹配前两个字符（\"ab\"） 支持子表达式的向前引用匹配 在 stRegEx 中，可以使用 '\\n' 向前引用曾经定义的子表达式。 例如：\"(a.*)\\1\" 可匹配 \"abcabc\" 等 支持无名子表达式 使用 \"(?:表达式)\" 的方式创建一个无名表达式， 无名表达式不占用一个 '\\n' 匹配。 向前预判 要命中匹配，必须向前满足指定条件，向前预判分为肯定预判和否定预判两种。 肯定预判的语法为：\"(?=表达式)\" 例如：\"bai.(?=yang)\" 匹配 \"bai yang\"的前四个字符（\"bai \"），但在匹配时保证字符串在 \"bai.\" 后必须包含 \"yang\". 否定判断的语法为：\"(?!表达式)\" 例如：\"bai.(?!yang)\" 匹配 \"bai shan\" 的前四个字符（\"bai \"），但在匹配是保证字符串在 \"bai.\" 后不出现 \"yang\"。 支持模式切换前缀 在 \"***:\" 之后可以紧跟形如 \"(?模式串)\" 样式的模式串，模式串影响其后表达式的语义和行为。 模式串可以是以下字符的组合 字符 描述 b 切换至 POSIX BRE 模式，覆盖 bExtended 选项 e 切换至 POSIX ERE 模式，覆盖 bExtended 选项 q 切换至普通文本字面匹配模式，\"*=\" 前缀是其快捷表示 c 执行大小写敏感的匹配，覆盖 bNoCase 选项 i 执行忽略大小写的匹配，覆盖 bNoCase 选项 n 开启行敏感的匹配：'^' 和 '$' 匹配行首和行尾；'.' 和否定集 （'...'）不匹配换行符。此功能等同于 'pw' 模式串。覆盖 bNewLine 选项 m 等同于 'n' p '^' 和 '$' 只匹配整个字符串的首尾，不匹配行；'.' 和否定集不匹配换行符。覆盖 bNewLine 选项 w '^' 和 '$' 匹配行首和行尾；'.' 和否定集匹配换行符。覆盖 bNewLine 选项 s '^' 和 '$' 只匹配整个字符串的首尾，不匹配行；'.' 和否定集匹配换行符。覆盖 bNewLine 选项。ARE 状态下默认使用此模式 x 开启扩展模式：在扩展模式中，将忽略表达式中的空白符和注释符 '#' 后的内容 t 关闭扩展模式，不忽略空白符和注释符后的内容。ARE 状态下默认使用此模式 Perl风格字符类换码序列 由于在Markdown中使用实体符号表示尖括号时引入了多余的空格 所以请忽略尖括号左右多余的空格 perl类 等效POSIX表达式 描述 \\a - 响铃字符 \\A - 不论当前模式如何，仅匹配整个串的最开头 \\b - 退格字符 ('\\x08') \\B - 转义字符本身 ('\\') \\cX - 控制符-X (= X & 037) \\d [:digit:] 10进制数字 ('0' - '9') \\D [^[:digit:]] 非10进制数字 \\e - 退出符 ('\\x1B') \\f - 换页符 ('\\x0C') \\m [: 单词开始位置 \\M [:>:] 单词结束位置 \\n - 换行符 ('\\x0A') \\r - 回车符 ('\\x0D') \\s [:space:] 空白符 \\S [^[:space:]] 非空白符 \\t - 制表符 ('\\x09') \\uX - 16 位 UNICODE 字符 (X∈[0000 .. FFFF]) \\UX - 32 位 UNICODE 字符 (X∈[00000000 .. FFFFFFFF]) \\v - 纵向制表符 ('\\x0B') \\w [[:alnum:]_] 字母数字和下划线组成单词 \\W [^[:alnum:]_] 非字母数字和下划线组成单词 \\xX - 8位字符 (X∈[00 .. FF]) \\y - 单词边界（\\m 或 \\M） \\Y - 非单词边界 \\Z - 不论当前模式如何，仅匹配整个串的最尾部 \\0 - NULL，空字符 \\X - 子表达式向前引用 (X∈[1 .. 9]) \\XX - 子表达式向前引用或 8 进制表示的字符 \\XXX - 子表达式向前引用或 8 进制表示的字符 glob和regex的区别 针对对象不同 glob针对文件名，regex针对文件内容 通配符有差异 点号（.）在glob中就是字符点号，在regex中表示任意字符 星号（*）在glob中表示任意长度的字符，在regex中表示匹配零到多次 问号（?）在glob中表示一个字符，在regex中表示匹配最多一次 通配符和shell展开 单引号和双引号对模糊匹配中的*和?有影响，本质是shell展开造成的 [root@zhujipeng test-glob]# touch test.txt [root@zhujipeng test-glob]# touch test [root@zhujipeng test-glob]# ls test* test test.txt [root@zhujipeng test-glob]# ls 'test*' ls: cannot access test*: No such file or directory [root@zhujipeng test-glob]# find . -name test* find: paths must precede expression: test.txt Usage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression] [root@zhujipeng test-glob]# find . -name 'test*' ./test.txt ./test [root@zhujipeng test-glob]# find . -name 'test.*' ./test.txt 参考 linux中的通配符和正则表达式Linux中通配符、正则表达式和扩展正则表达式Linux Shell 通配符、元字符、转义符Linux正则表达式Why does [A-Z] match lowercase letters in bashBRE与ERE的差异shell 基本特性之~ shell展开详解What's the difference between [:space:] and [:blank:]? Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/":{"url":"base-chapter/file-about/","title":"文件相关","keywords":"","body":"本章是关于文件相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-mu-lu-ti-xi.html":{"url":"base-chapter/file-about/wen-jian-mu-lu-ti-xi.html","title":"文件目录体系","keywords":"","body":"查看根目录结构目录详解etc目录usr目录var目录proc目录dev目录/bin、/usr/bin、/usr/local/bin的区别文件名限制参考查看根目录结构 [root@zhujipeng /]# ls -1 / bin boot dev etc home lib lib64 lost+found media mnt opt proc root sbin selinux srv sys tmp usr var 目录详解 bin操作系统级别的命令所在的目录 boot引导程序和开机启动所在的目录，通常是一个单独的分区 dev设备文件所在的目录，硬盘、光驱、鼠标、键盘 都是以文件的方式放在这个目录下，/dev/null表示空设备，即丢弃输出 etc内核程序配置文件所在的目录 home主目录，包含各个用户的家目录 lib内核程序依赖库文件所在的目录，可能有软链接指向lib64或lib32 lib6464位内核程序依赖库文件所在的目录 media媒体文件的挂载目录，例如CD-ROM mnt临时文件的挂载目录，例如CD-ROM，u盘 opt可选软件的安装目录 proc虚拟文件系统，纪录内核、进程、外部设备的状态及网络状态等信息。所有数据都是在内存中，不占任何硬盘空间 rootroot用户的家目录 sbin操作系统级别的命令所在的目录，但普通用户无权限执行 selinuxselinux安全配置文件目录 srv网络服务的数据目录 sys虚拟文件系统，主要记录与内核相关的信息，包括目前已加载的内核模块与内核检测到的硬件设备信息。所有数据都是在内存中，不占任何硬盘空间 tmp临时文件目录，在系统重启时目录中文件可能不会被保留 usr系统级别的目录结构，也包含bin、lib、etc等目录 var运行时内容不断变化的文件所在的目录 etc目录 /etc/init.d程序开机启动脚本所在的目录 /etc/rc.d /etc/rc.d为了与以前兼容，/etc/rc.d是指向/etc/rc.d里对应目录的软链接，/etc/rc.d里不同级别的启动脚本都是/etc/init.d的软链接 /etc/hosts网络地址和域名的映射配置文件，操作系统会优先使用这个文件做dns解析 /etc/sysconfig/networkIP、掩码、网关、主机名配置 /etc/resolv.confDNS服务器配置 /etc/fstab文件系统自动挂载配置 /etc/inittabinit进程对系统的设置文件 /etc/exportsNFS的配置文件 /etc/profile系统（全局）环境变量配置文件 /etc/issue发行版信息 /etc/passwd用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息 /etc/shadow在安装了影子口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读，这使破译口令更困难 /etc/sudoerssudo用户的配置文件 /etc/syslog.conf /etc/rsyslog.conf系统日志的配置文件 /etc/shells可信任的shell列表 /etc/xinetd.d如果服务器是通过xinetd模式运行的，它的脚本要放在这个目录下。有些系统没有这个目录，比如Slackware，有些老的版本也没有。在Redhat Fedora中比较新的版本中存在。 /etc/opt//opt/的配置文件 usr目录 /usr/docLinux技术文档 /usr/bin系统程序级别的命令所在的目录 /usr/sbin系统程序级别的命令所在的目录 /usr/etc系统程序配置文件所在的目录 /usr/include开发和编译应用程序所需要的头文件 /usr/lib系统程序依赖库文件所在的目录 /usr/lib64位系统程序依赖库文件所在的目录 /usr/man帮助文档所在的目录 /usr/srcLinux开放的源代码，就存在这个目录，爱好者们别放过哦 /usr/share体系结构无关（共享）数据 /usr/local用户级别的目录结构，也包含bin、lib、etc等目录 var目录 /var/log/message系统日志信息，按周自动轮询 /var/spool/cron定时任务配置文件目录，默认按用户命名 /var/log/secure记录登陆系统存取信息的文件，不管认证成功还是认证失败都会记录 /var/log/wtmp记录登陆者信息的文件，last,who,w 命令信息来源于此 /var/spool/clientmqueue当邮件服务未开启时，所有应发给系统管理员的邮件都将保留在此 /var/spool/mail邮件目录 /var/tmp比/tmp 允许的大或需要存在较长时间的临时文件(虽然系统管理员可能不允许/var/tmp有很旧的文件) /var/lib系统正常运行时要改变的文件 /var/local/usr/local中安装的程序的可变数据(即系统管理员安装的程序)存放的目录。注意，如果必要，即使本地安装的程序也会使用其他/var目录，例如/var/lock。 /var/lock锁定文件目录。许多程序遵循在/var/lock中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件，将不试图使用这个设备或文件。 /var/log各种程序的Log文件，特别是login（/var/log/wtmp log所有到系统的登录和注销）和syslog（/var/log/messages 里存储所有核心和系统程序信息）。/var/log 里的文件经常不确定地增长，应该定期清除。 /var/run保存到下次引导前有效的关于系统的信息文件。例如/var/run/utmp包含当前登录的用户的信息。 /var/cache应用程序缓存数据。这些数据是在本地生成的一个耗时的I/O或计算结果。应用程序必须能够再生或恢复数据。缓存的文件可以被删除而不导致数据丢失。 proc目录 /proc/meminfo内存信息 /proc/loadavg还记得 top 以及 uptime 吧？没错！上头的三个平均数值就是记录在此！ /proc/uptime就是用 uptime 的时候，会出现的资讯啦！ /proc/cpuinfo关于处理器的信息，如类型、厂家、型号和性能等。 /proc/cmdline加载 kernel 时所下达的相关参数！查阅此文件，可了解系统是如何启动的！ /proc/filesystems目前系统已经加载的文件系统！ /proc/interrupts目前系统上面的 IRQ 分配状态。 /proc/ioports目前系统上面各个装置所配置的 I/O 位址。 /proc/kcore这个就是内存的大小啦！好大对吧！但是不要读他啦！ /proc/modules目前我们的 Linux 已经加载的模块列表，也可以想成是驱动程序啦！ /proc/mounts系统已经挂载的设备，就是用 mount 这个命令呼叫出来的数据啦！ /proc/swaps到底系统挂加载的内存在哪里？呵呵！使用掉的 partition 就记录在此啦！ /proc/partitions使用 fdisk -l 会出现目前所有的 partition 吧？在这个文件当中也有纪录喔！ /proc/pci在 PCI 汇流排上面，每个装置的详细情况！可用 lspci 来查阅！ /proc/version核心的版本，就是用 uname -a 显示的内容啦！ /proc/bus/*一些汇流排的装置，还有 U盘的装置也记录在此喔！ dev目录 /dev/hd[a-t]IDE设备 /dev/sd[a-z]SCSI设备 /dev/fd[0-7]标准软驱 /dev/md[0-31]软raid设备 /dev/loop[0-7]本地回环设备 /dev/ram[0-15]内存 /dev/null无限数据接收设备,相当于黑洞 /dev/zero无限零资源 /dev/tty[0-63]虚拟终端 /dev/ttyS[0-3]串口 /dev/lp[0-3]并口 /dev/console控制台 /dev/fb[0-31]framebuffer /dev/cdrom=> /dev/hdc /dev/modem=> /dev/ttyS[0-9] /dev/pilot=> /dev/ttyS[0-9] /dev/random随机数设备 /dev/urandom随机数设备 /bin、/usr/bin、/usr/local/bin的区别 etc，lib和bin类似，参见这里 /bin对应于操作系统级别的命令 /usr/bin对应于系统软件级别的命令 /usr/local/bin对应于用户（可选）软件级别的命令 文件名限制 在Linux中可以给目录和文件取任何名字，但必须遵守以下规则 除了/（路径分隔符）之外，所有的字符都合法 避免使用 + - . 来作为普通文件名的第一个字符 大小写敏感 有些字符最好不适用，详情参见 符号 说明 Space 分隔符 Tab 分隔符 Backspace 不变输入 : 空命令 ? 匹配单个字符 * 匹配多个字符 @ 位置参数符号 # 注释符号 $ 变量解析符号 & 后台运行符号 \\ 转义符号 | 管道符号 , 逗号 ; 分号 ' 单引号 \" 双引号 ` 反引号 () 在子shell中执行命令 {} 代码块 <> 重定向符号 上面的大多数字符在输入时需要转义，而且很容易在脚本中引发问题 参考 linux目录结构详细介绍Difference between lib, lib32, lib64, libx32, and libexec linux目录和文件名的命名规则关于Windows文件名和路径名的那些事shell脚本中28个特殊字符的作用简明总结Unix目录结构的来历操作系统对于文件和文件名的限制 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-ji-chu-ming-ling.html":{"url":"base-chapter/file-about/wen-jian-ji-chu-ming-ling.html","title":"文件基础命令","keywords":"","body":"pwdcdlsmvcpscptouchrmmkdirrmdirtreestatfiledirnamebasenamereadlink注意：使用删除命令时，要谨慎。如果删掉了重要数据或者根目录，你就只有准备跑路了 →_→参考pwd 用于查看当前所在目录，即工作目录（working directory） 格式如下 pwd [选项] 选项如下 选项 说明 -L, --logical 显示当前的逻辑位置，如果是软链接就是软链接本身的位置，是默认的选项 -P, --physical 显示当前的物理位置，如果是软链接就是软链接指向的位置 cd 切换到指定目录下，如果不指定默认为用户家目录。 当目录为字符“-”，表示切换到上次进入的目录，这个很有用 格式如下 cd [选项] [目录] 选项如下 选项 说明 -L 进入到指定目录的逻辑位置，如果是软链接就是软链接本身的位置，是默认的选项 -P 进入到指定目录的物理位置，如果是软链接就是软链接指向的位置 L -> Logical | P -> Physical ls 输出指定目录下的文件和目录，如果不指定默认为当前目录 格式如下 ls [选项] [文件或目录...] 选项如下 选项 说明 -a, --all 包含隐藏文件和目录 -A, --almost-all 输出除了名为.和..的目录以外的文件和目录 --block-size=SIZE 指定区块大小 -C 每行输出多列，当输出是终端时这个是默认启用的 -d, --directory 输出目录本身，不会输出子目录和文件 -F 目录的后面多一个斜杠（/） -h, --human-readable 以K，M，G为单位，更加易读 --si 与-h参数相同，但是K，M，G是以1000为换算单位 -i, --inodes 显示inode信息，而不是大小 -I, --ignore=PATTERN 过滤掉指定正则的文件和目录 -L, --dereference 输出软链接对应的源文件的信息q -l 以长格式的形式输出 -m 用逗号分割输出 -r, --reverse 反向排序输出 -R, --recursive 递归输出 -s, --size 按块为单位输出文件的大小 -S 按文件的大小降序输出 -t 按文件的修改时间降序输出 -1 强制每一项输出内容都用一行，当输出不是终端时这个是默认启用的 C -> column | l -> long mv 移动文件或者目录，或者移动和重命名源文件 如果目的是目录，则是移动 如果目的是文件，并且目的文件所在的目录和源文件相同，则是重命名 如果目的是文件（此时源不能是目录），并且目的文件所在的目录和源文件不同，则是移动和重命名 格式如下 mv [选项] 选项如下 选项 说明 -f, --force 如果文件或目录已经存在，则强制执行 -i, --interactive 如果文件或目录已经存在，则提示用户选择 -n, --no-clobber 如果文件或目录已经存在，则放弃执行 注意：-f，-i，-n 中后指定选项的会覆盖先指定的 cp 复制文件或者目录 格式如下 cp [选项] 选项如下 选项 说明 -a, --archive 使用归档模式，类似-dR --preserve -d 类似--no-dereference --preserve -f, --force 如果文件或目录已经存在，则强制执行 -i, --interactive 如果文件或目录已经存在，则提示用户选择 -l, --link 建立硬连接而不是拷贝 -L, --dereference 拷贝软链接文件对应的源文件 -p 保留模式、所属、和时间 -P, --no-dereference 拷贝软链接文件本身 -n, --no-clobber 如果文件或目录已经存在，则放弃执行 -r, -R, --recursive 递归拷贝目录 -s, --symbolic-link 建立软连接而不是拷贝 -u, --update 只拷贝更新的文件 注意：-f，-i，-n 中后指定选项的会覆盖先指定的 scp 拷贝文件到远程主机 scp [选项] [[用户@]主机:] ... [[用户@]主机:] 选项如下 选项 说明 -p 保留模式、所属、和时间 -q 不显示复制进度 -r 递归处理目录 touch 修改文件的时间，如果文件不存在则创建一个空文件 格式如下 touch [选项] 选项如下 选项 说明 -a 改变文件的访问时间 -m 改变文件的修改时间 -d, --date=STRING 使用指定的字符串改变访问时间和修改时间 -t TIMESTAMP 使用指定的时间戳改变访问时间和修改时间 a -> access | m -> modify | t -> timestamp rm 删除文件或者目录 格式如下 rm [选项] 选项如下 选项 说明 -f, --force 如果文件或目录已经存在，则强制执行 -i 如果文件或目录已经存在，则提示用户选择，每次都提示 -I 如果文件或目录已经存在，则提示用户选择，只提示一次 --interactive[=WHEN] never（从不）, once （等同于-I）, always （等同于-i，默认选项） -r, -R, --recursive 递归删除目录，删除目录时必须的选项 -d, --dir 删除空目录 注意：-f，-i 中后指定选项的会覆盖先指定的 mkdir 创建目录 格式如下 mkdir [选项] 选项如下 选项 说明 -p, --parents 如果父目录不存在，则创建父目录 rmdir 删除目录 格式如下 rmdir [选项] 选项如下 选项 说明 -p, --parents 删除该目录和所有的祖先目录，危险选项，容易删除根目录 tree tree命令可以用树的形式显示文件结构 格式如下 tree [选项] [目录] 选项如下 选项 说明 -a 显示所有文件，包括隐藏文件 -d 只显示目录 -f 显示全路径 -L level 指定书的最大显示深度 -l 如果文件为符号链接，列出符号链接的源文件 -P PATTERN 显示符合glob匹配的文件 -I PATTERN 不显示符合glob匹配的文件 -p 输出文件类型和权限 -u 输出文件的用户名或uid -g 输出文件的组名或gid -s 输出文件的大小，以字节为单位 -h 以K，M，G为单位，更加易读 --si 与-h参数相同，但是K，M，G是以1000为换算单位 --du 统计目录下子文件和目录的大小 -F 目录的后面多一个斜杠（/） -r 输出按相反的顺序输出 -t 按文件的修改时间排序 -c 按文件的状态时间排序 --dirsfirst 目录在文件的前面 stat 显示文件的状态信息 格式如下 stat [选项] file 探测给定文件的类型 格式如下 file [选项] 选项如下 选项 说明 -b, --brief 列出辨识结果时，不显示文件名称 -c 显示详细的执行过程，便于排错或分析程序的执行 -f, --files-from FILENAME 从指定文件中获取文件名，短横杠则从标准输入中获取 -i, --mime 显示MIME类型 -h, --no-dereference 显示软链接本身的文件类型 -L, --dereference 显示软链接源文件的文件类型 -m MAGIC_FILES 指定魔法数字文件 -v 显示版本信息 -z 尝试去解读压缩文件的内容 dirname 去除文件名中的非目录部分，仅显示目录部分 格式如下 dirname [选项] basename 去除文件名中的非文件名部分，仅显示文件名部分 格式如下 basename [选项] 选项如下 选项 说明 -a, --multiple 所有的参数都视为名称，否则第二个参数为后缀 -s, --suffix=SUFFIX 取出指定后缀名 readlink 如果文件是软链接，查看文件对应的源文件 格式如下 readlink [选项] 选项如下 选项 说明 -f, --canonicalize 递归查找源文件，最后一个源文件必须存在 -e, --canonicalize-existing 递归查找源文件，所有的源文件都必须存在 -m, --canonicalize-missing 递归查找源文件，源文件不一定要真实存在 注意：使用删除命令时，要谨慎。如果删掉了重要数据或者根目录，你就只有准备跑路了 →_→ 参考 file命令dirname命令basename命令 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-cha-zhao-ming-ling.html":{"url":"base-chapter/file-about/wen-jian-cha-zhao-ming-ling.html","title":"文件查找命令","keywords":"","body":"whichwhereislocatefind参考which 查看命令文件所在的位置 格式如下 which [选项] whereis 搜索包含该命令的的相关文件 和find相比，whereis查找的速度非常快，这是因为linux系统会将系统内的所有文件都记录在一个数据库文件中，查找时会从数据库中查找数据 格式如下 whereis [选项] 选项如下 选项 说明 -b 只搜索可执行文件 -m 只搜索帮助文件 -s 只搜索源代码文件 -B LIST 指定搜索可执行文件的路径 -M LIST 指定搜索帮助文件的路径 -S LIST 指定搜索源代码文件的路径 locate 快速查找文件 格式如下 locate [选项] locate命令可以通过搜寻数据库来快速找到档案，数据库由updatedb程序来更新，updatedb是由crontab周期性调用 选项如下 选项 说明 -A, --all 显示所有的匹配结果 -b, --basename 匹配文件名部分，而不是全路径 -c, --count 输出匹配个数，而不是文件名 -i, --ignore-case 匹配时忽略大小写 -l, --limit, -n LIMIT 找到足够的匹配后退出 -r, --regexp REGEXP 使用基本正则表达式匹配 --regex 使用扩展正则表达式匹配 -w, --wholename 匹配全路径，而不是文件名部分 BRE（基本正则表达式）与ERE（扩展正则表达式）的差异参考这里 find Linux下find命令在目录结构中搜索文件，并执行指定的操作 格式如下 find [选项] [动作] 选项如下 选项 说明 -name 按照文件名查找文件 -perm 按照文件权限来查找文件 -user 按照文件属主来查找文件 -group 按照文件所属的组来查找文件 -mtime [-/+]n 按照文件的更改时间来查找文件， -n表示距现在n天以内，+n表示距现在n天以前 -newer FILE1 ! FILE2 查找更改时间比文件file1新但比文件file2旧的文件 -type 查找某一类型的文件 -size 查找文件大小的文件 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 find命令非常复杂，更多参考这里 和 man文档 参考 每天一个linux命令 whereis 命令每天一个linux命令 locate 命令每天一个linux命令 find 命令概览每天一个linux命令 find命令之exec每天一个linux命令 find命令之xargs每天一个linux命令 find命令的参数详解linux find -regex 使用正则表达式BRE与ERE的差异Find命令查找指定时间范围内的文件Linux如何查找大文件或目录总结 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-cha-kan-ming-ling.html":{"url":"base-chapter/file-about/wen-jian-cha-kan-ming-ling.html","title":"文件查看命令","keywords":"","body":"cattacnlmorelessheadtaildiff参考cat 输出文件的内容，如果不指定，则输出标准输入的内容 格式如下 cat [选项] [文件...] 选项如下 选项 说明 -A, --show-all 等价于 -vET -b, --number-nonblank 对非空输出行编号 -e 等价于 -vE -E, --show-ends 在每行结束处显示$ -n, --number 对输出的所有行编号 -s, --squeeze-blank 合并两行以上的空白行为一行 -t 与 -vT 等价 -T, --show-tabs 将跳格字符显示为 ^I -u (被忽略) -v, --show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 tac tac命令用于将文件已行为单位的反序输出，即第一行最后显示，最后一行先显示 格式如下 tac [选项] [文件...] nl 计算文件中行号并和内容一起输出，行号的显示比cat -n更丰富 格式如下 nl [选项] [文件...] 选项如下 选项 说明 -b a 表示不论是否为空行，也同样列出行号(类似 cat -n) -b t 如果有空行，空的那一行不要列出行号(默认值) -n ln 行号在萤幕的最左方显示； -n rn 行号在自己栏位的最右方显示，且不加 0 -n rz 行号在自己栏位的最右方显示，且加 0 -w 行号栏位的占用的位数 -p 在逻辑定界符处不重新开始计算 more 按页显示文件内容 格式如下 more [选项] 选项如下 选项 说明 +n 从笫n行开始显示 -n 定义屏幕大小为n行 +/PATTERN 在每个档案显示前搜寻该模式（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 操作如下（Ctrl代表Control） 选项 说明 h | ? 查看使用帮助 Enter 向下n行，需要定义，默认为1行 Space 向下滚动一屏 Ctrl + d 向下滚动半屏 Ctrl + f 向下滚动一屏 Ctrl + b 向上滚动一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 V 调用编辑器，默认为vi !COMMAND 调用Shell，并执行命令 q 退出more less 按页显示文件内容，比more更强大 格式如下 less [选项] 选项如下 选项 说明 -g 只标识最后搜索的关键词 -i 忽略搜索时搜索串中小写部分的大小写 -I 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x n 将“tab”键显示为规定的数字空格 操作如下（Ctrl代表Control） 选项 说明 /PATTERN 向下搜索模式匹配 ?PATTERN 向上搜索模式匹配 &PATTERN 只显示匹配的行 n 下一个搜索（方向与 / 或 ? 有关） N 上一个搜索（方向与 / 或 ? 有关） g 移动到顶部 G 移动到底部 f 向下滚动一页 b 向上滚动一页 d 向下滚动半页 u 向上滚动半页 e 向下滚动一行 y 向上滚动一行 j 向下滚动一行 k 向上滚动一行 Enter 向下滚动一行 Space 向下滚动一页 [pagedown] 向下滚动一页 [pageup] 向上滚动一页 ,, （两次逗号）回到上一次的位置 h 显示帮助界面 q 退出less命令 f -> forward | b -> backward | d -> down | u-> up head 查看文件的开头部分 格式如下 head [选项] 选项如下 选项 说明 -c, --bytes=[-]K 每个文件显示K字节，如果K前有短横杠，则从末尾开始 -n, --lines=[-]K 每个文件显示K行，如果K前有短横杠，则从末尾开始 -q, --quiet, --silent 隐藏文件名 -v, --verbose 显示文件名 tail 查看文件的结尾部分 格式如下 tail [选项] 选项如下 选项 说明 -c, --bytes=[+]K 每个文件显示K字节，如果K前有加号，则从开头开始 -n, --lines=[+]K 每个文件显示K行，如果K前有加号，则从开头开始 -q, --quiet, --silent 隐藏文件名 -v, --verbose 显示文件名 -f 监听并输出文件变化的部分 -F 和-f --retry 一样的效果 --retry 当文件切割后，重新打开文件 -s, --sleep-interval=N 文件的监听频率 diff 比较文件之间的差异，格式的说明参照读懂diff 格式如下 diff [选项] 选项如下 选项 说明 - 指定要显示多少行文本，此参数必须与-c或-u参数一并使用 -a, --text diff预设只会逐行比较文本文件 -b, --ignore-space-change 不检查空格字符的不同 -B, --ignore-blank-lines 不检查空白行 -c 显示全部内文，并标出不同之处 -C, --context 与执行\"- -c\"选项相同 -d, --minimal 使用不同的演算法，以较小的单位来做比较 -D, ifdef 　此参数的输出格式可用于前置处理器巨集 -e, --ed 　此参数的输出格式可用于ed的script文件 -f, -forward-ed 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处 -H, --speed-large-files 比较大文件时，可加快速度 -l, --ignore-matching-lines 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异 -i, --ignore-case 不检查大小写的不同 -l, --paginate 　将结果交由pr程序来分页 -n, --rcs 将比较结果以RCS的格式来显示 -N, --new-file 　在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较 -p 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称 -P, --unidirectional-new-file 　与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较 -q, --brief 仅显示有无差异，不显示详细的信息 -r, --recursive 　比较子目录中的文件 -s, --report-identical-files 　若没有发现任何差异，仍然显示信息。 -S, --starting-file 　在比较目录时从指定的文件开始比较 -t, -expand-tabs 　在输出时将tab字符展开 -T, --initial-tab 　在每行前面加上tab字符以便对齐 -u, -U, --unified 　以合并的方式来显示文件内容的不同 -v, --version 　显示版本信息 -w, --ignore-all-space 忽略全部的空格字符 -W, --width 　在使用-y参数时，指定栏宽 -x, --exclude 　排除指定的文件或目录 -X, --exclude-from 排除文件中指定的文件和目录 -y, --side-by-side 　以并列的方式显示文件的异同之处 --help 　显示帮助 --left-column 　在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容 --suppress-common-lines 　在使用-y参数时，仅显示不同之处 参考 每天一个linux命令 cat 命令每天一个linux命令 nl命令每天一个linux命令 more命令每天一个linux命令 less 命令每天一个linux命令 head 命令每天一个linux命令 tail 命令每天一个linux命令 diff 命令读懂diffWhat is the difference between \"tail -f\" and \"tail -F\" Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-quan-xian-ming-ling.html":{"url":"base-chapter/file-about/wen-jian-quan-xian-ming-ling.html","title":"文件权限命令","keywords":"","body":"概述查看文件的权限修改文件的权限（chmod）文件和目录的权限强制保存文件的规则更改文件的拥有者(chown)更改文件的所属组(chgrp)参考概述 Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限 对于文件（目录是一种特殊的文件）来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 查看文件的权限 可以使用ls的-l选项或者ll命令（ls -l）的别名来查看 ls -l ll ➜ test-per ll total 0 drwxr-xr-x 2 zhujipeng staff 68B 8 13 15:49 test -rw-r--r-- 1 zhujipeng staff 0B 8 13 15:52 test.txt 每列的含义如下 第1列，文件属性。由文件类型(第一个字符)＋用户权限＋组权限＋他人权限组成。 文件类型 - 普通文件 d 目录文件 l 链接文件 b 块设备 c 字符设备 p 管道 s 套接字 文件权限 r 读权限 w 写权限 x 可执行权限 第2列，文件被引用的次数 第3列，文件的拥有者（owner） 第4列，文件的所属组（group） 第5列，文件的大小 第6-8列，文件的修改时间 最后一列，文件名 修改文件的权限（chmod） 格式如下 chmod [选项] 文字模式由范围＋操作符＋权限组成 范围 u 修改文件拥有者的权限 g 修改文件所属组的权限 o 修改其他人的权限 a 修改所有的权限 操作符 ＋ 增加权限 - 去掉权限 = 设置权限 权限 r 读权限 w 写权限 x 执行权限 数字模式由三个八进制数字组成。每个八进制中bit位为1代表有权限，0代表无权限 r 100 -> 4 w 010 -> 2 x 001 -> 1 rw 110 -> 6 rx 101 -> 5 wx 011 -> 3 rwx 111 -> 7 选项如下 选项 说明 -f, --silent, --quiet 忽略错误，强制执行 -R, --recursive 递归修改目录 f -> force | R -> recursive 文件和目录的权限 linux中文件和目录的权限有所不同 文件的权限 r 可以读文件 w 可以写文件 x 可以执行文件 目录的权限 r 可以读取（cp）和查看（ls）目录的内容（即文件和目录），同时还需要可执行权限 w 可以在目录里创建文件（touch）和目录（mkdir）和删除文件（rm）和目录（rmdir），同时还需要可执行权限 x 可以进入目录（cd）和执行文件 实践过程 创建一个目录和文件➜ test-per mkdir test ➜ test-per touch test/old ➜ test-per ll total 0 drwxr-xr-x 3 zhujipeng staff 102B 8 13 17:56 test 去除所有权限➜ test-per chmod 0 test ➜ test-per ll total 0 d--------- 3 zhujipeng staff 102B 8 13 17:56 test 只添加读权限➜ test-per chmod 400 test ➜ test-per ls test ls: old: Permission denied ➜ test-per cd test cd: permission denied: test ➜ test-per touch test/old touch: test/old: Permission denied ➜ test-per touch test/new touch: test/new: Permission denied ➜ test-per rm test/old rm: test/old: Permission denied 添加读和执行权限➜ test-per chmod 500 test ➜ test-per ls test old ➜ test-per cd test ➜ test cd ../ ➜ test-per touch test/old ➜ test-per touch test/new touch: test/new: Permission denied ➜ test-per rm test/old rm: test/old: Permission denied 只添加写权限➜ test-per chmod 200 test ➜ test-per ls test ls: test: Permission denied ➜ test-per cd test cd: permission denied: test ➜ test-per touch test/old touch: test/old: Permission denied ➜ test-per touch test/new touch: test/new: Permission denied ➜ test-per rm test/old rm: test/old: Permission denied 添加写和执行权限➜ test-per chmod 300 test ➜ test-per ls test ls: test: Permission denied ➜ test-per cd test ➜ test cd ../ ➜ test-per touch test/old ➜ test-per touch test/new ➜ test-per rm test/new 只添加执行权限➜ test-per chmod 100 test ➜ test-per ls test ls: test: Permission denied ➜ test-per cd test ➜ test cd ../ ➜ test-per touch test/old ➜ test-per touch test/new touch: test/new: Permission denied ➜ test-per rm test/old rm: test/old: Permission denied 总结如下 如果目录只有读或写权限是不够的，还需要执行权限 touch目录下一个存在的文件只需要执行权限，否则需要写权限 ls在只有读权限和没有读权限似的错误并不相同（^_^?） Tab补全只需要读权限 当对文件没有写权限的时候，保存时会提示你使用!强制保存 强制保存文件的规则 当对文件没有写权限的时候，保存时会提示你使用!强制保存 文件的所有者，不管对上级目录还是文件本身有何权限，都可以强制保存 不是文件的所有者，对上级目录有写权限，强制保存后，owner和group都会变成这个用户 更改文件的拥有者(chown) 格式如下 chown [选项] [:所属组名] 选项如下 选项 说明 -R, --recursive 递归修改目录 chown -> change owner 更改文件的所属组(chgrp) 格式如下 chgrp [选项] 选项如下 选项 说明 -R, --recursive 递归修改目录 chgrp -> change group 参考 linux文件基本权限讲解Linux 文件和目录权限的区别一些简单的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-te-shu-quan-xian.html":{"url":"base-chapter/file-about/wen-jian-te-shu-quan-xian.html","title":"文件特殊权限","keywords":"","body":"概述案例1SUID（set uid）SGID（set gid）案例2SBIT（Sticky）文件的隐藏属性查看隐藏属性（lsattr）修改隐藏属性（chattr）案例3查看文件访问控制列表（getfacl）设置文件访问控制列表（setfacl）参考概述 简单的文件rwx权限不能满足我们对安全和便捷的需求，所以便有了SUID与SGID的特殊权限机制 案例1 /etc/passwd文件存储着用户的相关设置，/etc/shadow存储着用户加密后的密码。/etc/passwd的拥有者是root，所属组是root，根据权限的知识普通用户应该是不能修改/etc/passwd的内容的，但是普通用户可以通过passwd命令修改自己的密码。这是因为passwd设置了suid位，让用户临时拥有了文件拥有者的权限。 ➜ test ll /etc/passwd -rw-r--r--. 1 root root 2609 8月 4 18:18 /etc/passwd ➜ test ll /usr/bin/passwd -rwsr-xr-x. 1 root root 27832 6月 10 2014 /usr/bin/passwd SUID（set uid） 让执行者临时拥有拥有者的权限（仅对拥有执行权限的二进制程序有效） 添加suidchmod u+s 去除suidchmod u-s SGID（set gid） SGID有两个功能，一个是让执行者临时拥有文件所属组的权限，另外一个是让文件下创建的文件的所属组是目录的所属组 添加suidchmod g+s 去除suidchmod g-s 案例2 一般老师希望学生可以将作业上传到某个特定目录。但为了避免某些小破坏份子有意或无意删掉别人的文件，那就要设置SBIT位了（也叫粘滞位）来限制用户删除其他人文件。 SBIT（Sticky） 只可管理自己的数据而不能删除他人文件(仅对目录有效)。对于所属组可写或全部可写的目录，当为此类目录设置sticky权限，则每个用户只能删除拥有者为自己的文件 添加stickychmod o+t 去除stickychmod o-t 文件的隐藏属性 文件权限除了读写执行与SUID、SGID、SBIT外还有一种隐藏权限，例如明明有权限删除某个文件却报错了，或者仅能为某个文件追加内容而不能减少内容，遇到这种很“奇怪”的文件，就要怀疑文件可能被设置隐藏权限了 查看隐藏属性（lsattr） 格式如下 lsattr [选项] 选项如下 选项 说明 -a 显示所有文件和目录 -d 若目标文件为目录，显示本身，而不是子目录和文件 -R 递归处理，将指定目录下的所有文件及子目录一并处理 lsattr -> list attribute 修改隐藏属性（chattr） 格式如下 chattr 模式如下 模式 说明 i 将无法对文件进行修改，若对目录设置后则仅能修改子文件而不能新建或删除 a 仅允许追加内容，无法覆盖/删除 S 文件内容变更后立即同步到硬盘(sync) s 彻底从硬盘中删除，不可恢复(用0填充原文件所在硬盘区域) A 不再修改这个文件的最后访问时间(atime) b 不再修改文件或目录的存取时间 D 检查压缩文件中的错误 d 当使用dump命令备份时忽略本文件/目录 c 默认将文件或目录进行压缩 u 当删除此文件后依然保留其在硬盘中的数据，方便日后恢复 t 让文件系统支持尾部合并（tail-merging） X 可以直接访问压缩文件的内容 chattr -> change attribute 案例3 rwx权限、特殊权限、隐藏权限都是对某一类用户设置的，而有时候需要对某个指定的用户进行单独的权限设置，那么就需要用文件的访问控制列表来实现啦 查看文件访问控制列表（getfacl） 格式如下 getfacl [选项] 选项如下 选项 说明 -d, --default 显示默认的文件访问控制权限 -R, --recursive 递归处理，将指定目录下的所有文件及子目录一并处理 getfacl -> get file access control list 设置文件访问控制列表（setfacl） 格式如下 setfacl [选项] 选项如下 选项 说明 -R, --recursive 递归处理，将指定目录下的所有文件及子目录一并处理 -m FORMAT 设置文件的acl规则 -b 删除所有扩展的acl规则，基本的acl规则(所有者，群组，其他）将被保留 格式如下（详细参考这里） [d[efault]:] [u[ser]:]uid [:perms] 指定用户的权限，文件所有者的权限 [d[efault]:] g[roup]:gid [:perms] 指定群组的权限，文件所有群组的权限 [d[efault]:] o[ther] [:perms] 其他的权限 [d[efault]:] m[ask][:] [:perms] 有效权限掩码 setfacl -> set file access control list 参考 linux文件特殊权限讲解setfacl命令 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-shi-jian-jian-jie.html":{"url":"base-chapter/file-about/wen-jian-shi-jian-jian-jie.html","title":"文件时间简介","keywords":"","body":"文件的时间详解查看文件时间修改文件时间示例参考文件的时间详解 在windows下，一个文件有三种时间：创建时间、修改时间、访问时间而在Linux下，一个文件也有三种时间：访问时间、修改时间、状态时间 Windows 创建时间（create time） 修改时间（modify time） 访问时间（access time） Linux 访问时间（access time） 修改时间（modify time） 状态时间（change time） 时间 描述 修改时间 文件的内容最后一次修改的时间，ls -l命令显示时间就是这个时间，对文件进行编辑之后保存，mtime就会改变 访问时间 对文件进行一次读操作就会改变，例如cat、more、less等操作，但是像stat、ls等不访问文件内容的命令对atime是不会有影响的 状态时间 当文件的状态被改变的时候就会改变，例如当使用chmod、chown等改变文件属性的命令就会改变文件的ctime 查看文件时间 查看所有时间stat 查看修改时间ls -l 查看访问时间ls -lu 查看状态时间ls -lc 修改文件时间示例 [root@zhujipeng file-time]# touch test.txt [root@zhujipeng file-time]# stat test.txt File: `test.txt' Size: 0 Blocks: 0 IO Block: 4096 regular empty file Device: 2dh/45d Inode: 571 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2017-08-19 17:36:23.513744773 +0000 Modify: 2017-08-19 17:36:23.513744773 +0000 Change: 2017-08-19 17:36:23.513744773 +0000 [root@zhujipeng file-time]# echo haha >> test.txt [root@zhujipeng file-time]# stat test.txt File: `test.txt' Size: 5 Blocks: 8 IO Block: 4096 regular file Device: 2dh/45d Inode: 571 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2017-08-19 17:36:23.513744773 +0000 Modify: 2017-08-19 17:37:31.957587082 +0000 Change: 2017-08-19 17:37:31.957587082 +0000 [root@zhujipeng file-time]# cat test.txt haha [root@zhujipeng file-time]# stat test.txt File: `test.txt' Size: 5 Blocks: 8 IO Block: 4096 regular file Device: 2dh/45d Inode: 571 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2017-08-19 17:37:58.459710303 +0000 Modify: 2017-08-19 17:37:31.957587082 +0000 Change: 2017-08-19 17:37:31.957587082 +0000 [root@zhujipeng file-time]# chmod a+x test.txt [root@zhujipeng file-time]# stat test.txt File: `test.txt' Size: 5 Blocks: 8 IO Block: 4096 regular file Device: 2dh/45d Inode: 571 Links: 1 Access: (0755/-rwxr-xr-x) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2017-08-19 17:37:58.459710303 +0000 Modify: 2017-08-19 17:37:31.957587082 +0000 Change: 2017-08-19 17:49:29.153883697 +0000 参考 Linux下文件的三个时间 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-ya-suo-jie-ya.html":{"url":"base-chapter/file-about/wen-jian-ya-suo-jie-ya.html","title":"文件压缩解压","keywords":"","body":"gzipgunzipbzip2bunzip2zipunziptar参考gzip gzip是指GNU zip，压缩和解压文件，后缀名为gz。 只能压缩文件，不能压缩目录 压缩之后不能保留原文件 如需打包，需要配合tar命令 格式如下 gzip [选项] 选项如下 选项 说明 -c --stdout --to-stdout 将压缩结果输出到标准输出，通常是屏幕 -d --decompress --uncompress 解压缩文件 -l --list 列出压缩文件的信息 -r --recursive 递归压缩目录里的文件 -v --verbose 压缩时输出详细信息 -# --fast --best 指定压缩级别，1-9，默认为6 gunzip 解压gz文件 格式如下 gunzip [选项] 选项如下 选项 说明 -c --stdout --to-stdout 将解压结果输出到标准输出，通常是屏幕 bzip2 bzip2是gzip的升级版，后缀名为bz2 格式如下 bzip2 [选项] 选项如下 选项 说明 -k, --keep 保留原文件 bunzip2 bunzip2是gunzip的升级版 格式如下 bunzip2 [选项] zip 压缩和解压文件，用的最多的压缩命令 压缩之后保留原文件 不自动产生后缀名，通常自行指定为zip linux和windows都支持的格式 格式如下 zip [选项] 选项如下 选项 说明 -c, --entry-comments 替每个被压缩的文件加上注释 -d, --delete 从压缩文件内删除指定的文件 -f 更新或者添加文件 -F 尝试修复已损坏的压缩文件 -g 将文件压缩后附加在既有的压缩文件之后，不另行建立新的压缩文件 -i, --include FILES 只压缩符合条件的文件 -j 只保存文件名称及其内容，而不存放任何目录名称 -J 删除压缩文件前面不必要的数据 -k 使用MS-DOS兼容格式的文件名称 -l 压缩文件时，把LF字符置换成LF+CR字符 -ll 压缩文件时，把LF+CR字符置换成LF字符 -L, --license 显示版权信息 -m, --move 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中 -n, -suffixes SUFFIXES 不压缩具有以特定字符串结尾的文件 -o,--latest-time 压缩时间以压缩文件内拥有最新更改时间的文件为准 -q, --quiet 不显示指令执行过程 -r, --recurse-paths 递归处理，将指定目录下的所有文件和子目录一并处理 -S 包含系统和隐藏文件 -t --from-date 把压缩文件的日期设成指定的日期 -T 检查备份文件内的每个文件是否正确无误 -u 更换较新的文件到压缩文件内 -v 显示指令执行过程或显示版本信息 -V 保存VMS操作系统的文件属性 -w 在文件名称里假如版本编号，本参数仅在VMS操作系统下有效 -x, --exclude FILES 压缩时排除符合条件的文件 -X 不保存额外的文件属性 -y 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效 -z 替压缩文件加上注释 -$ 保存第一个被压缩文件所在磁盘的卷册名称 -# 指定压缩效率，压缩效率是一个介于1-9的数值 unzip 解压zip文件 格式如下 unzip [选项] 选项如下 选项 说明 -o 覆盖存在的文件 tar 打包文件，后缀名为tar，配合-z选项时，后缀名为tar.gz或tgz 格式如下 tar [选项] 选项如下 选项 说明 -c, --create 建立一个tar包 -C, --directory=DIR 指定解压文件到指定目录 --delete 从tar包中删除文件 -f, --file=ARCHIVE 指定压缩文件名 -r, --append 追加文件到tar包中 -t, --list 列出tar包中的文件和目录 -u, --update 更新文件 -x 解压文件 -z, --gzip 使用gzip压缩 -k, --keep-old-files 解压时如果文件已存在，报错 --overwrite 覆盖已存在的文件 -v 输出进度 参考 Linux常用命令之压缩打包篇（gzip、gunzip、tar、zip、bzip2）Linux文档的压缩与打包Linux下zip包的压缩与解压Linux常见压缩格式Tar、Zip和Gz格式之不同rar tar gz zip 7z 有什么区别 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-jian-ting-tong-bu.html":{"url":"base-chapter/file-about/wen-jian-jian-ting-tong-bu.html","title":"文件监听同步","keywords":"","body":"inotifyinotifywaitinotifywatchrsync工作模式参考inotify 一种强大的、细粒度的、异步文件系统监控机制，它满足各种各样的文件监控需要，可以监控文件系统的访问属性、读写属性、权限属性、创建、删除、移动等操作。inotify-tools 是一个C库和一组命令行的工作提供Linux下inotify的简单接口，inotify-tools安装后会得到inotifywait和inotifywatch命令 inotifywait 监控有关文件的各种变化 inotifywait [-hcmrq] [-e ] [-t ] [--format ] [--timefmt ] [ ... ] 选项 说明 --fromfile 指定从文件中读取排除文件列表 -m, --monitor 事件第一次发生后不退出，而是继续监听 -d, --daemon 后台持续运行，需要配合--outfile指定日志输出文件 -o, --outfile 输出事件到文件中而不是标准输出 -s, --syslog 输出错误到syslog中而不是标准错误 -r, --recursive 递归监听子目录，忽略符号链接 -q, --quiet 输出少量的信息 --exclude 排除指定文件，大小写敏感 --excludei 排除指定文件，大小写不敏感 -t , --timeout 指定事件的超时时间 -e , --event 指定监听的时间，可使用多次 -c, --csv 输出格式为CSV格式 --format 指定输出的格式 输出格式的详细信息请参考 inotifywait 的 man 手册 事件 说明 access 目录里的文件被读取了 modify 目录里的文件被编辑了 attrib 目录里的文件属性被改变了 close_write 写模式打开的文件被关闭了 close_nowrite 只读模式打开的文件被关闭了 close 打开的文件被关闭了 open 目录里的文件被打开了 moved_to 文件或目录被移入了监听的目录 moved_from 文件或目录被移出了监听的目录 move 有文件或目录被在监听的目录中被移动了 create 有文件或目录被在监听的目录中被创建了 delete 有文件或目录被在监听的目录中被删除了 unmount 文件所在的文件系统被卸载了 inotifywatch 统计文件系统访问的次数 inotifywatch 的 使用方法和 inotifywait 差不多 rsync rsync是一个远程数据同步工具，只传送两个文件的不同部分 Access via remote shell: Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST] Push: rsync [OPTION...] SRC... [USER@]HOST:DEST Access via rsync daemon: Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST] rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST] Push: rsync [OPTION...] SRC... [USER@]HOST::DEST rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST 工作模式 rsync 有2种不同的工作模式 shell 模式：使用远程shell程序（如ssh或rsh）进行连接，一个冒号时使用这种模式 daemon 模式：使用TCP直接连接rsync daemon，两个冒号或URL写法时使用这种模式 选项 说明 -v, --verbose 输出更详细的信息 -a, --archive 试用归档模式，等同于-rlptgoD -r, --recursive 递归处理目录 -u, --update 忽略接收端中更新的文件 --inplace 替换接收端的文件 --append 追加到接收端的文件 -d, --dirs 不递归处理目录 -l, --links 保持软链接的形式 -L, --copy-links 使用软链接对应的源文件 -H, --hard-links 保持硬连接 -p, --perms 保留文件的权限 -E, --executability 保留可执行权限 --chmod=CHMOD 修改文件权限 -A, --acls 保留访问策略 -X, --xattrs 保留额外的属性 -o, --owner 保留用户属性（只能超级用户使用） -g, --group 保留组属性 -t, --times 保留修改时间 --delete 删除接收端多余的文件 -m, --prune-empty-dirs 忽略空的文件 --exclude=PATTERN 排除指定模式的文件 --exclude-from=FILE 从文件中读取排除模式 --include=PATTERN 包含指定模式的文件 --include-from=FILE 从文件中读取包含模式 --files-from=FILE 从文件中读取传输文件列表 --progress 显示传输进度 --list-only 只列出要传输的文件 --daemon 后台运行 参考 Linux下同步工具inotify+rsync使用详解inotifywait命令rsync命令Inotify: 高效、实时的Linux文件系统事件监控框架Linux-Rsync服务器/客户端搭建实战 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/file-about/wen-jian-jie-gou-xiang-jie.html":{"url":"base-chapter/file-about/wen-jian-jie-gou-xiang-jie.html","title":"文件结构详解","keywords":"","body":"文件简介文件组成inodeblock软链接和硬链接软链接硬链接链接命令windows和linux链接的异同lsof文件名和inode的关系inode引发的问题参考文件简介 linux下一切皆文件，包括内存，磁盘，网络都可以用文件的形式表示。操作系统的主要功能之一就是文件管理，所以文件是一种非常重要的资源。目录是一种特殊的文件，他的存储文件的名称和相关信息。 文件组成 文件主要由两部分组成，一是文件的元信息，由inode表示，二是文件的数据，由block表示 inode 用于存储文件的各属性，如下表 元数据 说明 所有者信息 owner, group, other 权限信息 read, write, execute 时间信息 修改时间（mtime）,访问时间（atime）,状态时间（ctime） 标志信息 文件的一些flag 链接数 有多少文件名指向这个inode 内容信息 type, size和对应的block的位置信息 inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。 一个是数据区，存放文件数据，另一个是inode区（inode table），存放 文件元信息。 每个inode节点的大小，一般是128字节或256字节。 inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。 假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8% block 用来存储文件的内容数据 软链接和硬链接 软链接 软链接（也叫符号链接）是指向另一个文件的特殊文件，这种文件的数据部分仅包含它所要链接文件的路径名。 软链接是为了克服硬链接的不足而引入的，软链接不直接使用inode号作为文件指针，而是使用文件路径名作为指针（软链接：文件名+数据部分‐‐>目标文件的路径名）。 软链接有自己的inode，并在磁盘上有一小片空间存放路径名。因此，软链接能够跨文件系统，也可以和目录链接。 软链接可以对一个不存在的文件名进行链接，但直到这个名字对应的文件被创建后，才能打开其链接。 当软链接指向的文件删除重命名或移动后，软链接并不会发生更新。 硬链接 硬链接是通过索引节点进行的链接。 该登记项具有一个新的文件名和要连接文件的inode 号，文件的目录登记项就是源文件的硬链接（硬链接，目录登记项： 文件名‐‐>文件的inode；文件名可以有多个，但文件inode 只是一个）。 不论一个文件有多少硬链接，在磁盘上只有一个描述它的inode，只要该文件的链接数不为0，该文件就保持存在。硬链接不能跨越文件系统，为避免无限递归，一般也不能在目录上建立hard link。 硬连接是直接建立在节点表上的（inode），建立硬连接指向一个文件的时候，会更新节点表上面的计数值。举个例子，一个文件被连接了两次（硬连接），这个文件的计数值是3，而无论通过3个文件名中的任何一个访问，效果都是完全一样的，但是如果删除其中任意一个，都只是把计数值减1，不会删除实际的内容的，（任何存在的 文件本身就算是一个硬连接）只有计数值变成0也就是没有任何硬连接指向的时候才会真实的删除内容。 对任何一个硬链接文件修改，都会对原文件进行修改。 链接命令 格式如下 ln [选项] 选项 说明 -s, --symbolic 建立软链接，否则就是硬链接 -f, --force 如果文件已存在，强制覆盖 -i, --interactive 如果文件已存在，则提示 windows和linux链接的异同 详情参见这里 lsof lsof的意思是’列出打开的文件’（list openfiles），用于找出文件被哪些进程打开或是占用。我们都知道Linux/UNIX的理念就是一切皆文件(包括pipes管道、sockets、directories目录、devices设备等等)。 使用lsof这个命令我们可以轻易的识别哪些文件正在被占用，详情参见这里 文件名和inode的关系 文件名可以看作inode的别名，进程已经打开文件后，删除文件名对应的文件不会影响进程的读写，因为进程依然持有文件的inode，有些时候这会引发一些问题。windows中没有inode的概念，当删除已打开的的文件的时候，会提示文件正在被使用的信息，原因参考这里。 inode引发的问题 文件已经删掉，但磁盘空间并没有减小。原因是因为文件名只是别名，文件并没有真正的删除，依然在被某个进程使用。解决步骤如下： 查找已经删除的文件 lsof | grep deleted 根据文件名查找进程 lsof 关闭或重新启动进程 写磁盘时明明还有空间，却报No space left on device（磁盘空间不足）的问题，原因可能是inode耗尽了，需要删除没用的小文件释放inode资源 日志切割后，日志采集程序无法继续采集。原因是日志切割时，旧文件A被命名为新文件B，日志采集程序此时持有的依然是B的inode，所以实际打开的还是新文件B，而新日志写到是A里面而不是B里面，所以采集程序无法继续采集。解决方案如下 低版本的采集程序有可能支持nohup信号重新打开文件，例如rsyslog 高版本的程序可能支持切割后重新打开文件的配置，例如rsyslog v8.16.0以上的reopenOnTruncate 最笨的方法，添加定时任务，在日志切割后重启日志采集程序 参考 Linux文件系统的最基本数据结构：inode和block理解inodeLinux软链接和硬链接详解Windows的四种链接方式lsof在Linux中的10个例子linux删除文件后没有释放空间Linux服务器磁盘占满问题解决（/dev/sda3 满了）为什么Windows在删除正在使用的文件时会提示“文件已在 XX 中打开”并拒绝删除，而安卓不会Linux的inode的理解 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-edit/":{"url":"base-chapter/text-edit/","title":"文本编辑","keywords":"","body":"本章是关于文本编辑相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-edit/vimwen-ben-bian-ji.html":{"url":"base-chapter/text-edit/vimwen-ben-bian-ji.html","title":"vim文本编辑","keywords":"","body":"vimvim的模式模式切换正常模式 －》 插入模式正常模式 －》 命令模式正常模式 －》 替换模式正常模式 －》 可视模式启动vim退出vimvim的使用光标移动翻屏移动文档标记文档操作基本插入改写插入删除和剪切复制粘贴文本对象寄存器文件加解密文件的编码文件换行格式vim退格键参考vim vim（vi的增强版）是我最喜欢的编辑器，也是linux下第二强大的编辑器 虽然emacs是公认的世界第一，但我认为emacs并没有vi编辑来得高效 如果是初学vi，运行一下vimtutor是个聪明的决定 如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh vim的模式 正常模式（normal-mode）：可以使用快捷键 插入模式（insert-mode）：可以输入文本 命令模式（command-mode）：可以执行命令，又称末行模式 替换模式（replace-mode）：替换光标后的文字 可视模式（visual-mode）：按行或按列选择区块 模式切换 正常模式 －》 插入模式 打开Vim时是正常模式。在任何模式下，只要按下Esc键就可以返回正常模式 快捷键 功能 i 在光标左侧输入正文 I 在光标所在行的行首输入正文，此行首指第一个非空白字符处 a 在光标右侧输入正文 A 在光标所在行的行尾输入正文 s 删除光标所在的字符，并进入输入模式 S 删除光标所在的行，并进入输入模式 o 在光标所在行的下一行增添新行，光标位于新行的行首 O 在光标所在行的上一行增添新行，光标位于新行的行首 r 修改光标所在字符，r后面跟要修改为的字符 R 替换光标所在处开始的字符，直到按【ESC】回到普通模式 正常模式 －》 命令模式 按冒号（:）即可进入命令模式，又称末行模式 正常模式 －》 替换模式 按大写的R即可进入替换模式，替换光标所在处开始的字符，直到按【ESC】回到普通模式 正常模式 －》 可视模式 快捷键 功能 v 进入可视模式，移动光标可以选择文本 V 进入可视行模式，总是整行整行的选中 ctrl + v 进入可视块模式，左右移动选择区块 启动vim vim可以启动多个文件 vim [选项] [文件...] 命令 功能 vim -b FILENAME 用二进制模式打开 vim -c CMD FILENAME 在打开文件前，先执行指定的命令 vim -r FILENAME 恢复上次异常退出的文件 vim -R FILENAME 以只读的方式打开文件，但可以强制保存 vim -M FILENAME 以只读的方式打开文件，不可以强制保存 vim -y N FILENAME 将编辑窗口的大小设为N行 vim + FILENAME 从文件的末尾开始 vim +N FILENAME 从第N行开始 vim +/STRING FILENAME 打开file，并将光标停留在第一个找到的string上 vim --remote FILENAME 用已有的vim进程打开指定的文件 退出vim 退出vim将是初学者面临的第一大难题，趣闻可以参考这里 快捷键 功能 :wq或:x 保存文件，退出vi编辑器 :w 保存文件，但不退出vi编辑器 :q 退出vi编辑器 :q! 不保存文件，退出vi编辑器 ZZ 保存文件，退出vi编辑器 在字符命令后加上字符a表示操作全部文件，如qa退出所有文件 vim的使用 注意后续带冒号（:）开头的字符命令都是在命令模式下，否则在正常模式下 ctrl-w是指control 和 w字符的组合，不包括减号，是非常常用的组合 快捷键中的加号表达组合的意思，不需要输入 光标移动 下面的操作都可以配合数字n使用，比如3h， 则光标向左移动3个字符。 快捷键 功能 h | Backspace 左移一个字符 l | Space 右移一个字符 j 下移一行 k 上移一行 gj 移动到一段内的下一行 gk 移动到一段内的上一行 Enter | + 把光标移至下一行第一个非空白字符 - 把光标移至上一行第一个非空白字符 w 移动下一个单词开头 W 移动下一个单词开头，忽略一些标点符号 e 移动下一个单词末尾 E 移动下一个单词末尾，忽略一些标点符号 b 移动到上一个单词开头 B 移动到上一个单词开头，忽略一些标点符号 ge 移动到上一个单词末尾 gE 移动到上一个单词末尾，忽略一些标点符号 ( 前移1句 ) 后移1句 { 前移1段 } 后移1段 fc 把光标移到同一行的下一个c字符处，c可换为其他字符 Fc 把光标移到同一行的上一个c字符处，c可换为其他字符 tc 把光标移到同一行的下一个c字符前，c可换为其他字符 Tc 把光标移到同一行的上一个c字符后，c可换为其他字符 ; 配合f & t使用，重复一次 , 配合f & t使用，反向重复一次 一行文本在屏幕上可以显示多行，屏幕行是屏幕上的一行，而非文本行 快捷键 功能 0 移动到行首 g0 移到光标所在屏幕行行首 ^ 移动到文本行第一个非空白字符 g^ 移动到屏幕行第一个非空白字符处 $ 移动到行尾 g$ 移动屏幕行行尾 n 向前移动n列 n| 移动到第n列 nG 移动到文件第n行 :n 移动到文件第n行 gg 移动到文件头部 G 移动到文件尾部 :$ 移动到文件尾部 H 移动到屏幕最顶端 M 移动到屏幕中间 L 移动到屏幕最底端 翻屏移动 ctrl是control键，加号（+）表示组合的意思，不需要输入 快捷键 功能 ctrl + f 下翻一屏 ctrl + b 上翻一屏 ctrl + d 下翻半屏 ctrl + u 上翻半屏 ctrl + e 向下滚动一行 ctrl + y 向上滚动一行 zz 将当前行移动到屏幕中央 zt 将当前行移动到屏幕顶端 zb 将当前行移动到屏幕底端 f -> forward | b -> backward | d -> down | u-> up 文档标记 使用标记可以快速移动。到达标记后，可以用ctrl + o后退，ctrl + i继续前进 快捷键 功能 m[a-z] 标记光标所在位置，局部标记，只用于当前文件 m[A-Z] 标记光标所在位置，全局标记，重新启动时标记仍然有效 [a-z] 移动到标记位置 '[a-z] 移动到标记位置的行首 `[0-9] 移动到倒数第[2-10]次关闭vim时离开的位置 `` 移动到上次编辑的位置，精确到列 \" 移动到上次编辑的位置，精确到行 `\" 移动到上次离开的地方 `. 移动到最后改动的地方 ctrl + o 移动到更老的位置 ctrl + i 移动到更新的位置 :marks 显示所有标记 :delmarks a b 删除标记a和b :delmarks a-c 删除标记a、b和c :delmarks a c-f 删除标记a和c、d、e、f :delmarks! 删除当前缓冲区的所有标记 :help mark-motions 查看更多关于mark的知识 文档操作 快捷键 功能 :e 重新加载当前文档 :e! 重新加载当前文档，并丢弃已做的改动 :e FILENAME 关闭当前文件并打开新的文件，如果修改未保存则会有警告 :e! FILENAME 关闭当前文件并打开新的文件，并丢弃已做的改动 :e+ FILENAME 开始新的文件，并从文件尾开始编辑 :e+n FILENAME 开始新的文件，并从第n行开始编辑 :enew 编辑一个未命名的新文档（ctrl-w + n） :e# 切回到刚才编辑的文件（ctrl + ^） :f 显示文档和光标等相关信息（ctrl + g ） :f FILENAME 改变编辑的文件名，这时再保存相当于另存为 gf 打开以光标所在字符串为文件名的文件 :w 保存修改 :n1,n2w FILENAME 保存第n1行到n2行的内容到指定文件中 :wq 保存并退出 :x 保存并退出 ZZ 保存并退出 :q[uit] 退出当前窗口（ctrl-w + q或ctrl-w + ctrl-q） :saveas NEW_FILENAME 文件另存为 :browse e 打开一个文件浏览器来选择要编辑的文件 :set browsedir=last 用上次访问过的目录（默认） :set browsedir=buffer 用当前文件所在目录 :set browsedir=current 用当前工作目录 :Ex(plore) 浏览当前目录下的所有文件 :Sex 水平分割一个窗口，浏览文件系统 :Vex 垂直分割一个窗口，浏览文件系统 :browse e vim --version | grep browse用来检查支不支持browse命令 加号（+）开头表示支持，减号（-）开头表示不支持 如果是终端，则会打开netrw文件浏览窗口 如果是gvim，则会打开一个图形界面的浏览窗口 :browse后可以跟任何编辑文档的命令，如sp等 打开的起始目录可以由browsedir来设置 基本插入 快捷键 功能 i 在光标左侧输入正文 I 在光标所在行的行首第一个非空白字符处输入正文 a 在光标右侧输入正文 A 在光标所在行的行尾输入正文 s 删除光标所在的字符，并进入输入模式 S 删除光标所在的行，并进入输入模式 o 在光标所在行的下一行增添新行，光标位于新行的行首 O 在光标所在行的上一行增添新行，光标位于新行的行首 :r FILENAME 在当前行下面插入另一个文件的内容 :[n]r FILENAME 在第n行下面插入另一个文件的内容 :r !date 在当前行下面插入当前日期与时间 :r !command 在当前行下面插入指定command命令的输出 一个小技巧： 按7 再按 i 进入插入模式 输入= 按 esc 回到命令模式 就会出现7个= 这在插入分割线时非常有用，如 36i + esc 就插入了36个+组成的分割线 改写插入 类似[n]cw的类型也可以写为c[n]w 快捷键 功能 [n]cw 改写光标（包括光标）后n个词 [n]ch 改写光标（包括光标）前n个字符 [n]cl 改写光标（包括光标）后n个字符 [n]cc 改写当前n行 [n]s 以输入的文本代替光标（包括光标）之后的n个字符 [n]S 以输入的文本代替当前n行 b, w, e大写时，表示忽略一些标点符号 删除和剪切 类似[n]dw的类型也可以写为d[n]w 快捷键 功能 d 删除（剪切）在可视模式下选中的文本 [n]dd 删除（剪切）n行 [n]db 删除（剪切）光标左边n个单词 [n]dw 删除（剪切）光标右边n个单词 [n]dh 删除（剪切）光标左边n个字符 [n]dl 删除（剪切）光标右边n个字符 [n]x 剪切光标右边n个字符，相当于d[n]l [n]X 剪切光标左边n个字符，相当于d[n]h d0 删除（剪切）当前位置到行首的内容 d$ | D 删除（剪切）当前位置到行尾的内容 dgg | d1G 删除（剪切）光标及光标以上的所有行 dG 删除（剪切）光标及光标以下的所有行 :m,nd 删除（剪切）m行到n行的内容 daw 删除（剪切）一个词，即使光标不在词首和词尾 das 删除（剪切）一个句子，即使光标不在句首和句尾 d/c 删除（剪切）当前位置到下一个字符c之间（不包括字符c）的内容，c可换为其他字符 b, w, e大写时，表示忽略一些标点符号 复制 类似[n]yw的类型也可以写为y[n]w 快捷键 功能 y 复制在可视模式下选中的文本 [n]yy | [n]Y 复制n行 [n]yw 复制n个词 [n]yh 复制光标左边n个字符 [n]yl 复制光标右边n个字符 y0 从光标当前位置复制到行首 y$ 从光标当前位置复制到行尾 ygg | y1G 复制光标及光标以上的所有行 yG 复制光标及光标以下的所有行 :m,ny 复制m行到n行的内容 yaw 复制一个词，即使光标不在词首和词尾 yas 复制一个句子，即使光标不在词首和词尾 b, w, e大写时，表示忽略一些标点符号 粘贴 快捷键 功能 p 粘贴到光标所在行之后 P 粘贴到光标所在行之前 文本对象 c(change), y(yank), d(delete), p(paste)都可以跟文本对象，进行更复杂的操作 aw：一个词 as：一句 ap：一段 ab：一块（包含在圆括号中的） 寄存器 Vim中的复制、删除的内容都会被存放到默认（未命名）寄存器中，可以在相关命令前添加字母表示将数据放入指定寄存器中 字符 说明 a-z 拷贝内容到寄存器，如ayy把当前行的内容放入a寄存器 A-Z 追加内容到寄存器，如Ayy把当前行的内容追加到a寄存器中 :reg 显示所有寄存器的内容 \"\" 不加寄存器索引时，默认使用的寄存器 \"* 拷贝内容到默认缓冲区 \"+ 拷贝内容到系统剪贴板 vim --version | grep clipboard 用来检查支不支持系统剪切板 加号（+）开头表示支持，减号（-）开头表示不支持 文件加解密 ｀vim -x file｀ 开始编辑一个加密的文件 快捷键 功能 :X 为当前文件设置密码 :set key= 去除文件的密码 文件的编码 快捷键 功能 :e ++enc=utf8 filename 使用utf-8的编码打开指定文件 :w ++enc=gbk 转存为gbk编码 :set fenc | fileencoding 查看当前文件的编码 在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936 vim会为要打开的文件选择合适的编码，注意编码之间不要留空格 cp936对应于gbk编码，ucs-bom对应于windows下的文件格式 文件换行格式 有三种文件换行格式：dos, unix, mac 系统 换行 dos \\r\\n（CRLF）（ASCII 13,10） unix \\n（LF）（ASCII 10） mac \\r（CR）（ASCII 13） 快捷键 功能 :e ++ff=dos FILENAME 用dos格式来打开指定文件 :w ++ff=mac FILENAME 以mac格式存储到指定文件 :set ff 显示当前文件的格式 在vimrc中添加set fileformats=unix,dos,mac，vim会自动识别文件格式 vim退格键 vim 退格键（backspace）不能用是由于vi一致性模式造成的 去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限set nocompatible backspace有几种工作方式，默认是vi兼容的set backspace=indent,eol,start |可选值 | 说明 | |---|--- | |indent | 如果用了:set indent等自动缩进，必须设置这个选项 | |eol | 想通过退格键合并两行，需要设置eol | |start | 要想删除此次插入前的输入，需设置这个 | 参考 Vim使用笔记Stack Overflow：帮助一百万开发者退出 Vimvim命令模式与输入模式切换vim 退格键（backspace）不能用vim自定义设置-配置文件 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-edit/vimkuai-su-bian-ji.html":{"url":"base-chapter/text-edit/vimkuai-su-bian-ji.html","title":"vim快速编辑","keywords":"","body":"基本排版缩进缩出折叠展开大小写转换撤消与重做拼写检查自动补全参考基本排版 快捷键 功能 :ce(nter) 本行文字居中 :le(ft) 本行文字靠左 :ri(ght) 本行文字靠右 gq 对选中的文字重排，即对过长的文字进行断行 gqq 重排当前行 gq[n]q 重排当前n行 gqap 重排当前段 gq[n]ap 重排当前n段 gq[n]j 重排当前行和下面n行 gqQ 重排当前段至文章末尾 J 拼接当前行和下一行 gJ 同 J ，不过合并后不留空格 缩进缩出 快捷键 功能 >> 正常模式下，按两下>光标所在行会缩进 [n]>> 如果先按了n，再按两下>，光标及以下的n行会缩进 正常模式下，按两下光标所在行会缩出 [n] 如果先按了n，再按两下，光标及以下的n行会缩出 == 在正常模式下调整代码行 = 在可视模式下调整代码块 [n]= 调整n行代码的缩排 折叠展开 快捷键 功能 zf 创建折叠，在一个可视区域上使用该命令 zd 删除当前行的折叠 zD 删除当前行的折叠 zfap 折叠光标所在的段 zo 打开折叠的文本 zc 收起折叠 za 打开/关闭当前折叠 zr 打开嵌套的折叠 zm 收起嵌套的折叠 zR | zO 打开所有折行 zM | zC 收起所有折行 zj 跳到下一个折叠处 zk 跳到上一个折叠处 zi 开启/关闭折叠 大小写转换 快捷键 功能 ~ 反转光标所在字符的大小写 u 把可视模式下选中的文本变为小写 U 把可视模式下选中的文本变为大写 gu + range 将指定范围的行变为小写 gU + range 将指定范围的行变为大写 ggguG，就是把开头到最后一行之间的字母全部变为小写 gu5j，把当前行和下面四行全部变成小写 gg表示开头，G表示结尾，5j表示向下5行，5h表示向上6行 撤消与重做 快捷键 功能 [n]u 取消n个改动 :undo 5 撤销5个改变 :undolist 你的撤销历史 U 取消当前行中所有的改动 ctrl + r 重做最后的改动 :earlier 1m 回到1分钟前 :later 60s 前进60秒 拼写检查 快捷键 功能 :set spell 开启拼写检查功能 :set nospell 关闭拼写检查功能 ]s 移到下一个拼写错误的单词 [s 移到上一个拼写错误的单词 z= 显示一个有关拼写错误单词的列表，可从中选择 zg 告诉拼写检查器该单词是拼写正确的 zw 告诉拼写检查器该单词是拼写错误的 自动补全 下文中的大写C代表Control键 快捷键 功能 C-x C-s 拼写建议 C-x C-v 补全vim选项和命令 C-x C-n 用文档中出现过的单词补全当前的词，直接按C-n和C-p也可以 C-x C-p 用文档中出现过的单词补全当前的词，直接按C-n和C-p也可以 C-x C-l 补全整行关键字 C-x C-f 补全文件路径。弹出菜单后，按C-f循环选择，按C-n和C-p上下选择 C-x C-o 补全关键字和函数名 C-x C-i 根据头文件内关键字补全 C-x C-d 补全宏定义 当弹出补全菜单后，以下快捷键可以选择 快捷键 功能 C-p 向前切换成员 C-n 向后切换成员 C-e 退出下拉菜单，并退回到原来录入的文字 C-y 退出下拉菜单，并接受当前选项 参考 Vim使用笔记 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-edit/vimcha-zhao-ti-huan.html":{"url":"base-chapter/text-edit/vimcha-zhao-ti-huan.html","title":"vim查找替换","keywords":"","body":"查找替换范围正则元字符基本元字符量词元字符位置元字符元字符的转义高级正则参考查找 快捷键 功能 /PATTERN 在后面的文本中查找something ?PATTERN 在前面的文本中查找something /PATTERN/+N 将光标停在pattern匹配行的后面第N行上 /PATTERN/-N 将光标停在pattern匹配行的前面第N行上 n 查找下一个，和查找方向有关 N 查找上一个，和查找方向有关 * 向下搜索光标所在词 g* 向下搜索光标所在词，但部分符合即可 # 向上搜索光标所在词 g# 向上搜索光标所在词，但部分符合即可 q: 正常模式下，q然后按':'，打开命令行历史缓冲区 q/ 正常模式下，q然后按'/'，可以正向查找命令历史记录 q? 正常模式下，q然后按'?'，可以反向查找命令历史记录 可以用grep或vimgrep查找一个模式都在哪些地方出现过 :grep是调用外部的grep程序 vimgrep使用vim自己的查找算法 % 代表正在编辑的文件 用法为:vim[grep]/pattern/[g] [j] files g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现 j的含义是grep结束后，结果停在第j项，默认是停在第一项 vimgrep前面可以加数字限定结果的上限，如:1vim/pattern/ % 只查找第一个 vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。 比如电子书中每一节的标题形式为n.xxx，你就可以这样:vim/^d{1,}./ % 然后用:cw 或 :copen查看结果 可以用ctrl-w + H 把quickfix窗口移到左侧，就更像个目录了 替换 快捷键 功能 :s/PATTERN/STRING 替换第一个匹配为STRING :s/PATTERN/STRING/g 替换*当前行所有的匹配为STRING :n1,n2s/PATTERN/STRING/g 替换第n1到n2行所有的匹配为STRING :%s/PATTERN/STRING/g 替换文件中所有的匹配为STRING :%s/^/STRING/g 在每一行的行首插入STRING，^表示行首 :%s/$/STRING/g 在每一行的行尾插入STRING，$表示行尾 % 代表所有行 替换语法后面可跟多个标记 快捷键 功能 c 表示每个替换都将需要用户确认 i 表示匹配时忽略(ignore)大小写 g 表示替换一行上的所有匹配 还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种Ex命令，语法为 :[range]g[lobal][!]/pattern/ex_command 例如 :%g/^xyz/d表示对xyz开头的行执行delete命令 下面是Ex命令表，更多内容参考这里 命令 说明 :[range]d[elete] [x] 删除指定范围内的行【到寄存器x中】 :[range]y[ank] [x] 复制指定范围的行【到寄存器x中】 :[line]put [x] 在指定行后粘贴寄存器x中的内容 :[range]copy ADDRESS 把指定范围内的行拷贝到address所指定的行下 :[range]move ADDRESS 把指定范围内的行移动到address所指定的行下 :[range]join 连接指定范围内的行 :[range]normal COMMANDS 对指定范围内的每一行执行普通模式命令commands 范围 vim的很多命令前面都可以指定范围(range)，如果不指定范围则表示当前行 字符 说明 m,n 从m行到n行 0 最开始一行 $ 最后一行 . 当前行 % 所有行 正则 正则表达式能够实现更为复杂的查找 :help pattern 可以查看帮助文档 元字符 元字符是在正则中有特殊含义的字符，不当做字符本身来解释，表示为单个字符或斜杠与单个字符组成的双元字符 基本元字符 元字符 说明 . 匹配任意一个字符 . 匹配任意一个字符 [] 字符集匹配，匹配方括号中定义的字符集之一 [^] 字符集否定匹配，匹配没有在方括号中定义的字符 [0-9] 所有的数字 [a-z] 所有的小写字母 [A-Z] 所有的大写字母 [a-zA-Z] 所有的字母 [0-9a-zA-Z] 所有的数字和字母 [abc-e] 匹配方括号中的任意一个字符，-表示字符范围 [^abc] ^符号表示匹配除方括号中字符之外的任意字符 \\d 匹配阿拉伯数字，等同于[0-9] \\D 匹配阿拉伯数字之外的任意字符，等同于[^0-9] \\x 匹配十六进制数字，等同于[0-9A-Fa-f] \\w 匹配单词，等同于[0-9A-Za-z_] \\W 匹配单词之外的任意字符，等同于[^0-9A-Za-z_] \\t 匹配TAB字符 \\s 匹配空白字符，等同于[ \\t] \\S 匹配非空白字符，等同于[^ \\t] \\a 所有的字母字符. 等同于[a-zA-Z] \\l 小写字母[a-z] \\L 非小写字母[^a-z] \\u 大写字母 [A-Z] \\U 非大写字母[A-Z] \\| 表示或 量词元字符 元字符 说明 * 匹配0个或多个(匹配优先) + 匹配1个或多个(匹配优先) \\? 0个或1个(匹配优先)，\\?不能在 ? 命令（逆向查找）中使用 \\= 0个或1个(匹配优先)，\\=不能在 ? 命令（逆向查找）中使用 {n,m} 匹配n个到m个(匹配优先) {n,} 最少n个匹配(匹配优先) {,m} 最多m个匹配(匹配优先) {n} 恰好n个匹配 位置元字符 元字符 说明 $ 在行尾匹配 ^ 在行首匹配 \\ 匹配以某些字符开头的(\\)的单词，单词是用标点符号或空格来分隔的 \\> 匹配以某些字符结尾的(\\)的单词，单词是用标点符号或空格来分隔的 元字符的转义 如果想要元字符表达字符本身的意思，则需要使用反斜杠转义 转义 说明 \\. 匹配 . 字符 \\* 匹配 * 字符 \\\\ 匹配 \\ 字符 \\/ 匹配 / 字符 \\` 匹配 ` 字符 \\[ 匹配 [ 字符 高级正则 更多高级内容，例如magic，正反向查找，贪婪模式和非贪婪模式等参考这里 参考 Vim使用笔记Vim的正则表达式VIM中使用正则匹配中文global命令Vim高级进阶之ex命令集vim查找替换及正则表达式的使用 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-edit/vimduo-ge-wen-jian.html":{"url":"base-chapter/text-edit/vimduo-ge-wen-jian.html","title":"vim多个文件","keywords":"","body":"多文件编辑多标签编辑文件缓冲区水平分割垂直分割关闭子窗口切换和移动窗口调整窗口大小参考多文件编辑 vim一次可以打开多个文件 vim －》 在同一个窗口中编辑多个文件 vim -o －》 在水平分割的多个窗口中编辑多个文件 vim -O －》 在垂直分割的多个窗口中编辑多个文件 快捷键 功能 :f FILENAME 重命名当前窗口 :n[ext] 编辑下一个文件 :2n 编辑后面第2个文件，依次类推 :N 编辑上一个文件 :2N 编辑前面第2个文件，依次类推 :wnext 保存当前文件，并编辑下一个文件 :wprevious 保存当前文件，并编辑上一个文件 :args 显示文件列表 :n FILENAMES 指定新的文件列表 :args FILENAMES 指定新的文件列表 多标签编辑 vim一次可以打开多个标签页，每个文件一个标签页 vim -p 快捷键 功能 :tabe 如果加文件名，就在新的标签中打开这个文件，否则打开一个空缓冲区 :tabnew 如果加文件名，就在新的标签中打开这个文件，否则打开一个空缓冲区 ctrl-w + gf 在新的标签页里打开光标下路径指定的文件 :tabn 切换到下一个标签（Control + PageDown） :tabp 切换到上一个标签（Control + PageUp） [n]gt 切换到下一个标签。如果加了n，就切换到第n个标签，第一个是1 :tab split 将当前缓冲区的内容在新页签中打开 :tabc[lose] 关闭当前的标签页 :tabo[nly] 关闭其它的标签页 :tabm[ove] [N] 移动标签页，移动到第N个标签页之后 :tabs 列出所有的标签页和它们包含的窗口 文件缓冲区 快捷键 功能 :buffers 显示缓冲区列表 :ls 显示缓冲区列表 :files 显示缓冲区列表 ctrl + ^ 在最近两个缓冲区间切换 :bn 下一个缓冲区 :bp 上一个缓冲区 :bl 最后一个缓冲区 :b[n] 切换到第n个缓冲区 :[n]b 切换到第n个缓冲区 :[n]bw(ipeout) 彻底删除第n个缓冲区 :[n]bd(elete) 删除第n个缓冲区，并未真正删除，还在unlisted列表中 :ba[ll] 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口 水平分割 快捷键 功能 :sp[lit] 水平分割窗口 :sp[lit] FILENAME 水平分割窗口，并在新窗口中显示另一个文件 :[N]sp[lit] 水平分割出一个n行高的窗口 :[N]new 水平分割出一个n行高的窗口，并编辑一个未命名文件 C-W + f 水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 垂直分割 快捷键 功能 :vsp[lit] 垂直分割窗口 :vsp[lit] FILENAME 垂直分割窗口，并在新窗口中显示另一个文件 :[N]vsp[lit] 垂直分割出一个n列宽的窗口 :[N]vnew 垂直分割出一个n列宽的窗口，并编辑一个未命名文件 关闭子窗口 快捷键 功能 :qa[ll] 关闭所有窗口，退出vim :wa[ll] 保存所有修改过的窗口 :on[ly] 只保留当前窗口，关闭其它窗口(C-W + o) :close 关闭当前窗口(C-W + c)，:q :x也能关闭 切换和移动窗口 下文中的大写C代表Control键，加号表示组合的意思，不必输入 快捷键 功能 C-W + C-W 切换到下一个窗口 C-W + w 切换到下一个窗口 C-W + p 切换到前一个窗口 C-W + h(l,j,k) 切换到左（右，下，上）的窗口 C-W + H(L,K,J): 将当前窗口移动到最左（右、上、下）面 C-W + t(b) 切换到最上（下）面的窗口 C-W + r 旋转窗口的位置 C-W + T 将当前的窗口移动到新的标签页上 调整窗口大小 下文中的大写C代表Control键，加号表示组合的意思，不必输入 快捷键 功能 [n] C-W + + 当前窗口增高n行 [n] C-W + - 当前窗口减小n行 [n] C-W + 当前窗口减少n列 [n] C-W + > 当前窗口增宽n列 [n] C-W + _ 当前窗口尽可能高，也可以用n设定行数 [n] C-W + | 当前窗口尽可能宽，也可以用n设定列数 C-W + = 所有窗口同样高度 :resize n 当前窗口设置为n行高 :resize +n 当前窗口增加n行 :resize -n 当前窗口减少n行 :vertical resize n 当前窗口设置为n列宽 :vertical resize +n 当前窗口增加n列 :vertical resize -n 当前窗口减少n列 参考 Vim使用笔记vim中多标签和多窗口的使用 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-edit/vimbian-cheng-fu-zhu.html":{"url":"base-chapter/text-edit/vimbian-cheng-fu-zhu.html","title":"vim编程辅助","keywords":"","body":"光标移动修改、剪切、复制ctagscscopegtags编译调试快速修复窗口参考光标移动 快捷键 功能 gd 跳转到*局部变量的定义处 gD 跳转到全局变量的定义处，从当前文件开头开始搜索 g; 上一个修改过的地方 g, 下一个修改过的地方 [[ 跳转到上一个函数块开始，需要有单独一行的{ [] 跳转到上一个函数块结束，需要有单独一行的} ]] 跳转到下一个函数块开始，需要有单独一行的{ ][ 跳转到下一个函数块结束，需要有单独一行的} [{ 跳转到当前块开始处 ]} 跳转到当前块结束处 [/ 跳转到当前注释块开始处 ]/ 跳转到当前注释块结束处 % 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃 修改、剪切、复制 快捷键 功能 ci', di', yi' 修改、剪切或复制'之间的内容 ca', da', ya' 修改、剪切或复制'之间的内容，包含' ci\", di\", yi\" 修改、剪切或复制\"之间的内容 ca\", da\", ya\" 修改、剪切或复制\"之间的内容，包含\" ci(, di(, yi( 修改、剪切或复制()之间的内容 ca(, da(, ya( 修改、剪切或复制()之间的内容，包含() ci[, di[, yi[ 修改、剪切或复制[]之间的内容 ca[, da[, ya[ 修改、剪切或复制[]之间的内容，包含[] ci{, di{, yi{ 修改、剪切或复制{}之间的内容 ca{, da{, ya{ 修改、剪切或复制{}之间的内容，包含{} ci, di, yi 修改、剪切或复制<>之间的内容 ca, da, ya 修改、剪切或复制<>之间的内容，包含<> ctags 遍历源代码文件生成tags文件 ctags -R --c++-kinds=+p --fields=+iaS --extra=+q . vim操作 快捷键 功能 :set tags=TAGS_PATH 设置ctags文件的路径 :tag xyz 跳到xyz的定义处，或者在xyz处按（C-]），返回用（C-t） :stag xyz 用分割的窗口显示xyz的定义，或者在xyz处按（C-W + ]） :ptag xyz 在预览窗口中打开xyz的定义，或者在xyz处按（C-W + }） :pclose 关闭预览窗口（C-W + z） :pedit abc.h 在预览窗口中编辑abc.h :psearch abc 搜索当前文件和当前文件include的文件，显示包含abc的行 有时一个tag可能有多个匹配，会先跳转到第一个匹配处 快捷键 功能 :[n]tnext 后面第n个匹配 :[n]tprev 前面第n个匹配 :tfirst 第一个匹配 :tlast 最后一个匹配 :tselect TAG_NAME 打开选择列表 tab键补齐，继续按tab键，会显示其他的 快捷键 功能 :tag xyz 用以xyz开头的tag名补全 :tag /xyz 用含有xyz的tag名补全 cscope 提供交互式查询语言符号功能，如查询哪些地方使用某个变量或调用某个函数 cscope -Rbq -f vim操作 快捷键 功能 :cs add CSCOPE_PATH WORK_DIR 添加cscope.out文件到工作目录 :cs find c func 查找func在哪些地方被调用 :cw 打开quickfix窗口查看结果 gtags Gtags综合了ctags和cscope的功能 快捷键 功能 :Gtags FUNC_NAME 定位到 funcname 的定义处 :Gtags -r FUNC_NAME 查询 funcname 被引用的地方 :Gtags -s SYMBOL 定位到 symbol 出现的地方 :Gtags -g STRING 定位到 string 出现的地方 :Gtags -gi STRING 定位到 string 出现的地方，忽略大小写 :Gtags -f FILENAME 显示 filename 中的函数列表，:Gtags -f % 显示当前文件 :Gtags -P FILENAME 显示包含特定模式的文件，:Gtags -P .h$ 显示所有头文件 :Gtags -P /vm/ 显示vm目录下的文件 编译调试 vim提供了:make来编译程序，默认调用的是make 如果你当前目录下有makefile，简单地调用:make即可 如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序 如果你只有一个abc.java文件 你可以设置makeprg为java的编译命令 set makeprg=javac\\ abc.java 然后调用:make即可 如果程序有错，可以通过quickfix窗口查看错误 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息 :setl efm=%A%f:%l:\\ %m,%-Z%p^,%-C%.%# %f表示文件名，%l表示行号，%m表示错误信息，其它的还不能理解 更多信息请参考 :help errorformat 快速修复窗口 是quickfix插件提供的功能，对编译调试程序非常有用 :) 快捷键 功能 :cw 打开快速修改窗口 :copen 打开快速修改窗口 :cclose 关闭快速修改窗口 快速修改窗口在make程序时非常有用，当make之后 快捷键 功能 :cc 显示编译错误的详细信息 :cl 在快速修改窗口中列出错误 :cn 定位到下一个错误 :cp 定位到上一个错误 :cr 定位到第一个错误 参考 Vim使用笔记将Vim改造为强大的IDE—Vim集成 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-edit/vimcao-zuo-ji-qiao.html":{"url":"base-chapter/text-edit/vimcao-zuo-ji-qiao.html","title":"vim操作技巧","keywords":"","body":"另外一些实用的快捷键命令行模式下的快捷键执行内部命令执行外部命令vim帮助vim技巧vim问题vim搭建IDE参考另外一些实用的快捷键 快捷键 功能 K 打开光标所在词的manpage g + C-G 统计全文或统计部分的字数 命令行模式下的快捷键 快捷键 功能 上下方向键 上一条或者下一条命令，如果已经输入了部分则找匹配的命令 左右方向键 左/右移一个字符 Shift-Left 左移一个单词 Shift-Right 右移一个单词 @ 重复上一次的命令 其他快捷键可以参照 shell概述 章节中的快捷键 执行内部命令 快捷键 功能 :pwd 显示vim的工作目录 :cd path 改变vim的工作目录 :set autochdir 让vim根据编辑的文件自动切换工作目录 :set nu 显示行号 :set nonu 隐藏行号 :set autoident 开启自动缩进 :set noautoident 关闭自动缩进 :set cindent 开启c风格的缩进 :set nocindent 关闭c风格的缩进 :set paste 开启粘贴模式 :set nopaste 开启粘贴模式 执行外部命令 快捷键 功能 :! cmd 执行外部命令 :!! 执行上一次的外部命令 :sh 调用shell，用exit返回vim :r !cmd 将命令的返回结果插入当前位置的下一行 :m,n !cmd 将文件的m行到n行之间的内容做为命令输入执行命令，会改变文件 :m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令，不会改变文件 vim帮助 命令帮助的格式为： 第一行指明怎么使用那个命令 然后是缩进的一段解释这个命令的作用 然后是进一步的信息 快捷键 功能 F1 查看帮助 :h(elp) 查看帮助 :help command 查看指定命令的帮助 :help user-manual 打开用户手册 :helptags FILE_PATH 为指定文档生成索引 :helpgrep 搜索整个帮助文档，匹配的列表显示在quickfix窗口 :ver 显示版本信息 vim技巧 Vim 中读写特殊字符 VIM中执行Shell命令（炫酷） 强悍的 vim —— 处理大小写转换 vim tab设置为4个空格 VIM 文件编码识别与乱码处理 Vim的分屏功能 在 Vim 中优雅地查找和替换 Vim查找替换及正则表达式的使用 vim清空文件所有内容 轻快的VIM（三） 无插件Vim编程技巧 在Linux下使用vim配合xxd查看并编辑二进制文件 vim编辑器---批量注释与反注释 Vimdiff 使用 vim问题 vim粘贴注释–解决方法 vim 退格键（backspace）不能用 vim fileencoding和encoding vi/vim使用入门: vimrc在哪儿? YouCompleteMe中Ctrl-P/Ctrl-N失效 UTF-8、BOM、的问题 vim搭建IDE Mac下打造vim+Python开发环境 VIM的自动补全 如何用Vim搭建IDE？ 一步一步带你安装史上最难安装的 vim 插件 —— YouCompleteMe 像 IDE 一样使用 vim 参考 Vim使用笔记vim粘贴注释–解决方法vim 退格键（backspace）不能用Vim 中读写特殊字符VIM中执行Shell命令（炫酷）强悍的 vim —— 处理大小写转换vim tab设置为4个空格VIM 文件编码识别与乱码处理 Rationale of fileencoding and encoding in vim or elsewhereVim的分屏功能vi/vim使用入门: vimrc在哪儿?在 Vim 中优雅地查找和替换Vim查找替换及正则表达式的使用 vim清空文件所有内容Mac下打造vim+Python开发环境VIM的自动补全如何用Vim搭建IDE？一步一步带你安装史上最难安装的 vim 插件 —— YouCompleteMe轻快的VIM（三）无插件Vim编程技巧Ctrl-P/Ctrl-N broken; whitelist filetypes for YCM在Linux下使用vim配合xxd查看并编辑二进制文件像 IDE 一样使用 vimvim编辑器---批量注释与反注释Vimdiff 使用UTF-8、BOM、的问题 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-edit/vimdiffshi-yong.html":{"url":"base-chapter/text-edit/vimdiffshi-yong.html","title":"vimdiff使用","keywords":"","body":"差异比较vimdiff打开方法交换窗口快速移动文件合并折叠展开批量操作参考差异比较 源程序文件（通常是纯文本文件）的比较和合并工具一直是软件开发过程中比较重要的组成部分 现在市场上很多功能很强大的专用比较和合并工具，比如 BeyondCompare 很多IDE 或者软件配置管理系统（比如Eclipse）都提供了内建的功能来支持文件的比较和合并 vimdiff vimdif可以比较两个文件的差异，并且进行编辑和合并差异 打开方法 vimdiff FILE_LEFT FILE_RIGHT vim -d FILE_LEFT FILE_RIGHT 或者在vim编辑器中 :vim FILE_LEFT 交换窗口 如果希望交换两个窗口的位置，或者希望改变窗口的分割方式 快捷键 说明 Ctrl-w + K 把当前窗口移到最上边 Ctrl-w + H 把当前窗口移到最左边 Ctrl-w + J 把当前窗口移到最下边 Ctrl-w + L 把当前窗口移到最右边 快速移动 默认左右两侧的屏幕滚动是同步的，如果不想要通过以下命令可以设置 :set noscrollbind 快捷键 说明 ]c 跳转到下一个差异点 [c 跳转到下一个差异点 在命令前加上数字可以移动相应的次数，默认为1次 文件合并 文件比较的最终目的之一就是合并，以消除差异。 命令 说明 dp 将正在编辑中的文件的差异应用到另一个文件中(diff put) do 将另一个文件中的差异应用到正在编辑的文件中(diff get) :diffupdate 当自动刷新失败时强制刷新比较结果 diff \"get\"，之所以不用dg，是因为dg已经被另一个命令占用了 折叠展开 比较和合并文件时经常需要结合上下文来确定最终要采取的操作 vimdiff缺省是会把不同之处上下各 6 行的文本都显示出来 其他的相同的文本行被自动折叠，可使用zo命令展开 命令 说明 zo （folding open） 展开折叠 zc （folding close）使用折叠 :set diffopt=context:3 设置上下文行数为3 之所以用z这个字母，是因为它看上去比较像折叠着的纸 批量操作 命令 说明 :qa （quit all）退出全部文件 :wa （write all）保存全部文件 :wqa （write, then quit all）保存全部文件，然后退出 :qa! （force to quit all）都不保存，然后退出 参考 技巧：Vimdiff 使用linux-vimdiff,diff,patch,cmp:文件比较读懂diff Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-process/":{"url":"base-chapter/text-process/","title":"文本处理","keywords":"","body":"本章是关于文本处理相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-process/grepcha-zhao.html":{"url":"base-chapter/text-process/grepcha-zhao.html","title":"grep查找","keywords":"","body":"grepegrepfgrep参考grep 主要用来提取文件或标准输入中的满足条件的行，默认使用BRE grep [OPTIONS] PATTERN [FILE...] grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...] 选项 含义 -c 只输出匹配行的数量 -i 搜索时忽略大小写 -h, --no-filename 查询多文件时不显示文件名 -H, --with-filename 查询多文件时显示文件名 -l, --file-with-matches 只列出符合匹配的文件名，而不列出具体的匹配行 -L, --files-without-match 只列出不符合匹配的文件名，而不列出具体的匹配行 -n, --line-number 列出所有的匹配行，并显示行号 -s, --no-messages 不显示文件不存在或无匹配文本的错误信息 -v, --revert-match 显示不匹配文本的所有行 -w, --word-regexp 匹配整词 -x, --line-regexp 匹配整行 -r, --recursive 当指定要查找的是目录而非文件时，必须使用这项参数 -q, --quiet， --silent 禁止输出任何结果，以退出状态表示搜索是否成功 -b, --byte-offset 打印匹配行距文件头部的偏移量，以字节为单位 -o 与-b选项结合使用，只显示搜索文字 -E 使用支持扩展的正则表达式(ERE) -F 不支持正则表达式，按照字符串的字面意思进行匹配 BRE和ERE的知识请参考前言篇中的模糊匹配章节 egrep egrep 执行效果与 grep -E 相似 fgrep fgrep 执行效果与 grep -F 相似 参考 grep命令Linux 的(cut,sed,awk,grep,sort)工具What is the difference between grep, egrep, and fgrep Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-process/printfshu-chu.html":{"url":"base-chapter/text-process/printfshu-chu.html","title":"printf输出","keywords":"","body":"printfprintf printf命令格式化并输出结果到标准输出 printf [选项] ... 格式如下： 格式 描述 %d 十进制有符号整数 %u 十进制无符号整数 %f 浮点数 %s 字符串 %c 单个字符 %p 指针的值 %e 指数形式的浮点数 %x 十六进制表示的整数，字母部分小写 %X 十六进制表示的整数，字母部分大写 %o 无符号以八进制表示的整数 %g 自动选择合适的表示法 %-5s 表示左对齐且宽度为5 %-6.2f 表示左对齐宽度为6，保留两位小数 转义序列： 转义 描述 \\a 警告 \\b 退格 \\c 使换行符失效或终止后续的转换（只在%b格式中有效） \\f 换页（form feed） \\n 换行（line feed） \\r 回车（carriage return） \\t 水平制表符 \\v 垂直制表符 \\\\ 反斜杠 \\ddd 表示1到3位数八进制值的字符，仅在格式字符串中有效 \\0ddd 表示1到3位的八进制值字符 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-process/sedchu-li.html":{"url":"base-chapter/text-process/sedchu-li.html","title":"sed处理","keywords":"","body":"sedsed脚本sed命令sed标记sed定界符sed示例追加（行下）（a\\）插入（行上）（i\\）替换（整行）（c\\）替换（部分）（s）删除（范围）（d）打印（范围）（p）使用 p 命令使用 p 标记读入文件（r）写入文件（w）下一个（n）已匹配字符串引用子串匹配大小写转换s命令y命令奇偶行参考sed sed是一种流编辑器，默认使用BRE，主要用来 自动编辑一个或多个文件 简化对文件的反复操作 编写转换程序等 sed [OPTION]... {script-only-if-no-other-script} [input-file]... 选项 说明 -e SCRIPT, --expression=SCRIPT 以指定的script命令来处理 -f FILE, --file=FILE 以指定的script文件来处理 -i 将处理后的结果替换掉原来的文件 -n, --quiet, ——silent 仅显示script处理的结果 -r, --regexp-extended 使用扩展的正则表达式(ERE) -h, --help 显示帮助 -V, --version 显示版本信息 sed脚本 格式如下，其中范围可以通过正则表达式来匹配确定 [RANGE]/PATTERN/PATTERN/[sed标记] [/PATTERN/]/PATTERN/PATTERN/[sed标记] [/PATTERN, PATTERN/]/PATTERN/PATTERN/[sed标记] sed命令 命令 说明 a\\ 在当前行下面插入文本（append） i\\ 在当前行上面插入文本（insert） c\\ 把匹配的行改为新的文本（change） d 删除匹配的行（delete） D 删除匹配的第一行 s 替换匹配为指定字符串 h 拷贝匹配的内容到内存中的缓冲区 H 追加匹配的内容到内存中的缓冲区 g 获得内存缓冲区的内容，并替换匹配的文本 G 获得内存缓冲区的内容，并追加到匹配文本的后面 l 列出不可打印字符的清单 n 读取下一个输入行，用下一个命令处理新的行 N 追加下一个输入行到匹配行后面 p 打印匹配的行 P 打印匹配的第一行(大写的p) q 退出sed b LABLE 跳到到脚本中带有标记的地方，不存在则到脚本的末尾 r FILE 从指定文件中读取行 t LABLE if分支 T LABLE 错误分支 w FILE 追加匹配内容到指定文件末尾 W FILE 追加匹配内容的第一行到指定文件末尾 ! 表示后面的命令对所有没有被选定的行发生作用 = 打印当前行的号码 # 把注释扩展到下一个换行符以前 sed标记 标记 说明 g 替换一行内的所有匹配 p 打印行 w 把行写入一个文件 x 表示匹配的内容和缓冲区中的内容 y 表示把一个字符翻译为另外的字符（但是不用于正则表达式） \\1 子串匹配标记 & 已匹配字符串标记 sed定界符 sed命令中字符 / 是定界分割符，也可以使用任意的定界符 sed 's:test:TEXT:g' sed 's|test|TEXT|g' 定界符出现在样式内部时，需要进行转义 sed 's/\\/bin/\\/usr\\/local\\/bin/g' sed示例 追加（行下）（a\\） 将 this is a test line 追加到以test开头的行后面sed '/^test/a\\this is a test line' test.conf 在 test.conf 文件第2行之后插入 this is a test line sed -i '2a\\this is a test line' test.conf 插入（行上）（i\\） 将 this is a test line 追加到以test开头的行前面 sed '/^test/i\\this is a test line' test.conf 在test.conf文件第2行之前插入this is a test line： sed -i '2i\\this is a test line' test.conf 替换（整行）（c\\） 将test开头的行整行替换为 this is a test line sed '/^test/c\\this is a test line' test.conf 将第二行整行替换为 this is a test line sed '2c\\this is a test line' test.conf 替换（部分）（s） 替换第一个test为tests sed 's/test/tests/' file 替换所有的test为tests sed 's/test/tests/' file 在匹配test和west之间的所有行的行末尾添加ha ha sed '/test/,/west/s/$/ha ha/' file 删除（范围）（d） 删除所有的空白行 sed '/^$/d' file 删除文件的第2行 sed '2d' file 删除文件最后一行 sed '$d' file 删除文件的第2行到末尾的所有行 sed '2,$d' file 删除文件中所有test开头的行 sed '/^test/'d file 打印（范围）（p） 使用 p 命令 sed '/test/{p;}' test.txt 使用 p 标记 所有在模板test和check所确定的范围内的行都被打印 sed -n '/test/,/check/p' file 打印从第5行开始到第一个包含以test开始的行之间的所有行 sed -n '5,/^test/p' file 读入文件（r） 读取testfile的内容并显示在filename中与test匹配的 所有的 匹配行后面 sed '/test/r testfile' filename 写入文件（w） 将filename与test匹配的 所有的 匹配行都写到testfile文件中 sed '/test/w testfile' filename 下一个（n） 则移动到匹配test行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续 sed '/test/{ n; s/aa/bb/; }' file 已匹配字符串 & 对应于之前所匹配到的内容 正则表达式 \\w+ 匹配每一个单词，使用 [&] 替换它 [root@zhujipeng /]# echo this is a test line | sed 's/\\w\\+/[&]/g' [this] [is] [a] [test] [line] 所有以127.0.0.1开头的行都会被替换成它自已加上空格和localhost sed 's/^127.0.0.1/& localhost/' file 引用子串匹配 匹配给定样式的其中一部分 [root@zhujipeng /]# echo this is digit 7 | sed 's/digit \\([0-9]\\)/\\1/' this is 7 大小写转换 s命令 小写转大写 sed 's/\\(test\\)/\\U\\1\\E/g' file 大写转小写 sed 's/\\(test\\)/\\L\\1\\E/g' file y命令 abcde中每个字符转变为对应的大写，不能使用a-z这种语法 sed 'y/abcde/ABCDE/' file ABCDE中每个字符转变为对应的小写，不能使用A-Z这种语法 sed 'y/ABCDE/abcde/' file 奇偶行 奇数行 sed -n 'p;n' test.txt 偶数行 sed -n 'n;p' test.txt 参考 sed命令Linux 的(cut,sed,awk,grep,sort)工具Sed to replace lower case string between two strings to upper case Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-process/awkchu-li.html":{"url":"base-chapter/text-process/awkchu-li.html","title":"awk处理","keywords":"","body":"awkawk命令awk脚本基本结构工作原理模式和操作模式操作内置变量（预定义变量）运算与判断算术运算符关系运算符赋值运算符逻辑运算符正则运算符其它运算符条件判断循环语句数组数学计算字符串时间其他函数参考awk awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。 数据可以来自标准输入(stdin)、一个或多个文件 支持用户自定义函数以及动态正则表达式等先进功能 有很多内建的功能，比如数组、函数等，和c语言类似 awk命令 格式如下 awk [options] [-v var=value]... ... awk [options] -f [-v var=value]... ... 选项 说明 -F FS 指定输入分隔符，可以是字符串或正则表达式 -v VAR=VALUE 赋值给一个用户定义变量，并传递给awk -f SCRIPTFILE 从脚本文件中读取awk命令 -m[fr] VAL 对val值设置限制 -mf选项限制分配给val的最大块数目 -mr选项限制分配给val的记录的最大数目 这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用 awk脚本 基本结构 awk 'BEGIN{ commands } pattern{ commands } END{ commands }' 工作原理 执行BEGIN{ commands }语句块中的语句 从文件或标准输入(stdin)逐行读取数据，执行pattern{ commands }语句块，直到输入流末尾 执行END{ commands }语句块中的语句 BEGIN语句块是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。 END语句块也是一个可选的语句块，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成 pattern语句块中的通用命令是最重要的部分，它也是可选的。 如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块 模式和操作 awk脚本是由模式和操作组成的 模式 模式（PATTERN）可以是以下任意一个： /正则表达式/：使用通配符的扩展集 关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。 模式匹配表达式：用运算符~（匹配）和 ~!（不匹配） BEGIN语句块、PATTERN语句块、END语句块 操作 操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内 变量或数组赋值 输出命令 内置函数 控制流语句 内置变量（预定义变量） 注意： [A][N][P][G]前缀表示第一个能够支持该变量的工具 [A]=awk、[N]=nawk、[P]=POSIXawk、[G]=gawk，区别参见这里 变量 说明 $0 执行过程中当前行的文本内容 $n 当前记录的第n个字段 [N] ARGC 命令行参数的个数 [N] ARGV 包含命令行参数的数组 [G] ARGIND 命令行中当前文件的位置（从0开始算） [G] CONVFMT 数字转换格式（默认值为%.6g） [P] ENVIRON 环境变量相关的数组 [N] ERRNO 最后一个系统错误的描述 [G] FIELDWIDTHS 字段宽度列表（用空格键分隔） [A] FILENAME 当前输入文件的名称 [A] FS 输入字段分隔符（默认是任何空白符） [A] RS 输入记录分隔符（默认是一个换行符） [G] IGNORECASE 如果为真，则进行忽略大小写的匹配 [A] NF 表示字段数，在执行过程中对应于当前的字段号 [A] NR 表示记录数，在执行过程中对应于当前的行号 [P] FNR 同NR，但相对于当前文件 [A] OFMT 数字的输出格式（默认值是%.6g） [A] OFS 输出字段分隔符（默认值是一个空格） [A] ORS 输出记录分隔符（默认值是一个换行符） [N] RSTART 由match函数所匹配的字符串的第一个位置 [N] RLENGTH 由match函数所匹配的字符串的长度 [N] SUBSEP 数组下标分隔符（默认值是34） ARGC -> argument count | ARGV -> argument vector | FMT -> format | ENVIRON -> environment | F -> field | R -> record | O -> output 运算与判断 作为一种程序设计语言所应具有的特点之一，awk支持多种运算，这些运算与C语言提供的基本相同。 awk提供了一系列内置的运算函数（如log、sqr、cos、sin等） awk提供了一些对字符串进行操作的函数（如length、substr等） awk中允许进行多种测试，还提供了模式匹配表达式~（匹配）和~!（不匹配） 算术运算符 运算符 描述 + 正号 - 负号 + 加法 - 减法 * 乘法 / 除法 % 求余 ++ 自增 -- 自减 ^ 求幂 ** 求幂 所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0 关系运算符 运算符 描述 小于 小于等于 > 大于 >= 大于等于 == 等于 != 不等于 注意：小于和等于号之间没有空格，由于Markdown的原因多了一个空格 赋值运算符 运算符 描述 = 赋值 += 自增并赋值给当前变量 -= 自减并赋值给当前变量 *= 自乘并赋值给当前变量 /= 自除并赋值给当前变量 %= 求余并赋值给当前变量 ^= 求幂并赋值给当前变量 **= 求幂并赋值给当前变量 逻辑运算符 运算符 描述 && 逻辑与 | | 逻辑或 ! 逻辑非 正则运算符 运算符 描述 ~ 匹配正则表达式 ~! 不匹配正则表达式 其它运算符 运算符 描述 $ 引用字段 ?: C三元条件表达式 in 数组中是否存在某值 条件判断 为了方便判断和阅读，最好将多个语句用{}括起来 if(表达式) 语句1 else 语句2 if(表达式) {语句1} else if(表达式) {语句2} else {语句3} 每条命令语句后面可以用 ; 分号结尾 循环语句 while语句 while(表达式) {语句} do {语句} while(条件) for循环 for(变量 in 数组) {语句} for(初始变量;结束条件;表达式) {语句} 退出循环 break退出当层循环 continue跳过本次循环 next进入下一次循环 exit跳到END块，如果没有END块则终止脚本的执行 数组 awk的数组和c语言类似，但有以下不同 数组不必提前声明，也不必声明大小 数组元素用0或空字符串来初始化，由上下文而定 数组下标是从1开始，与C数组不一样 函数 描述 length 获取数组的长度 asort 对数组进行排序，返回数组长度 更多内容参考这里的数组部分 数学计算 公式中的参数值都是弧度，角度、弧度、三角函数的知识参考这里 ln － 以自然对数e为底） lg － 以10为底 logab － 以a为底，b为真数 函数 描述 sin( x ) 返回 x 的正弦，x 是弧度 cos( x ) 返回 x 的余弦， x 是弧度 atan2( y, x ) 返回 y/x 的反正切 exp( x ) 返回 x 幂函数 log( x ) 返回 x 的自然对数 sqrt( x ) 返回 x 平方根 int( x ) 返回 x 的取整值 rand( n ) 返回任意数字 n，其中 0 srand( [expr] ) 将 rand 函数的种子值设置为 Expr 参数的值，并返回先前的种子值 srand 如果省略 Expr 参数则使用某天的时间。 字符串 函数 注意：字符串函数中的起始编号都是1，查找失败返回都是0。缺省的字符串参数是正在处理的行 函数 描述 sub( Ere, Repl, [ In ] ) 用 Repl 参数指定的字符串替换 In 中匹配的部分并返回替换的数量 gsub( Ere, Repl, [ In ] ) 除了替换所有匹配外，和 sub 函数一样 index( String1, String2 ) 在 String1 查找首次String2出现的位置 length [(String)] 返回 String 参数指定的字符串的长度（以字符为单位） blength [(String)] 返回 String 参数指定的字符串的大小（以字节为单位） substr( String, M, [ N ] ) 从 M 处开始，截取N个长度的子串，N省略则到末尾 match( String, Ere ) 在 String1 查找首次 Ere 匹配的位置。RSTART 特殊变量设置为返回值，未匹配则为0。RLENGTH 特殊变量设置为匹配的字符串的长度。未匹配则为－1 split( String, A, [Ere] ) 将 String 参数指定的参数分割为数组A，并返回数组的长度。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数） tolower( String ) 转换为小写，映射由当前语言环境的 LC_CTYPE 定义 toupper( String ) 转换为大写，映射由当前语言环境的 LC_CTYPE 定义 printf(Format, Expr, Expr, . . . ) 根据 Format 参数来格式化 Expr 参数指定的表达式并返回最后生成的字符串 格式化 格式化参照 printf 命令和c语言的 printf()函数 时间 函数 格式 描述 mktime( YYYY MM dd HH MM ss[ DST]) 生成时间格式串 strftime([format [, timestamp]]) 格式化时间输出 systime() 返回从1970年1月1日开始到当前时间(不计闰年)的整秒数 格式化 格式 描述 %a 星期的缩写(Sun) %A 星期的完整写法(Sunday) %b 月名的缩写(Oct) %B 月名的完整写法(October) %c 本地日期和时间 %d 十进制日期 %D 日期 (08/10/25) %e 日期，如果只有一位会补上一个空格 %H 用十进制表示24小时格式的小时 %I 用十进制表示12小时格式的小时 %j 从1月1日起一年中的第几天 %m 十进制表示的月份 %M 十进制表示的分钟 %p 12小时表示法(AM/PM) %S 十进制表示的秒 %U 十进制表示的一年中的第几个星期(星期天作为一个星期的开始) %w 十进制表示的星期几(星期天是0) %W 十进制表示的一年中的第几个星期(星期一作为一个星期的开始) %x 重新设置本地日期(08/10/25) %X 重新设置本地时间(12：00：00) %y 两位数字表示的年(19) %Y 四位数字表示的年(99) %Z 时区(PDT) %% 百分号(%) 其他函数 格式 描述 close( Expression ) 用同一个带字符串值的 Expression 参数来关闭由 print 或 printf 语句打开的或调用 getline 函数打开的文件或管道。如果文件或管道成功关闭，则返回 0；其它情况下返回非零值。如果打算写一个文件，并稍后在同一个程序中读取文件，则 close 语句是必需的 system( command ) 执行 Command 参数指定的命令，并返回退出状态。等同于 system 子例程 Expression | getline [ Variable ] 从来自 Expression 参数指定的命令的输出中通过管道传送的流中读取一个输入记录，并将该记录的值指定给 Variable 参数指定的变量。如果当前未打开将 Expression 参数的值作为其命令名称的流，则创建流。创建的流等同于调用 popen 子例程，此时 Command 参数取 Expression 参数的值且 Mode 参数设置为一个是 r 的值。只要流保留打开且 Expression 参数求得同一个字符串，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录 getline [ Variable ] 从 Expression 参数指定的文件读取输入的下一个记录，并将 Variable 参数指定的变量设置为该记录的值。只要流保留打开且 Expression 参数对同一个字符串求值，则对 getline 函数的每次后续调用读取另一个记录。如果未指定 Variable 参数，则 $0 记录变量和 NF 特殊变量设置为从流读取的记录 getline [ Variable ] 将 Variable 参数指定的变量设置为从当前输入文件读取的下一个输入记录。如果未指定 Variable 参数，则 $0 记录变量设置为该记录的值，还将设置 NF、NR 和 FNR 特殊变量 使用示例 awk脚本非常复杂，需要结合示例学习，示例部分参考awk命令中的示例 参考 awk命令Linux 的(cut,sed,awk,grep,sort)工具awk、nawk、mawk、gawk的简答介绍数学基础：角度，弧度，三角函数LC_ALL=C的含义linux系统locale的设定Explain the effects of export LANG, LC_CTYPE, LC_ALL Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-process/er-jin-zhi-chu-li.html":{"url":"base-chapter/text-process/er-jin-zhi-chu-li.html","title":"二进制处理","keywords":"","body":"hexdumpodxdd参考hexdump hexdump命令一般用来查看“二进制”文件的十六进制编码，但实际上它能查看任何文件，而不只限于二进制文件 hexdump [选项] [文件]... 选项 说明 -n length 只格式化文件的前length个字节 -C 输出规范的十六进制和ASCII码 -b 单字节八进制显示 -c 单字节字符显示 -d 双字节十进制显示 -o 双字节八进制显示 -x 双字节十六进制显示 -s 从偏移量开始输出 -e 指定格式字符串 格式字符串包含在一对单引号中，形如：'a/b \"format1\" \"format2\"' 每个格式字符串由三部分组成，每部分之间由空格分隔 b表示对每b个输入字节应用format1格式 a表示对每a个输入字节应用format2格式 一般a > b，a、b应用的格式与输入的顺序相反 b只能为1，2，4，a可以省略，省略则a=1 格式 说明 %02d 两位十进制 %03x 三位十六进制 %02o 两位八进制 %c 单个字符 %_ad 标记下一个输出字节的序号，用十进制表示 %_ax 标记下一个输出字节的序号，用十六进制表示 %_ao 标记下一个输出字节的序号，用八进制表示 %_p 对不能以常规字符显示的用 . 代替 同一行如果要显示多个格式字符串，则可以跟多个-e选项 od od命令用于输出文件的八进制、十六进制或其它格式编码的字节 通常用于显示或查看文件中不能直接显示在终端的字符 od [选项] [文件]... 选项 说明 -A, --address-radix=RADIX 选择以何种基数计算字码 -a 此参数的效果和同时指定“-t a”参数相同 -b 此参数的效果和同时指定“-t o1”参数相同 -c 此参数的效果和同时指定“-t c”参数相同 -d 此参数的效果和同时指定“-t u2”参数相同 -f 此参数的效果和同时指定“-t fF”参数相同 -h 此参数的效果和同时指定“-t x2”参数相同 -i 此参数的效果和同时指定“-t dI”参数相同 -j, --skip-bytes=BYTES 略过指定的字符数目 -l 此参数的效果和同时指定“-t dL”参数相同 -N, --read-bytes=BYTES 到指定的字符数目为止 -o 此参数的效果和同时指定“-t o2”参数相同 -s 此参数的效果和同时指定“-t d2”参数相同 -S BYTES, --strings[=BYTES] 只显示符合指定的字节目的字符串 -t, --format=TYPE 设置输出格式 -v, --output-duplicates 输出时不省略重复的数据 -w[BYTES], --width[=BYTES] 设置每列的最大字符数 -x 此参数的效果和同时指定“-h”参数相同 --help 在线帮助 --version 显示版本信息 xdd 详情参考 在Linux下使用vim配合xxd查看并编辑二进制文件 和 linux 命令 xxd linux下查看二进制文件 参考 hexdump命令Linux命令学习总结：hexdumpod命令Linux之od命令详解在Linux下使用vim配合xxd查看并编辑二进制文件linux 命令 xxd linux下查看二进制文件 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"base-chapter/text-process/qi-ta-de-chu-li.html":{"url":"base-chapter/text-process/qi-ta-de-chu-li.html","title":"其他的处理","keywords":"","body":"wcsortuniqcuttrsplittruncatetee参考wc 对文件进行统计 wc [OPTION]... [FILE]... 选项 说明 -c, --bytes 显示字节数 -m, --chars 显示字符数 -l, --lines 显示行数 -w, --words 显示单词数 -L, --max-line-length 显示最长行的长度 sort 对文本（来自文件或管道）进行排序 sort [OPTION]... [FILE]... 选项 说明 -b, --ignore-leading-blanks 忽略每行前面开始出的空格字符 -c, --check, --check=diagnose-first 检查文件是否已经按照顺序排序 -d, --dictionary-order 排序时处理英文字母、数字及空格字符外，忽略其他的字符 -f, --ignore-case 排序时将小写字母视为大写字母 -i, --ignore-nonprinting 排序时处理040至176之间的ASCII字符外，忽略其他的字符 -m, --merge 不排序，将排序好的文件进行合并 -M, --month-sort 将前面3个字母依照月份的缩写进行排序 -n, --numeric-sort 依照数值的大小排序 -o, --output=FILE 将排序后的结果存入指定的文件 -r, --reverse 以相反的顺序来排序 -t, --field-separator=SEP 指定排序时所用的分隔字符 -u, --unique 排序后去重 +N-N 以指定的列（N）范围来排序，范围由起始列（N）到结束列（N）的前一列 uniq 报告或忽略文件中的相邻重复行，一般与sort命令结合使用 uniq [OPTION]... [FILE]... 选项 说明 -c, --count 在每列前面显示该行重复出现的次数 -d, --repeated 只显示重复的行 -f, --skip-fields=N 忽略比较指定的列 -i, --ignore-case 比较时忽略大小写 -s, --skip-chars=N 忽略指定的前N个字符 -u, --unique 只显示不重复的行 -w, --check-chars=N 只比较最多N个字符 cut 显示行中的指定部分，删除文件中指定字段 cut [OPTION]... [FILE]... 选项 说明 -b, --bytes=LIST 仅显示行中指定范围的字节 -c, --characters=LIST 仅显示行中指定范围的字符 -d, --delimiter=DELIM 指定字段的分隔符，默认为“TAB” -f, --fields=LIST 显示指定字段（数字）的内容 -n 与“-b”选项连用，不分割多字节字符 --complement 补足被选择的字节、字符或字段 --output-delimiter=STRING 指定输出内容的字段分割符 --help 显示指令的帮助信息 --version 显示指令的版本信息 tr 对来自标准输入的字符进行替换、压缩和删除 tr [OPTION]... SET1 [SET2] 选项 说明 -c, -C, --complement 对字符集求补集 -d, --delete 删除所有属于字符集1的字符 -s, --squeeze-repeats 把连续重复的字符替换为一个字符 -t, --truncate-set1 删除第一字符集较第二字符集多出的字符 大小写转化 tr 'A-Z' 'a-z' 大写转小写tr 'a-z' 'A-Z' 小写转大写 文件格式转换 Mac -> UNIX：tr \"\\r\" \"\\n\" unixfile UNIX -> Mac：tr \"\\n\" \"\\r\" macfile DOS -> UNIX：tr -d \"\\r\" unixfile UNIX -> DOS：awk '{ print $0\"\\r\" }' dosfile DOS -> MAC：tr -d \"\\n\" macfile MAC -> DOS： Mac -> UNIX, UNIX -> DOS 空行多余的合并 tr -s \"\\n\" 显示PATH的路径 echo $PATH | tr \":\" \"\\n\" 用问号显示不可打印字符 tr -c '[:cntrl:]' '[?]' split 将一个大文件分割成很多个小文件 split [OPTION]... [INPUT [PREFIX]] 选项 说明 -b, --bytes=SIZE 每一部分的大小，单位为 byte -C, --line-bytes=SIZE 单行的最大字节数 -d, --numeric-suffixes[=FROM] 使用数字作为后缀 -l, --lines=NUMBER 输出行数 truncate 将文件缩减或扩展至指定大小 truncate [OPTION]... FILE... 选项 说明 -c, --no-create 不创建文件 -o, --io-blocks 将SIZE 视为IO 块数而不使用字节数 -r, --reference=RFILE 使用此文件的大小 -s, --size=SIZE 使用指定大小 --help 显示此帮助信息并退出 --version 显示版本信息并退出 tee 将数据重定向到文件，并重定向数据的副本作为后续命令的标准输入 tee [OPTION]... [FILE]... 选项 说明 -a, --append 向文件中重定向时使用追加模式 -i, --ignore-interrupts 忽略中断（interrupt）信号 参考 wc命令sort命令uniq命令cuttr命令split命令truncate命令tee命令linux sort,uniq,cut,wc命令详解DOS和UNIX文本文件之间相互转换的方法How to get only the unique results without having to sort data Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/user-about/":{"url":"medial-chapter/user-about/","title":"用户相关","keywords":"","body":"本章是关于用户相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/user-about/yong-hu-jiao-hu-ming-ling.html":{"url":"medial-chapter/user-about/yong-hu-jiao-hu-ming-ling.html","title":"用户交互命令","keywords":"","body":"用户登录sshsshpassexpect免密登录用户切换susudorunuser参考用户登录 ssh 远程登录和数据转发 ssh [-1246AaCfgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-L [bind_address:]port:host:hostport] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q cipher | cipher-auth | mac | kex | key] [-R [bind_address:]port:host:hostport] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname [command] ➜ ~ ssh root@192.168.8.238 root@192.168.8.238's password: Last login: Sun Oct 29 05:06:33 2017 from 192.168.8.192 [root@localhost ~]# ssh登录部分不复杂，复杂的部分在于数据转发，详情参见这里 ssh -NL 0.0.0.0:3000:127.0.0.1:3001 root@101.236.56.121 上述命令代表将发送到101.236.56.121的3000端口的数据转发到本机（127.0.0.1）的3001端口 sshpass 可以指定密码的远程登录工具，需要额外安装，详情参见这里 expect 登陆脚本如下，参数为主机和密码，用户名按需修改，配合item2的profile非常不错 #! /usr/bin/expect set host [ lindex $argv 0 ] set pass [ lindex $argv 1 ] set timeout 10 spawn ssh -o ServerAliveInterval=60 root@$host expect { \"*yes/no\" { send \"yes\\r\"; exp_continue} \"*password\" {send \"${pass}\\r\"} } interact 免密登录 每次登陆都需要输入密码很麻烦，可以通过免密来解决，详情参考这里 ssh-copy-id命令可以简化拷贝过程 用户切换 su 切换用户 格式如下 su [选项] [用户名] 选项 说明 -c command, --command=command 切换时执行命令 -, -l, --login 切换时使用登陆模式，重新读取环境变量 -m, -p 切换时保留环境变量，如果使用了－l选项，忽略该选项 -s SHELL, --shell=SHELL 切换时指定使用的shell sudo 提升普通用户的权限 su命令允许普通用户完全变更为root用户身份 但这也无疑会暴露了超级管理员的密码，使得系统增添很多的安全隐患 因此我们需要使用sudo程序来仅将特定命令的执行权限赋予给指定的用户 格式如下 sudo [选项] [用户名] 选项 说明 -b 在后台执行指定的命令 -k 清空安全时间，下次执行sudo时需要再次密码验证 -l 列出当前用户可执行的命令 -u user 用户名或UID值 以指定的用户身份执行命令 -p prompt 更改询问密码的提示语 l -> list | b -> background sudo相关配置文件和visudo命令可以参考这里 runuser 使用指定用户执行命令，详情参见这里 参考 Linux 下 SSH 命令实例指南基于SSH协议的端口转发通过 SSH 实现 TCP / IP 隧道（端口转发）动态端口转发：安装带有 SSH 的 SOCKS 服务器sshpass：一个很棒的免交互 SSH 登录工具expect - 自动交互脚本 如何在 CentOS / RHEL 上设置 SSH 免密码登录 Linux使用ssh公钥实现免密码登录Linuxssh 免密码设置失败原因总结KNOWN_HOSTS处理实战演练su命令与sudo服务Linux 下以其他用户身份运行程序—— su、sudo、runuserlinux 切换用户身份、su、sudo、/etc/sudoers linux 常用命令： runuser Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/user-about/yong-hu-xin-xi-ming-ling.html":{"url":"medial-chapter/user-about/yong-hu-xin-xi-ming-ling.html","title":"用户信息命令","keywords":"","body":"whowhoamiid参考who 显示登陆的用户 who [OPTION]... [ FILE | ARG1 ARG2 ] 选项 说明 -a, --all 显示所有的用户 -b, --boot 系统最后一次的启动时间 -d, --dead 显示死亡的进程 -H, --heading 显示头信息 -l, --login 显示登录的进程 --lookup 对主机做DNS查询 -m 只显示主机和用户名 -p, --process 显示init进程的子进程 -q, --count 所有的登录名和总数 -r, --runlevel 显示运行级别 -s, --short 显示简短的信息 -t, --time 显示最后的时钟信息 -T, -w, --mesg 显示用户的信息 -u, --users 显示登录的用户 [root@zhujipeng /]# who root pts/0 2017-10-29 14:27 (111.207.151.80) [root@zhujipeng /]$ whoami root [root@zhujipeng /]# su - dig 上一次登录：四 10月 19 16:58:38 CST 2017pts/4 上 [dig@zhujipeng /]$ who root pts/0 2017-10-29 14:27 (111.207.151.80) [dig@zhujipeng /]$ whoami dig whoami 查看正在使用的用户名 whoami [OPTION]... [root@zhujipeng /]# who root pts/0 2017-10-29 14:27 (111.207.151.80) [root@zhujipeng /]$ whoami root [root@zhujipeng /]# su - dig 上一次登录：四 10月 19 16:58:38 CST 2017pts/4 上 [dig@zhujipeng /]$ who root pts/0 2017-10-29 14:27 (111.207.151.80) [dig@zhujipeng /]$ whoami dig id 显示用户id信息 id [OPTION]... [USER] 选项 说明 -Z, --context 显示SELinux的安全策略 -g, --group 显示有效用户组的id -G, --groups 显示所有用户组的id -n, --name 显示名称而不是id，配合-ugG -r, --real 显示实际id而不是有效用户id，配合，配合-ugG`` -u, --user 显示有效用户id 参考 who、whoami命令 和 who am i 命令的区别id命令linux下进程的实际用户ID（有效组）和有效用户ID（有效组ID） Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/user-about/yong-hu-he-zu-guan-li.html":{"url":"medial-chapter/user-about/yong-hu-he-zu-guan-li.html","title":"用户和组管理","keywords":"","body":"linux用户和组管理用户标识root账户UIDGID用户命令用户管理useraddpasswduserdelusermod用户组管理groupaddgroupdelgroupmodnewgrpgroups默认权限（umask）密码文件参考linux用户和组管理 linux是一个多用户操作系统，多用户是指系统资源可以被不同用户各自拥有使用，即每个用户对自己的资源（例如：文件、设备）有特定的权限，互不影响 用户标识 root账户 root用户拥有极高的系统所有权，能够管理系统的各项功能，如添加/删除用户，启动/关闭进程，开启/禁用硬件设备等权限。使用root用户工作时不会受到权限的控制，因此执行危险操作时很容易因为失误对系统造成危害 UID UID（即User IDentification的缩写）：每个用户都有对应的UID值，就像我们的身份证号码，为操作系统内部所使用。 帐户名称与UID保存在/etc/passwd文件中，而帐户密码则保存在/etc/shadow文件中 超级用户UID(0): root用户默认为0。 系统用户UID(1-999): 系统中系统服务由不同用户运行，更加安全，默认被限制登陆系统。 普通用户UID(1000+): 即管理员创建的用于日常工作而不能管理系统的普通用户。 GID GID(即Group IDentification的缩写)：可将多个用户加入某个组中，方便指派任务或工作，为操作系统内部所使用。 用户组名称与GID保存在/etc/group文件中 用户命令 用户管理 使用操作系统系统资源的用户都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统 useradd useradd命令用于创建新的用户 格式如下 useradd [选项] 选项 说明 -b, --base-dir BASE_DIR 指定用户家目录的基准目录（默认为/home） -d, --home HOME_DIR 指定用户的家目录（默认为/home/username） -D, --defaults 显示或修改当前的默认值 -e, --expiredate EXPIRE_DATE 帐号有效截至日期，格式：YYYY-MM-DD，空字符串表示不过期 -g, --gid GROUP 指定一个初始用户组（必须已存在） -G, --groups GROUP... 指定一个或多个扩展用户组 -M 不创建用户主目录 -N, --no-user-group 不创建与用户同名的用户组 -s, --shell SHELL 指定默认的Shell -u, --uid UID 指定用户的UID -U, --user-group 创建一个和用户同名的组，并将用户添加到组中 passwd passwd命令用于修改用户的密码 格式如下 passwd [选项] [用户名] 选项 说明 -l, --lock 锁定用户禁止其登陆，只有root用户能用 -u, --unlock 解除锁定允许用户登陆，只有root用户能用 --stdin 允许从标准输入修改用户密码，如使用管道 -d, --delete 删除账号的密码 -e, --expire 强制用户下次登陆时修改密码 -S, --status 显示用户的密码状态 userdel userdel命令用于删除用户 格式如下 userdel [选项] 选项 说明 -f, --force 强制删除用户，即使用户仍然在登录状态 -r, --remove 同时删除用户，家目录与其相关文件 usermod usermod命令用于修改用户的属性 格式如下 usermod [选项] 选项 说明 -c, --comment COMMENT 填写帐号的备注信息 -d, --home HOME_DIR -m与-d连用，指定用户新的家目录并转移数据，否则新建家目录 -e, --expiredate EXPIRE_DATE 帐户到期时间，格式“YYYY-MM-DD” -g, --gid GROUP 变更所属用户组 -G, --groups GROUP... 变更扩展用户组 -l, --login NEW_LOGIN 修改用户名为新名字 -L, --lock 锁定用户禁止其登陆系统 -U, --unlock 解锁用户，允许其登陆系统 -s, --shell SHELL 修改默认终端 -u, --uid UID 修改用户的UID 用户组管理 用户可以属于多个组，并获得相关组的权限。用户的组分为主组和附属组 groupadd groupadd命令用于创建群组 格式如下 groupadd [选项] 选项 说明 -g, --gid GID 为用户组指定组标识号 -o, --non-unique 与-g选项同时使用，GID可以使用系统已有用户组的GID groupdel groupdel用来删除用户组 格式如下 groupdel [选项] groupmod groupmod用来需该用户组的属性 格式如下 groupmod [选项] 选项 说明 -g, --gid GID 为用户组指定新的组标识号 -o, --non-unique 与-g选项同时使用，新的GID可以使用系统已有用户组的GID -n NEW_GROUP 将用户组的名字改为新名字 newgrp newgrp用来将用户切换到另一个组中 格式如下 newgrp [选项] 选项 说明 - 用户重新登陆 groups groups用来查看当前的用户组，和id -gn命令一样 格式如下 groups [选项] 默认权限（umask） umask命令可以查看和设置文件的默认权限 umask设置的是权限“补码”，而chmod设置的是文件权限码 详情参考[这里][3] 密码文件 用户的帐户名称与UID保存在/etc/passwd文件中 用户的帐户密码则保存在/etc/shadow文件中 文件的格式详情参考这里 参考 linux用户和组管理详解LINUX UMASK详解 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/user-about/yong-hu-he-jin-cheng-id.html":{"url":"medial-chapter/user-about/yong-hu-he-jin-cheng-id.html","title":"用户和进程id","keywords":"","body":"id的概念实际用户ID（RUID）有效用户ID（EUID）设置用户ID位（SUID）保存的设置用户ID进程的idid详解权限测试流程设置用户id和设置组idseteuid函数案例分析参考id的概念 实际用户ID（RUID） 实际用户ID(real user id)，用于标识一个系统中用户是谁，一般是在登录之后就被唯一的确定，是登录的用户的uid 有效用户ID（EUID） 有效用户ID（effective user id），用于系统对进程的的访问权限进行检查，默认和实际用户ID一样 设置用户ID位（SUID） 用于对外的权限开放，它的作用是修改进行的有效用户ID，给进程赋予临时的特权，仅限可执行文件拥有这个标志位 保存的设置用户ID 是有效用户ID副本，既然是有效用户ID的副本，那么它的作用肯定是为了以后恢复有效用户ID，仅限可执行文件拥有这个标志位 进程的id 默认情况下进程的id就是启动进程时实际用户的id，权限检查时就是根据该id拥有的权限进行检查 有时需要修改进程的id，来提升（例如sudo和suid）或降低权限（例如nginx的worker进程和ubuntu中的rsyslog） 由于实际用户id是固定不变的，所以进程使用有效用户id来切换权限 id详解 权限测试流程 测试的参与者是进程的有效用户id、有效组id、文件的拥有者id、文件拥有者组id 进程的有效用户id是0（超级用户），则允许访问 进程的有效用户id等于文件拥有者id，则按照拥有者的权限访问 进程有效组id或附加组id之一等于文件拥有者组id，则按照文件拥有者组的权限访问 否则，按照文件的其他用户访问权限访问 如果没有权限，则提示permission denied 设置用户id和设置组id 当文件的设置用户id位和设置组id位没有打开，进程的有效用户id和有效组id保持不变，严格按照权限测试流程测试 文件的设置用户id位和设置组id位被打开，exec函数会把进程的有效用户id和有效组id设置为文件拥有者的用户id和组id，这时再进行权限测试，进程就拥有了和文件拥有者一样的访问权限 保存的设置用户id会用来恢复被改变的有效用户ID seteuid函数 特权用户可以设置有效用户id为任意实际用户ID 非特权用户只能将有效有户ID设置为自己的实际用户ID或保存的设置用户ID 案例分析 对于linux系统来说，用户的密码都存放在/etc/shadow文件下➜ ~ ll /etc/passwd -rw-r--r--. 1 root root 2681 8月 16 17:29 /etc/passwd /etc/passwd属于root用户，按照权限的知识，普通用户是无法修改该文件的，但是可以却通过passwd命令修改自己的密码➜ ~ ll /usr/bin/passwd -rwsr-xr-x. 1 root root 27832 6月 10 2014 /usr/bin/passwd passwd设置了suid位，使得进程在执行时临时改变了EUID，从而普通用户也能修改/etc/passwd文件 更多信息可以参考这里 参考 无死角理解保存的设置用户ID，设置用户ID位，有效用户ID，实际用户ID Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/user-about/huan-jing-bian-liang.html":{"url":"medial-chapter/user-about/huan-jing-bian-liang.html","title":"环境变量详解","keywords":"","body":"环境变量的定义环境变量的分类常见的环境变量环境变量的操作设置环境变量查看环境变量envset清除环境变量（unset）只读环境变量（readonly）局部环境变量（local）声明环境变量（declare）环境变量生效sourcefork and exec环境变量的加载参考环境变量的定义 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序需要使用到的信息 环境变量的分类 按照作用域来分 系统环境变量：系统环境变量对该系统中所有用户都有效 用户环境变量：顾名思义，这种类型的环境变量只对特定的用户有效 按照生命周期来分 永久的：需要用户修改相关的配置文件，变量永久生效 临时的： 利用export命令在当前终端下导出的环境变量，Shell终端关闭就失效 脚本中定义的环境变量，脚本结束就失效 常见的环境变量 环境变量 说明 PATH 指定可执行文件的搜索路径 HOME 指定用户的主工作目录 PWD 指定当所在目录 USER 指定当前用户名 LOGNAME 指定当前用户的登录名 HOSTNAME 指定主机的名称 SHELL 指定当前正在使用Shell LANG/LANGUGE 语言相关的环境变量，使用多种语言时可以修改此环境变量 IFS (Internal Field Seprator)，内部域分隔符，详情参考这里 LD_LIBRARY_PATH 动态库搜索路径，详情参考这里 环境变量的操作 设置环境变量 环境的格式为[export] 变量名=变量值:变量值...，多个值用英文冒号分开 在/etc/profile文件中添加变量，对所有用户生效（永久的） 在~/.bash_profile或~/.bashrc文件中添加变量，对当前用户生效（永久的） 在shell中使用export 变量名=变量值，只在当前的shell或其子shell下是有效的（临时的） 查看环境变量 env 显示所有环境变量，详情参考这里 格式如下 env [选项] [-] [变量名=变量值]... [命令 [参数]...] 选项 说明 -i, --ignore-environment 清空以前的环境变量，从新开始 -u, --unset=NAME 移除指定的环境变量 set 显示本地定义的shell变量，详情参考这里 格式如下 set [选项] [-o 选项名称] [--] [参数]... 选项 说明 -a 标示已修改的变量，以供导出到环境变量 -b 让中止的后台程序立刻回报执行状态 -C 禁止重定向覆盖已存在的文件 -e 若返回状态不等于0，则立即退出shell -f 取消通配符匹配 -h 记录函数的所在位置 -H Shell 可利用\"!\"加指令编号的方式来执行history中记录的指令 -k 指令所给的参数都会被视为此指令的环境变量 -m 开启任务控制 -n 只读取指令，而不实际执行 -P 启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接 -t 执行一条指令后退出shell -u 当执行时使用到未定义过的变量，则显示错误信息 -v 显示shell所读取的输入值 -x 执行指令后，会先显示该指令及所下的参数 清除环境变量（unset） 详情参考这里 只读环境变量（readonly） 详情参考这里 局部环境变量（local） 详情参考这里 声明环境变量（declare） 用于声明和显示已存在的shell变量，和typeset用法相同，详情参考这里 格式如下 declare [选项] [-p] [变量名=变量值]... 选项如下 可以使用加号“+”代替减号“-”，效果是关闭对应的属性，但是“+a”和“+r”无效。 选项 说明 -p 显示每个name的属性和值，不指定name时显示相应的所有变量的 -f 用于函数，显示函数定义 -F 用于函数，只显示函数名字，不显示函数定义 -a 用于索引（下标）数组 -A 用于关联（键值对）数组 -i 用于整数，可以进行数学运算 -n 用于引用变量的值所引用的值 -l 对变量赋值时，值的大写字母全部转换为小写 -u 对变量赋值时，值的小写字母全部转换为大写 -r 声明变量只读，不能被修改，也不能unset -g 在函数中declare变量的影响范围是局部的，除非使用了“-g” -x 等效于内置命令export -t 给每个name设置trace属性 环境变量生效 source 修改环境变量文件后需要执行source命令（一个点和source同义）使环境变量生效，详情参考这里 fork and exec fork和exec使得环境变量有不同的作用域，详情参考这里 环境变量的加载 详情参考bash的环境配置文件加载原理 参考 Linux环境变量总结我使用过的Linux命令之env - 显示当前用户的环境变量set命令shell的set命令unset命令readonly命令declare命令shell内建命令之declare、typeset、localShell中的IFS解惑Shell中的 IFSLinux 静态库与动态库搜索路径设置关于Shell的source、点（.）和export在 Shell 脚本中调用另一脚本的三种方式bash的环境配置文件加载原理交互式shell和非交互式shell、登录shell和非登录shell的区别login shell与non-login shell的区别 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/shell-about/":{"url":"medial-chapter/shell-about/","title":"shell相关","keywords":"","body":"本章是关于shell相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/shell-about/shelljiao-ben-ji-chu.html":{"url":"medial-chapter/shell-about/shelljiao-ben-ji-chu.html","title":"shell脚本基础","keywords":"","body":"基本格式执行方法使用路径名变量变量分类本地变量环境变量局部变量位置变量特殊变量$* 和 $@的区别引号函数函数返回值return语句echo语句全局变量readdeclare数组数组赋值查看元素数组长度元素大小数组区间删除元素重定向true 和 falsehere documentxargs命令shell中的括号参考基本格式 Shell脚本的文件名后缀通常是.sh （当然也可以使用其他后缀或者没有后缀，.sh只是为了规范） #!/bin/bash # 注释使用#号 # 第一行是Shebang # 告诉系统使用bash程序执行这个文件 执行方法 使用路径名 为文件添加可执行权限 chmod u+x test.sh 然后使用路径名执行 ./test.sh 变量 变量不需要声明，初始化不需要指定类型，变量值默认当作字符串处理 只能使用数字，字母和下划线，且不能以数字开头 变量名区分大小写 变量名要通俗易懂 变量赋值是通过等号(=)进行赋值 注意： 在变量、等号和值之间不能出现空格 变量分类 Shell变量有这几类：本地变量、环境变量、局部变量、位置变量、特殊变量 本地变量 对当前shell进程有效的，对当前进程的子shell进程和其它shell进程无效 定义：VAR_NAME=VALUE 变量引用：${VAR_NAME} 或者 $VAR_NAME 取消变量：unset VAR_NAME 环境变量 对当前shell进程及其子shell进程有效，对其它的shell进程无效 定义：export VAR_NAME=VALUE 要想对所有shell进程都有效需要配置到配置文件中 局部变量 在函数中调用，函数执行结束，变量就会消失 定义：local VAR_NAME=VALUE 位置变量 $0表示脚本名，$1-9表示第1到9个参数 特殊变量 变量 说明 $? 上一条命令的返回状态码， 返回状态码在0-255之间 $# 参数个数 $* 所有的参数 $@ 所有的参数 $_ 最后一个参数 $$ 当前shell的进程号（PID） $! 后台执行的最后一个命令的进程号（PID） $$ 可以实现脚本自杀，或者使用exit命令直接退出，也可以使用exit [num] $* 和 $@的区别 不带双引号时，$* 和 $@一样，都会对参数进行展开 带双引号时，$* 会将输入参数合并为一个参数 带双引号时，$@ 会保留输入参数的结构 [root@zhujipeng /]# cat test.sh echo 'print param from $*' for var in $* do echo $var done echo 'print param from $@' for var in $@ do echo $var done echo 'print param from \"$*\"' for var in \"$*\" do echo $var done echo 'print param from \"$@\"' for var in \"$@\" do echo $var done [root@zhujipeng /]# sh test.sh a 'b c' print param from $* a b c print param from $@ a b c print param from \"$*\" a b c print param from \"$@\" a b c 引号 Shell编程中有三类引号：单引号、双引号、反引号 ''单引号不解析变量 \"\"双引号会解析变量 ``反引号获取命令的结果 反引号是执行并引用一个命令的执行结果，类似于$(...) 函数 function FUNCTION_NAME(){ ... } 引用自定义函数文件时，使用 source func.sh 命令 函数可以可以通过 $n 获取参数来使用 函数的返回值，只能是数字 函数返回值 Shell函数返回值，一般有3种方式 return echo global argv return语句 return语句只能返回 0-255，且使用 $? 来访问 [root@zhujipeng test]# cat test.sh func(){ return 7 } func echo $? [root@zhujipeng test]# sh test.sh 7 echo语句 [root@zhujipeng test]# cat test.sh func(){ echo 7 } echo `func` [root@zhujipeng test]# sh test.sh 7 全局变量 [root@zhujipeng test]# cat test.sh ret_val= func(){ ret_val=7 } func echo $ret_val [root@zhujipeng test]# sh test.sh 7 [root@zhujipeng test]# cat test.sh ret_val= func(){ ret_val=7 echo \"inner ${ret_val}\" } echo haha | func echo \"outer ${ret_val}\" [root@zhujipeng test]# sh test.sh inner 7 outer 在管道中修改全局变量并没有用，因为子进程的修改无法反映到父进程 read 接收标准输入（键盘）或者其他文件描述符的输入，并将数据放入一个变量中 输出提示字符串 read -p \"Enter your name:\" VAR_NAME 等待指定的时间 read -t 5 -p \"Enter your name:\" VAR_NAME 键入密码不显示 read -s -p \"Enter your password: \" PASSWORD declare 限定变量的属性 选项 说明 -r 只读 -i 整数 -a 数组 某些算术计算允许在被声明为整数的变量中完成，而不需要特别使用 expr或 let 来完成 数组 declare -a 表示定义普通数组 支持稀疏格式 仅支持一维数组 数组赋值 一次对一个元素赋值 a[0]=$RANDOM 一次对多个元素赋值 a=(a b c d) 按索引进行赋值 a=([0]=a [3]=b [1]=c) 查看元素 ${ARRAY[index]}：查看数组指定角标的元素 ${ARRAY}：查看数组的第一个元素 ${ARRAY[*]}或者${ARRAY[@]}：查看数组的所有元素 数组长度 ${#ARRAY[*]} ${#ARRAY[@]} 元素大小 ${#ARRAY[index]} ${#ARRAY[0]}表示获取数组中的第一个元素的长度，等于${#ARRAY} 数组区间 ${ARRAY[@]:offset[:length]} offset：偏移的元素个数 length：取出的元素的个数 省略length取出数组中偏移量后的所有元素 删除元素 unset ARRAY[index] 重定向 标准输入、输出、错误可以使用文件描述符0、1、2引用 重定向输入 COMMAND 重定向输出 COMMAND [FILE_DESCRIPTOR]> FILE 可以使用 & 后面接文件描述符来代表文件 文件描述符 说明 0 标准输入 1 标准输出 2 错误输出 可以使用 & 符号同时代表标准输出和错误输出 字符串重定向 COMMAND true 和 false true命令啥都不做，只设置退出码为0，false设置为非0，详见这里 here document 详情参照这里 [root@zhujipeng test]# cat hi > here > EOF hi here [root@zhujipeng test]# cat /tmp/test.txt > hi > here > EOF [root@zhujipeng test]# cat /tmp/test.txt hi here xargs命令 xargs命令是给其他命令传递参数的一个过滤器，详情参见xargs命令 shell中的括号 详情参照这里 参考 Shell编程详解Linux Shell函数返回值Linux中重定向及管道What does linux shell的here document用法(cat shell中的括号linux shell中的单引号与双引号的区别linux shell的here document用法(cat 1>/dev/null 2>&1的含义我使用过的Linux命令之true我使用过的Linux命令之:（冒号）我使用过的Linux命令系列总目录关于Shell的source、点（.）和exportsh/bash/csh/Tcsh/ksh/pdksh等shell本质区别csh输出重定向[xargs命令 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/shell-about/shellyun-xing-guo-cheng.html":{"url":"medial-chapter/shell-about/shellyun-xing-guo-cheng.html","title":"shell运行过程","keywords":"","body":"shell运算过程花括号展开波浪线展开变量替换安全替换变量展开参数的长度子串截取删除匹配正则替换大小写转换命令替换算术替换单词分割路径匹配命令执行顺序顺序（;）条件与（&&）条件与（||）参考shell运算过程 将命令分割成tokens 检查token是不是关键字 检查token是不是别名 花括号（{}）展开 波浪号（~）展开 变量替换 命令替换 算术替换 单词分割（word splitting） 路径匹配（path globbing） 花括号展开 在花括号内，可以是以逗号分隔的字符串，或者是一个序列表达式 [root@zhujipeng test]# echo a{b,c,d}e abe ace ade [root@zhujipeng test]# echo a{b..d}e abe ace ade [root@zhujipeng test]# echo a{b..f..2}e abe ade afe [root@zhujipeng test]# echo a{1..3}e a1e a2e a3e [root@zhujipeng test]# echo a{001..3}e a001e a002e a003e [root@zhujipeng test]# echo a{1..7..3}e a1e a4e a7e 波浪线展开 如果一个单词以未被引号包括的 '~' 开头，则 这个单词所有到斜线 '/'(如果有得话) 之间的字符被认为是一个波浪线前缀字符串（TILDE-PREFIX） 如果波浪线前缀对应的登录名是无效的，或者波浪线展开失败，则保留原样 如果波浪线前缀是 '~+'，则被替换为 'PWD' 变量的值 如果波浪线前缀是 '~-'，则被替换为 'OLDPWD' 变量的值(如果存在的话) [root@zhujipeng test]# echo ~ /root [root@zhujipeng test]# echo ~root/.bashrc /root/.bashrc [root@zhujipeng test]# echo \"~root/.bashrc\" ~root/.bashrc [root@zhujipeng test]# echo ~guest ~guest [root@zhujipeng test]# echo ~- /root [root@zhujipeng test]# cd /tmp [root@zhujipeng tmp]# cd - /root/test [root@zhujipeng test]# echo ~+ /root/test [root@zhujipeng test]# echo ~- /tmp 变量替换 变量替换的基本的形式是 ${PARAMETER} 如果 PARAMETER 的第一个字符是 \"!\"，会进行“间接变量展开” 但是 ${!PREFIX*} 和 ${!NAME[@]} 是例外，在下面会介绍 安全替换 使用下面表格中的的形式，bash 会测试 PARAMETER 是否是未定义（unset） PARAMETER 是否是空字符串（null） 在下面的表格中，DEFAULT，OTHER，ERR_MSG 可进行 “波浪线展开” “变量替换” “命令替换” “算术替换” 变量 说明 ${PARAMETER-DEFAULT} 如果 PARAMETER 是 unset，返回DEFAULT的结果 ${PARAMETER:-DEFAULT} 如果 PARAMETER 是 unset 或 null，返回DEFAULT的结果 ${PARAMETER:=DEFAULT} 如果 PARAMETER 是 unset，将DEFAULT的结果赋给PARAMETER并返回 ${PARAMETER:=DEFAULT} 如果 PARAMETER 是 unset 或 null，将DEFAULT的结果赋给PARAMETER并返回 ${PARAMETER:+OTHER} 如果 PARAMETER 不是 unset，返回OTHER的结果 ${PARAMETER:+OTHER} 如果 PARAMETER 不是 unset和null，返回OTHER的结果 ${PARAMETER:?ERR_MSG} 如果 PARAMETER 是 unset，打印ERR_MSG ${PARAMETER:?ERR_MSG} 如果 PARAMETER 是 unset 或 null，打印ERR_MSG 变量展开 * 和 @ 的区别请参考shell脚本基础章节 ${!PREFIX*} ${!PREFIX@} 展开结果为所有以 PREFIX 为前缀的变量的名字 ${!NAME[@]} ${!NAME[*]} 如果 NAME 是数组变量，展开为数组索引(key)的列表 如果 NAME 不是数组变量，当变量存在时展开为0 参数的长度 ${#PARAMETER} 位置参数是参数的个数，数组变量时数组的长度 子串截取 ${PARAMETER:OFFSET} ${PARAMETER:OFFSET:LENGTH} OFFSET: 截取的开始位置，为负时从尾部向前截取 LENGTH: 截取的长度，没有则截取到末尾 当 PARAMETER 是普通变量时，以字符为单位对参数做截取 当 PARAMETER 是位置参数时，表示从OFFSET处开始的LENGTH个位置参数 当 PARAMETER 是数组变量时，表示从OFFSET处开始的LENGTH个数组变量 对于字符串值，索引从 0 开始(0-based) 对于位置参数，索引从 1 开始(1-based) 对于数组变量，索引从 0 开始(0-based) 删除匹配 ${PARAMETER#PATTERN} ${PARAMETER##PATTERN} ${PARAMETER%PATTERN} ${PARAMETER%%PATTERN} #代表从左向右匹配，%代表从右向左 一个代表最小匹配，两个代表最大匹配 [root@zhujipeng test]# cat test.sh HAHA='var/log/messages' echo ${HAHA#*a} echo ${HAHA##*a} echo ${HAHA%a*} echo ${HAHA%%a*} [root@zhujipeng test]# sh test.sh r/log/messages ges var/log/mess v 正则替换 ${PARAMETER/PATTERN/STRING} ${PARAMETER//PATTERN/STRING} 一个斜杠替换第一个匹配，两个斜杠替换所有匹配 如果参数是“*”或者“@”，对每个位置参数做上面的操作 [root@zhujipeng test]# cat test.sh HAHA='var/log/messages' echo ${HAHA/a/b} echo ${HAHA//a/b} [root@zhujipeng test]# sh test.sh vbr/log/messages vbr/log/messbges 大小写转换 ${PARAMETER^PATTERN} ${PARAMETER^^PATTERN} ${PARAMETER,PATTERN} ${PARAMETER,,PATTERN} 一个替换第一个匹配，两个替换所有匹配 但是实际测试却是一个不生效，两个生效 如果参数是“*”或者“@”，对每个位置参数做上面的操作 [root@zhujipeng test]# cat test.sh HAHA='var/log/messages' echo ${HAHA^a} echo ${HAHA^^a} HAHA='vAr/log/messAges' echo ${HAHA,A} echo ${HAHA,,A} [root@zhujipeng test]# sh test.sh var/log/messages vAr/log/messAges vAr/log/messAges var/log/messages 命令替换 $(COMMAND) `COMMAND` 算术替换 $(( EXPRESSION )) 单词分割 shell会对对未被引号引用的展开进行单词分割 分割符由IFS 变量决定 [root@zhujipeng test]# cat test.sh HAHA='haha /var/log/*yum*.log' for i in ${HAHA} do echo $i done echo ------ for i in \"${HAHA}\" do echo $i done [root@zhujipeng test]# sh test.sh haha /var/log/anaconda.yum.log /var/log/yum.log ------ haha /var/log/anaconda.yum.log /var/log/yum.log 路径匹配 shell会对展开的结果进行路径匹配 [root@zhujipeng test]# cat test.sh HAHA='haha /var/log/*yum*.log' for i in ${HAHA} do echo $i done echo ------ for i in \"${HAHA}\" do echo $i done [root@zhujipeng test]# sh test.sh haha /var/log/anaconda.yum.log /var/log/yum.log ------ haha /var/log/anaconda.yum.log /var/log/yum.log 命令执行顺序 顺序（;） 命令1与命令2没有逻辑关系。无论命令1是否执行成功，命令2都会执行 COMMAND1; COMMAND2 条件与（&&） 只有当命令1执行成功，才执行命令2；否则不执行命令2 COMMAND1 && COMMAND2 条件与（||） 只有当命令1执行失败,才执行命令2;否则不执行命令2 COMMAND1 || COMMAND2 参考 shell 基本特性之~ shell展开详解Shell中的 IFSlinux shell 字符串操作（长度，查找，替换）详解Linux Shell 通配符、元字符、转义符使用实例介绍 Linux命令的执行顺序从 shell 眼中看世界 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/shell-about/shellce-shi-ji-suan.html":{"url":"medial-chapter/shell-about/shellce-shi-ji-suan.html","title":"shell测试计算","keywords":"","body":"test命令真假值[ 命令[[ 命令表达式数值运算整数运算[] 运算符(( )) 运算符expr命令let命令浮点数运算(bc)常规运算进制转换参考test命令 test 就是测试的意思，常用在流程控制语句中作为条件表达式 test EXPRESSION test ! EXPRESSION test EXPR1 && EXPR2 test EXPR1 || EXPR2 真假值 与其他语言不同，bash（包括其他Shell）中，是用0表示真，非0表示假 之所以用0表示成功，而不是1来表示，是因为成功的情况只有一种，而出错的可能却有许多 如果你有过POSIX编程经验（比如Linux下C编程），你应该会知道一个叫做errno的东西 你也会知道有大量的函数的调用结果，基本上都是返回0时表示操作成功，返回非0则出错 [ 命令 [ 是 test的命令的简写，] 是 [ 命令的参数的结束标记 [ EXPRESSION ] [ ! EXPRESSION ] [ EXPR1 -a EXPR2 ] [ EXPR1 -o EXPR2 ] [[ 命令 根据条件表达式的结果返回状态0或1，表达式部分和[ 命令基本一样，不同如下 > 和 符号不需要转移 == 和 != 使用正则匹配 AND 和 OR 运算也不相同 [[ EXPRESSION ] [[ ! EXPRESSION ] [[ EXPR1 && EXPR2 ] [[ EXPR1 || EXPR2 ] 表达式 表达式以 [ 命令讲解，[[ 与 [ 的不同部分请参考 [[命令 数值比较符 比较符 说明 $NUM1 -eq $NUM2 等于 (equal) $NUM1 -ne $NUM2 不等于 (not equal) $NUM1 -gt $NUM2 大于 (greater than) $NUM1 -lt $NUM2 小于 (less than) $NUM1 -ge $NUM2 大于等于 (greater or equal) $NUM1 -le $NUM2 小于等于 (less or equal) 数字比较不是用 > 和 符号，它们是重定向和字符串比较符 [root@zhujipeng test]# [ 2 > 3 ] && echo yes || echo no yes [root@zhujipeng test]# ls 3 [root@zhujipeng test]# [ 12 \\> 3 ] && echo yes || echo no no 字符串比较符 比较符 说明 $STR1 = $STR2 测试是否相等 $STR1 == $STR2 测试是否相等 $STR1 != $STR2 测试是否不等 $STR1 \\ 测试str1的字典序是否在小于str2 $STR1 > $STR2 测试str1的字典序是否在大于str2 $STR1 总是返回0 -n \"$str1\" 测试是否为空串 -z \"$str1\" 测试是否为非空串 注意 [ 命令中 和 > 需要转义，否则是代表重定向的意思 [root@zhujipeng test]# [ a > b ] && echo yes || echo no yes [root@zhujipeng test]# ls b [root@zhujipeng test]# [ a \\> b ] && echo yes || echo no no [root@zhujipeng test]# [ a 注意 [ 命令中 -n 和 -z 的值需要用双引号扩起来，否则变量未定义时就会失败 [root@zhujipeng test]# unset HAHA [root@zhujipeng test]# set -u : $HAHA bash: HAHA: unbound variable [root@zhujipeng test]# HAHA=haha [root@zhujipeng test]# set -u : $HAHA [root@zhujipeng test]# unset HAHA [root@zhujipeng test]# set -u : $HAHA bash: HAHA: unbound variable [root@zhujipeng test]# set +u [root@zhujipeng test]# [ -n $HAHA ] && echo yes || echo no yes [root@zhujipeng test]# [ -n \"$HAHA\" ] && echo yes || echo no no [root@zhujipeng test]# export HAHA= [root@zhujipeng test]# [ -n \"$HAHA\" ] && echo yes || echo no no [root@zhujipeng test]# unset HAHA 需要在比较符两边的元素的前面添加x字符，避免变量未定义导致的错误 [ a \\> $HAHA ] && echo yes || echo no bash: [: a: unary operator expected no [root@zhujipeng test]# HAHA= [root@zhujipeng test]# [ a \\> $HAHA ] && echo yes || echo no bash: [: a: unary operator expected no [root@zhujipeng test]# [ xa \\> x$HAHA ] && echo yes || echo no yes [root@zhujipeng test]# unset HAHA 文件比较符 比较符 说明 -e FILENAME 是否存在 -d FILENAME 是否为目录 -f FILENAME 是否为普通文件 -h FILENAME 是否为软链接文件 -L FILENAME 是否为软链接文件 -r FILENAME 是否有读权限 -w FILENAME 是否写读权限 -x FILENAME 是否有执行权限 -s FILENAME 文件大小是否大于0 -c FILENAME 是否为字符设备文件 -b FILENAME 是否为块设备文件 FILENAME1 -nt FILENAME2 文件1是否比文件2新 FILENAME1 -ot FILENAME2 文件1是否比文件2旧 -e 检测的是链接文件的源文件是否存在 [root@zhujipeng test]# ll total 0 lrwxrwxrwx 1 root root 5 Sep 20 12:49 test1.link -> test1 [root@zhujipeng test]# [ -e test1 ] && echo yes || echo no no [root@zhujipeng test]# [ -e test1.link ] && echo yes || echo no no [root@zhujipeng test]# [ -h test1.link ] && echo yes || echo no yes 模糊比较 [ 会做路径展开（file globbing）和单词分割（word splitting），而 [[ 不会 [root@zhujipeng test]# ls a.log a.txt [root@zhujipeng test]# A='a.*' [root@zhujipeng test]# echo $A a.log a.txt [root@zhujipeng test]# echo \"$A\" a.* [root@zhujipeng test]# [ $A == a* ] && echo yes || echo no bash: [: too many arguments no [root@zhujipeng test]# [ \"$A\" == a* ] && echo yes || echo no bash: [: too many arguments no [root@zhujipeng test]# [ $A == \"a*\" ] && echo yes || echo no bash: [: too many arguments no [root@zhujipeng test]# [ \"$A\" == \"a*\" ] && echo yes || echo no no [root@zhujipeng test]# [ \"$A\" == \"a.*\" ] && echo yes || echo no yes [root@zhujipeng test]# [[ $A == a* ]] && echo yes || echo no yes [root@zhujipeng test]# [[ \"$A\" == a* ]] && echo yes || echo no yes [root@zhujipeng test]# [[ $A == \"a*\" ]] && echo yes || echo no no [root@zhujipeng test]# [[ \"$A\" == \"a*\" ]] && echo yes || echo no no [root@zhujipeng test]# [[ \"$A\" == \"a.*\" ]] && echo yes || echo no yes 数值运算 整数运算 [] 运算符 [root@zhujipeng test]# echo $[ 1 * 3 ] 3 (( )) 运算符 [root@zhujipeng test]# echo $(( 1 * 3 )) 3 expr命令 [root@zhujipeng test]# echo `expr 1 \\* 3` 3 let命令 [root@zhujipeng test]# let a=1+2 && echo $a 3 [root@zhujipeng test]# a=1 && let a++ && echo $a 2 [root@zhujipeng test]# a=2 && let a+=1 && echo $a 3 浮点数运算(bc) 除法运算的时候，默认是取整的，即没有小数部分，需要使用scale设置精度 常规运算 [root@zhujipeng test]# echo '3.0 - 1.0' | bc 2.0 [root@zhujipeng test]# echo '2.0/3' | bc 0 [root@zhujipeng test]# echo 'scale=3;2.0/3' | bc .666 进制转换 不指定进制时默认是10进制 [root@zhujipeng test]# echo 'ibase=8;755' | bc 493 [root@zhujipeng test]# echo 'obase=2;ibase=8;755' | bc 111101101 [root@zhujipeng test]# echo 'obase=8;ibase=2;111101101' | bc 755 参考 玩转Bash脚本：test测试语句Linux 之 shell 比较运算符Linux-shell-算术运算{expr、bc、dc、(( ))和[ ]}Why do shell script comparisons often use x$VAR = xyes?linux shell 中判断字符串为空的正确方法空格、回车符(\\r)、换行符(\\n)、水平制表符(\\t)、垂直制表符(\\v)、换页符(\\f)）的理解 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/shell-about/shellkong-zhi-jie-gou.html":{"url":"medial-chapter/shell-about/shellkong-zhi-jie-gou.html","title":"shell控制结构","keywords":"","body":"if选择结构for循环结构迭代元素普通枚举命令替换变量展开seq命令while循环结构死循环重定向输入重定向输出重定向遍历文件case分支结构真假的本质参考if选择结构 c语言中的else if在shell中写作elif，elif语句可以有多个 if then elif then else fi if ; then ; elif ; then ; else ; fi 注意if和[]之间要有空格，[]和内容之间也有空格 for循环结构 shell写法 for in 取值列表 do done for in ; do ;done c语言写法 for((i = 0; i 迭代元素 普通枚举 for i in 'fruit' 'meat' 'sleep' do echo I like $i done 命令替换 for var in `ls /var/log/*.log` do echo $var done 变量展开 sum=0 for i in {1..100} do let sum+=$i done echo $sum sum=0 for i in {1..100..2} do let sum+=$i done echo $sum for i in ｛a..z｝ do letters=\"${letters}${ch}\" done echo $letters seq命令 seq [增量] 用脚本ping一下局域网ip PREFIX=192.168.1. for i in `seq 100 110` do echo -n \"${PREFIX}$i \" ping -c5 ${PREFIX}${i} >/dev/null 2>&1 if [ \"$?\" -eq 0 ];then echo \"OK\" else echo \"Failed\" fi done while循环结构 while do done while 条件;do ; done 死循环 while : do echo I love you forever done 这是一个死循环，执行之后请用按组合键Ctrl + C来终止它 while true do echo I love you forever done true 和 false 都是shell中的一个命令，不是关键字 重定向 输入重定向 将文件内容逐行传递给while后面的命令(类似管道)，然后再执行循环体 while do done 从/etc/passwd文件中读取用户名并输出 OLD_IFS=$IFS # IFS是文件内部分隔符 IFS=\":\" # 设置分隔符为: while read username var # var变量不可少 do echo \"用户名:$username\" done 输出重定向 会将命令的输出，以及循环体中的标准输出都重定向到指定的文件中 while do done > 每隔1分钟，ping一下局域网内主机192.168.1.101 while date do ping -c5 192.168.1.101 >/dev/null 2>&1 if [ $? = 0 ];then echo OK else echo FAIL fi sleep 60 # 60秒是1分钟 done > ping.txt 遍历文件 while read line do echo $line done cat test.txt | while read line do echo $line done for line in `cat test.txt` do echo $line done while遍历和for遍历是有区别的，while按行分割，for按字段分割 [root@zhujipeng /]# cat test.txt 1 2 3 [root@zhujipeng /]# cat test.txt | while read line; do echo $line; done 1 2 3 [root@zhujipeng /]# for line in `cat test.txt`; do echo $line; done 1 2 3 case分支结构 case匹配可以使用通配符*（任意多个字符）、?（一个字符）和[]（字符集） case VAR in VAR1) ;; VAR2) ;; VAR3) ;; ... *) esac 输出带颜色的文字 str=\"is good \" read -p \"你喜欢什么颜色：\" color case $color in red) echo -e \"\\e[1;31m$color $str \\e[0m\";; green) echo -e \"\\e[1;32m$color $str \\e[0m\";; yellow) echo -e \"\\e[1;33m$color $str \\e[0m\";; blue) echo -e \"\\e[1;34m$color $str \\e[0m\";; *) echo -e \"\\e[1;30m这是什么颜色?\\e[0m\";; esac 真假的本质 if 和 while 的本质是根据命令的返回结果来决定的，参考这里 参考 玩转Bash脚本：test测试语句玩转Bash脚本：选择结构之if玩转Bash脚本：循环结构之for循环玩转Bash脚本：循环结构之while循环玩转Bash脚本：选择结构之caseWhen square brackets are required in bash if statement?What do square brackets mean without the \"if\" on the left Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/shell-about/shelltiao-shi-ji-qiao.html":{"url":"medial-chapter/shell-about/shelltiao-shi-ji-qiao.html","title":"shell调试技巧","keywords":"","body":"前言调试方法trap命令tee命令勾子函数调试开关脚本变量参考前言 熟练掌握shell编程和调试是成为一名优秀的unix/linux开发者和系统管理员的必经之路 常用的调试手段 分析输出的错误信息 在脚本中加入调试语句，输出调试信息 利用调试工具 但与其它高级语言相比，shell解释器缺乏相应的调试机制和调试工具的支持，其输出的错误信息又往往很不明确 调试方法 trap命令 trap 系统信号 [root@zhujipeng test]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX 系统信号 说明 SIGHUP 用户终端连接(正常或非正常)结束时发出 SIGINT 进程终止(interrupt)信号， 结束前台进程 SIGTERM 进程终止(terminate)信号，进程平稳结束 SIGKILL 进程终止(kill)信号，进程立即结束，不能被捕获 SIGUSR1 留给用户使用 SIGUSR2 留给用户使用 SIGTERM、SIGKILL、SIGINT和SIGQUIT的区别参考这里 伪信号 说明 EXIT 从一个函数中退出或整个脚本执行完毕发出 ERR 当一条命令返回非零状态时(代表命令执行不成功)发出 DEBUG 脚本中每一条命令执行之前发出 “伪信号”是因为这三个信号是由shell产生的 [root@zhujipeng test]# cat test.sh error_trap() { echo \"[Line $1] Error: command or function exited with status $?\" } exit_trap() { echo \"[Line $1] INFO: exit method\" } foo() { false } bar() { for i in {1..10} do sleep 1 done } trap 'error_trap $LINENO' ERR trap 'exit_trap $LINENO' EXIT trap 'echo abort by user $USER; exit 1' INT abc foo bar [root@zhujipeng test]# sh test.sh test.sh: line 24: abc: command not found [Line 24] Error: command or function exited with status 127 [Line 10] Error: command or function exited with status 1 ^Cabort by user [Line 1] INFO: exit method tee命令 管道的中间结果并不会显示在屏幕上，需要使用 tee 命令输出到文件观察 [root@zhujipeng test]# cat test.sh ifconfig | grep 'inet addr:' | grep -v '127.0.0.1' ifconfig | grep 'inet addr:' | tee /tmp/test.txt | grep -v '127.0.0.1' echo 'content of test.txt' cat /tmp/test.txt [root@zhujipeng test]# sh test.sh inet addr:172.17.0.2 Bcast:0.0.0.0 Mask:255.255.0.0 inet addr:172.17.0.2 Bcast:0.0.0.0 Mask:255.255.0.0 content of test.txt inet addr:172.17.0.2 Bcast:0.0.0.0 Mask:255.255.0.0 inet addr:127.0.0.1 Mask:255.0.0.0 勾子函数 [root@zhujipeng test]# cat test.sh debug() { [ x\"$DEBUG\" = x\"true\" ] && echo $* } echo debug debug haha hehe [root@zhujipeng test]# sh test.sh debug [root@zhujipeng test]# DEBUG='true' && sh test.sh debug 调试开关 shell 命令有一些选项可以帮助调试 |选项 | 说明 | |-n | 只读取脚本，但不实际执行，用于检查是否有语法错误 | |-x | 显示每一条命令的执行过程，是调试脚本的强有力工具 | |-c | 从字符串中读取命令并执行，用来临时测试一小段脚本 | 当脚本非常庞大时，-x 的输出会很多，这时可以使用 set -x命令 [root@zhujipeng test]# cat test.sh foo() { echo haha } echo call foo foo echo echo debug foo set -x foo set +x echo echo call foo foo [root@zhujipeng test]# sh test.sh call foo haha debug foo + foo + echo haha haha + set +x call foo haha 脚本变量 对于复杂的shell脚本的调试来说，需要输出行号和函数等相关信息 不是所有的shell都支持这些变量 变量 说明 LINENO 当前行号，类似于C语言中的内置宏__LINE__ FUNCNAME 函数名称，类似于C语言中的内置宏__func__ PS4 调试时输出的前缀，缺省的$PS4的值是\"+\"号 主提示符变量$PS1和第二级提示符变量$PS2比较常见 FUNCNAME是一个数组变量，包含了调用链上所有的函数的名字 变量${FUNCNAME[0]}代表shell脚本当前正在执行的函数的名字 [root@zhujipeng test]# cat test.sh PS4=\"[+$LINENO:${FUNCNAME[0]}]\" echo haha [root@zhujipeng test]# sh -x test.sh + PS4='[+1:]' [+1:]echo haha haha 参考 Shell脚本调试技术SIGTERM、SIGKILL、SIGINT和SIGQUIT的区别我使用过的Linux命令之trap Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/shell-about/shellzhu-yi-shi-xiang.html":{"url":"medial-chapter/shell-about/shellzhu-yi-shi-xiang.html","title":"shell注意事项","keywords":"","body":"慎用删除使用引号赋值语句条件测试[和空格[ 中的比较符号[[ 中的比较符号[ 中的逻辑符号[[ 中的逻辑符号变量未定义参考慎用删除 当变量未定义时，rm很可能会意外删掉你不想删掉的文件，-f 选项很危险 使用引号 使用变量时最好使用引号包起来，避免单词分割和路径匹配等行为带来的问题 赋值语句 shell中=两边不能有空格，和编程语言不一样 [root@zhujipeng test]# HAHA = haha bash: HAHA: command not found 条件测试 [和空格 [ 和表达式之间要有空格 [root@zhujipeng test]# [ -n haha ] && echo yes || echo no yes [root@zhujipeng test]# [-n haha ] && echo yes || echo no bash: [-n: command not found no [root@zhujipeng test]# [ -n haha] && echo yes || echo no bash: [: missing `]' no [ 中的比较符号 [root@zhujipeng test]# [ 1 -gt 2 ] && echo yes || echo no no [root@zhujipeng test]# ll total 0 [root@zhujipeng test]# [ 1 > 2 ] && echo yes || echo no yes [root@zhujipeng test]# ll total 0 -rw-r--r-- 1 root root 0 Sep 23 09:07 2 [[ 中的比较符号 [root@zhujipeng test]# [[ 1 -gt 2 ]] && echo yes || echo no no [root@zhujipeng test]# [[ 1 > 2 ]] && echo yes || echo no no [ 中的逻辑符号 [root@zhujipeng test]# [ -n haha -a -n hehe ] && echo yes || echo no yes [root@zhujipeng test]# [ -n haha && -n hehe ] && echo yes || echo no bash: [: missing `]' no [[ 中的逻辑符号 [root@zhujipeng test]# [[ -n haha -a -n hehe ]] && echo yes || echo no bash: syntax error in conditional expression bash: syntax error near `-a' [root@zhujipeng test]# [[ -n haha && -n hehe ]] && echo yes || echo no yes 变量未定义 -n 和 -z 的值需要用双引号扩起来，否则变量未定义时就会失败 [root@zhujipeng test]# unset HAHA [root@zhujipeng test]# set -u : $HAHA bash: HAHA: unbound variable [root@zhujipeng test]# HAHA=haha [root@zhujipeng test]# set -u : $HAHA [root@zhujipeng test]# unset HAHA [root@zhujipeng test]# set -u : $HAHA bash: HAHA: unbound variable [root@zhujipeng test]# set +u [root@zhujipeng test]# [ -n $HAHA ] && echo yes || echo no yes [root@zhujipeng test]# [ -n \"$HAHA\" ] && echo yes || echo no no [root@zhujipeng test]# export HAHA= [root@zhujipeng test]# [ -n \"$HAHA\" ] && echo yes || echo no no [root@zhujipeng test]# unset HAHA 参考 shell 语句出错自动退出linux shell 中判断字符串为空的正确方法Bash空格的那点事Bash引号的那点事shell中的括号（小括号，中括号，大括号）及单引号、 双引号，反引号 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/shell-about/shellshi-yong-jiao-ben.html":{"url":"medial-chapter/shell-about/shellshi-yong-jiao-ben.html","title":"shell实用脚本","keywords":"","body":"自动交互脚本执行命令前设置变量获取脚本所在的目录获取发行版检查网络畅通pingtelnetnetcat软件版本比较检查通配文件输出颜色文字日常的技巧查看文件指定行删除行首行尾的空格行首空格行末空格所有空行列出文件的绝对路径参考自动交互脚本 详情参考 expect - 自动交互脚本 登陆脚本，参数为主机和密码 #! /usr/bin/expect set host [ lindex $argv 0 ] set pass [ lindex $argv 1 ] set timeout 10 spawn ssh -o ServerAliveInterval=60 root@$host expect { \"*yes/no\" { send \"yes\\r\"; exp_continue} \"*password\" {send \"${pass}\\r\"} } interact 执行命令前设置变量 原理参考 Why is setting a variable before a command legal in bash 获取脚本所在的目录 cur_dir=$(cd `dirname ${BASH_SOURCE-$0}`; pwd) 获取发行版 get_os() { # Determine OS platform local U_NAME=$(uname | tr \"[:upper:]\" \"[:lower:]\") local LINUX_DIST=\"\" # If Linux, try to determine specific distribution if [ \"$U_NAME\" == \"linux\" ]; then # If available, use LSB to identify distribution if [ -f /etc/lsb-release -o -d /etc/lsb-release.d ]; then LINUX_DIST=$(lsb_release -i | cut -d: -f2 | sed s/'^\\s'//) # If system-release is available, then try to identify the name elif [ -f /etc/system-release ]; then LINUX_DIST=$(cat /etc/system-release | awk '{print $1}') # /etc/issue always exit (Ubuntu, Debian, CentOS, Fedora, RHEL, Arch, OpenSUSE) elif [ -f /etc/issue ]; then LINUX_DIST=$(head -n1 /etc/issue | awk '{print $1}') # Otherwise, use release info file else LINUX_DIST=$(ls -d /etc/[A-Za-z]*[_-][rv]e[lr]* | grep -v \"lsb\" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1) fi else # error \"this script only supports linux\" : fi # For everything else (or if above failed), just use generic identifier if [ \"x$LINUX_DIST\" == \"x\" ]; then LINUX_DIST=${U_NAME} fi LINUX_DIST=$(echo ${LINUX_DIST} | tr \"[:upper:]\" \"[:lower:]\") echo ${LINUX_DIST} } 检查网络畅通 ping check_network_by_ping(){ local REMOTE_SERVER_HOST=$1 echo \"Checking if ${REMOTE_SERVER_HOST} is reachable.\" if [ $(ping -c 1 ${REMOTE_SERVER_HOST} | grep \"1 packets transmitted, 1 received\" | wc -l) == 1 ]; then echo \"remote host ${REMOTE_SERVER_HOST} is reachable.\" else echo \"remote host ${REMOTE_SERVER_HOST} is not reachable via ping. maybe forbidden by firewall\" fi } telnet check_network_by_telnet(){ local REMOTE_HOST=$1 local REMOTE_PORT=$2 local telnet_output_log=\"/tmp/telnet_output.log\" telnet ${REMOTE_HOST} ${REMOTE_PORT} > ${telnet_output_log} 2>&1 netcat check_network_by_netcat(){ local REMOTE_HOST=$1 local REMOTE_PORT=$2 local NETCAT_RESULT= echo test | nc -w 6 ${REMOTE_HOST} ${REMOTE_PORT} &> /dev/null && NETCAT_RESULT=0 || NETCAT_RESULT=1 return ${NETCAT_RESULT} } 软件版本比较 compare_version(){ if [ -z \"${1}\" -o -z \"${2}\" ]; then echo \"version can't be empty\" exit 1 fi typeset IFS='.' typeset -a v1=( $1 ) typeset -a v2=( $2 ) typeset n d local count=0 if [ ${#v1[@]} -gt ${#v2[@]} ]; then count=${#v1[@]} else count=${#v2[@]} fi for (( n = 0; n 检查通配文件 check_file_exists() { ! ls $1 &> /dev/null && echo \"File \\\"${1}\\\" does not exist\" || echo \"file \\\"${1}\\\" exists\" } check_file_wildcard() { [[ \"$1\" =~ [*?\\[] ]] && echo \"FileName can't contains wildcard\" } 输出颜色文字 print_msg() { if [ x${1} == x\"[ERROR]\" ]; then echo -e \"\\033[1;31m[$(date +\"%Y-%m-%d %H:%M:%S\")] $@\\033[m\" elif [ x${1} == x\"[WARN]\" ]; then echo -e \"\\033[1;33m[$(date +\"%Y-%m-%d %H:%M:%S\")] $@\\033[m\" else echo -e \"\\033[1;36m[$(date +\"%Y-%m-%d %H:%M:%S\")] $@\\033[m\" fi } error() { print_msg '[ERROR]' \"$@\" exit 1 } warn() { print_msg '[WARN]' \"$@\" } info() { print_msg '[INFO]' $@ } div_line() { echo echo -e \"\\033[1;35m------- (^_^) I am the dividing line (^_^) -------\\033[m\" echo } prompt(){ warn $1 ${IS_QUIET} && return while true do read -p \"Would you like to continue anyway? (yes/no)\" yn case $yn in [yY]* ) break ;; [nN]* ) error \"abort by user because $1\" exit 1 ;; * ) info \"Please answer y[es] or n[o]\" esac done } 日常的技巧 查看文件指定行 [root@zhujipeng test]# cat -n test.sh 1 #! /usr/bin/expect 2 3 set host [ lindex $argv 0 ] 4 set pass [ lindex $argv 1 ] 5 set timeout 10 6 7 spawn ssh -o ServerAliveInterval=60 root@$host 8 expect { 9 \"*yes/no\" { send \"yes\\r\"; exp_continue} 10 \"*password\" {send \"${pass}\\r\"} 11 } 12 interact [root@zhujipeng test]# sed -n '7,11p' test.sh spawn ssh -o ServerAliveInterval=60 root@$host expect { \"*yes/no\" { send \"yes\\r\"; exp_continue} \"*password\" {send \"${pass}\\r\"} } 删除行首行尾的空格 行首空格 sed 's/^[ \\t]*//g' 行末空格 sed 's/[ \\t]*$//g' 所有空行 sed 's/^[[:space:]]*$//g' 列出文件的绝对路径 [root@zhujipeng test]# ls * test.sh [root@zhujipeng test]# ls `pwd`/* /root/test/test.sh [root@zhujipeng test]# ls | sed \"s:^:`pwd`/:\" /root/test/test.sh 参考 expect - 自动交互脚本Why is setting a variable before a command legal in bashShell Script to find the Operating System of the machineHow can I get distribution name and version number in a simple shell scriptCheck if a file exists with wildcard in shell script控制echo显示字体的颜色和效果在Linux中让echo命令显示带颜色的字Linux shell 之 提取文件名和目录名的一些方法在ls中列出文件的绝对路径 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/software-about/":{"url":"medial-chapter/software-about/","title":"软件相关","keywords":"","body":"本章是关于软件相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/software-about/yumji-chu-zhi-shi.html":{"url":"medial-chapter/software-about/yumji-chu-zhi-shi.html","title":"yum基础知识","keywords":"","body":"安装方式源码安装源码包格式源码包安装rpm安装rpm包格式rpm安装安装升级查询删除yum安装安装升级降级查询删除软件包组软件仓库仓库缓存历史记录查看帮助dnf安装参考安装方式 linu下的软件包有三种安装方式 Redhat系列 源码安装 rpm安装 yum安装 Debian系列 源码安装 dpkg安装 apt-get安装 源码安装 相对于二进制软件包，源码安装配置和编译比较繁琐，但是可移植性却好得多 源码包格式 源码包通常包含以下字样 src：源码包标识，相对于bin .tar.gz：压缩包格式 .tgz：tar.gz的缩写 二进制包通常包含以下字样 bin：二进制包格式，相对于src .rpm：Redhat系列二进制包 .deb：Debian系列二进制包 源码包安装 源码安装通常有以下几步 通常我们会执行--prefix参数将软件安装到指定位置以便维护 生成Makefile：./configure --prefix=/opt/XXX 编译源文件：make 安装软件包：make install ./configre --help可以查看帮助信息来获得更多的设置选项 make clean（不一定有）可以清除编译连接过程中的临时文件 make uninstall（不一定有）可以根据Makefile文件来删除软件 关于configure的更多知识参考configure、make、make install 命令 和 configure和make install背后的故事 rpm安装 rpm包格式 [root@zhujipeng test]# ls telnet-0.17-48.el6.x86_64.rpm telnet-0.17-48.el6.x86_64.rpm rpm软件包的组成如下 telnet： 软件的名称 0.17：软件版本号 el6： redhat系列版本 x86_64： cpu型号 devel：软件开发包（包含开发需要的依赖） src： 源码形式的安装包 rpm安装 rpm [选项] 通用选项如下 选项 说明 -v 显示详细信息（通用选项） -vv 显示调试信息（通用选项） 安装 rpm -ivh 选项如下 选项 说明 -i, --install 安装（通常与vh选项一起使用） -h, --hash 以#显示进度信息 --force 强制进行安装 --nodeps 忽略依赖关系 --test 只测试，不实际执行 --replacepkgs 重新安装软件包 --oldpackage 允许安装低版本的包 出错后可以使用--force和--nodeps（no dependency）强制进行安装 升级 rpm -Uvh 选项 说明 -U, --upgrade 升级（如果没有安装则安装） -F, --freshen 升级（软件包要事先安装过） -h, --hash 以#进度显示进度信息 --force 强制进行升级 --nodeps 忽略依赖关系 --test 只测试，不实际执行 查询 rpm -q[其他选项] [参数] 选项 说明 -q, --query 查询单个软件包 -qa 查看所有已安装软件包 -qi 查看软件包摘要信息 -ql 查看软件包生成的文件列表 -qd 查看软件包生成的帮助文件 -qf 查看文件是由哪个软件包安装的 -qR 查看软件包的依赖关系 -q –scripts 查看软件包安装脚本 -p, package 指定查询时使用的本地软件包 -p 参数的影响如下 [root@zhujipeng test]# rpm -q telnet telnet-0.17-48.el6.x86_64 [root@zhujipeng test]# rpm -q telnet-0.17-48.el6.x86_64.rpm package telnet-0.17-48.el6.x86_64.rpm is not installed [root@zhujipeng test]# rpm -qp telnet-0.17-48.el6.x86_64.rpm telnet-0.17-48.el6.x86_64 删除 rpm -e 选项 说明 -e, --erase 移除软件包 --nodeps 忽略依赖关系 --test 只测试，不实际执行 --allmatches 移除所有匹配的版本 yum安装 yum [选项] [子命令] [软件包]... 通用选项如下 选项 说明 -y, --assumeyes 所有的询问回答yes --assumeno 所有的询问回答no -q, --quiet 不显示输出 安装 初始安装软件包 yum install [软件包]... 初始安装软件包 yum localinstall [软件包]... 重新安装软件包 yum reinstall [软件包]... 选项如下 选项 说明 --nogpgcheck 不检查GPG签名 --downloadonly 只下载不安装 --downloaddir=directory 指定下载的目录 升级 升级软件包 yum update [软件包]... 升级软件包 yum localupdate [软件包]... 检查软件更新 yum check-update [软件包]... 选项如下 选项 说明 --nogpgcheck 不检查GPG签名 --downloadonly 只下载不安装 --downloaddir=directory 指定下载的目录 降级 降级安装软件包 yum downgrade [软件包]... 查询 列出安装包 yum list [软件包]... 列出可更新安装包 yum list updates 列出已安装安装包 yum list installed 模糊查找软件包 yum search [软件包]... 查看软件包信息 yum info [软件包]... 查询软件包的提供方 yum provides [软件包]... 查询文件所在的安装包 yum resolvedep [文件]... 查询软件包的依赖 yum deplist [软件包]... 删除 删除软件包 yum erase [软件包]... 删除软件包 yum remove [软件包]... 软件包组 显示所有软件包组 yum grouplist [软件包]... 显示组包含的软件包 yum groupinfo [软件包]... 安装RPM软件包组 yum groupinstall [软件包]... 更新RPM软件包组 yum groupupdate [软件包]... 删除RPM软件包组 yum groupremove [软件包]... 软件仓库 仓库 查看所有的yum仓库 yum repolist all 查看启用的的yum仓库 yum repolist enabled 查看禁用的yum仓库 yum repolist disabled 缓存 清除缓存 yum clean 缓存范围 说明 headers 软件包头信息 packages 软件包缓存 metadata 元数据缓存 expire-cache 过期信息缓存 dbcache 数据库信息缓存 plugins 插件缓存 all 所有缓存 建立缓存 yum makecache 历史记录 列出yum历史操作命令 yum history 查看帮助 查看子命令的帮助信息 yum help dnf安装 DNF是新一代的rpm软件包管理器，详情参考这里 参考 rpm、tar及yum使用详解RPM 和 YUM 包管理Linux 平台上的软件包管理Linux软件管理工具rpm详解Linux软件包管理工具yum详解yum命令Header V3 RSA/SHA1 Signature, key ID c105b9de: NOKEY如何使用yum来下载RPM包而不进行安装Ubuntu的包管理方式简介（apt-get、dpkg、aptitude）configure、make、make install 命令configure和make install背后的故事GNU Autotools的使用方法Makefile选项CFLAGS,LDFLAGS,LIBSdnf 命令用法详解linux devel包 和 非devel包的区别rpm.bin和bin区别GPG入门教程 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/software-about/yumgong-zuo-yuan-li.html":{"url":"medial-chapter/software-about/yumgong-zuo-yuan-li.html","title":"yum工作原理","keywords":"","body":"yum简介yum运行原理yum服务端yum客户端yum仓库repo文件格式yum仓库搭建使用目录使用ISO参考yum简介 yum（Yellow dogUpdater, Modified）是一个RPM包的前端管理工具，能够自动解决软件包的依赖关系 yum运行原理 yum的工作需要两部分来合作，分别是yum服务器和yum客户端 yum服务端 所有要发行的rpm包都放在yum服务器上以提供别人来下载 rpm包是根据kernel的版本号和cpu的版本号来进行编译发布的 包含了rpm包对应的版本号，conf文件，binary信息，及依赖信息 yum客户端 client每次都会去解析/etc/yum.repos.d下面所有以.repo结尾的配置文件 yum会定期去\"更新\"yum服务器上的rpm包\"清单\"，并保存到自己的cache里面 下载的rpm软件包默认缓存到/var/cache/yum，需要设置keepcache参数开启 yum仓库 yum仓库里存放了软件包的下载源和缓存等相关信息 [root@zhujipeng test]# ls /etc/yum yum/ yum.conf yum.repos.d/ [root@zhujipeng test]# ls /etc/yum.repos.d/ CentOS-Base.repo CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo CentOS-fasttrack.repo repo文件格式 [root@zhujipeng test]# cat /etc/yum.repos.d/CentOS-Media.repo # CentOS-Media.repo # # This repo can be used with mounted DVD media, verify the mount point for # CentOS-6. You can use this repo and yum to install items directly off the # DVD ISO that we release. # # To use this repo, put in your DVD and use it with the other repos too: # yum --enablerepo=c6-media [command] # # or for ONLY the media repo, do this: # # yum --disablerepo=\\* --enablerepo=c6-media [command] [c6-media] name=CentOS-$releasever - Media baseurl=file:///media/CentOS/ file:///media/cdrom/ file:///media/cdrecorder/ gpgcheck=1 enabled=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 参数如下 参数 说明 [...] 仓库的名称，不能重复 name 仓库的描述，必须参数 baseurl 配置仓库的路径，指定一个url mirrorlist 指向一个镜像列表，指定多个url enabled 是否启用当前仓库，值为1或0，默认为1 gpgcheck 是否需要gpg校验，值为1或0，默认为1 gpgkey 验证RPM包的密钥文件路径，可以在远处服务器上也可以在本地 cost 仓库优先级的配置，值越低表示访问的代价越低，也即优先使用 baseurl可以是本地目录，光盘，ftp，http形式的，值可以使用变量 变量 说明 $releasever 当前操作系统的主版本号。若CentOS6.4 该值为6 $basearch 当前平台的基本架构。x86_64 或 i386 $arch 当前平台版本架构。x86_64 或 i386/i586/i686等 详情请参考这里 yum仓库搭建 使用目录 详情参考createrepo：创建本地源 使用ISO 详情参考RedHat/CentOS利用iso镜像做本地yum源 参考 深入理解yum工作原理 rpm包制作使用RPM安装、卸载、查询、升级和校验软件包yum的工作原理以及如何建立yum仓库Linux软件包管理工具yum详解yum中$releasever、 $basearch等变量含义createrepo：创建本地源RedHat/CentOS利用iso镜像做本地yum源 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"medial-chapter/software-about/yumshi-yong-ji-qiao.html":{"url":"medial-chapter/software-about/yumshi-yong-ji-qiao.html","title":"yum实用技巧","keywords":"","body":"epelyum-utilsRpmfind参考epel EPEL的全称叫Extra Packages for Enterprise Linux 是由Fedora社区打造的为RHEL系列提供高质量软件包的项目 装上了EPEL之后就相当于添加了一个第三方源 [root@zhujipeng test]# yum search epel Loaded plugins: fastestmirror, ovl Loading mirror speeds from cached hostfile * base: mirrors.shuosc.org * extras: mirrors.shuosc.org * updates: mirrors.shuosc.org ================================================ N/S Matched: epel ================================================ epel-release.noarch : Extra Packages for Enterprise Linux repository configuration Name and summary matches only, use \"search all\" for everything. 详情参考 什么是EPEL 及 Centos上安装EPEL yum-utils yum-utils以多种方式扩充yum的功能，从而使其功能更强大，使用更方便 [root@zhujipeng test]# yum search yum-utils Loaded plugins: fastestmirror, ovl Loading mirror speeds from cached hostfile * base: mirrors.shuosc.org * extras: mirrors.shuosc.org * updates: mirrors.shuosc.org ============================================= N/S Matched: yum-utils ============================================== yum-utils.noarch : Utilities based around the yum package manager Name and summary matches only, use \"search all\" for everything. 详情参考 如何安装和使用’yum-utils’来维护Yum并提高其性能 Rpmfind Rpmfind是一个查找和下载rpm的网站，有非常强大的搜索功能 参考 什么是EPEL 及 Centos上安装EPEL如何在CentOS 5/6上安装EPEL 源如何安装和使用’yum-utils’来维护Yum并提高其性能 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/memory-about/":{"url":"senior-chapter/memory-about/","title":"内存相关","keywords":"","body":"本章是关于内存相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/memory-about/nei-cun-xiang-guan-ming-ling.html":{"url":"senior-chapter/memory-about/nei-cun-xiang-guan-ming-ling.html","title":"内存相关命令","keywords":"","body":"free输出详解参考free 查看内存的使用情况 free 选项 选项 说明 -b, --bytes 以字节（Byte）为单位显示 -k, --kilo 以千字节（）为单位显示 -m, --mega 以兆字节（MegaByte）为单位显示 -g, --giga 以吉字节（GigaByte）为单位显示 --tera 以太字节（TeraByte）为单位显示 -h, --human 自动决定更友好的显示单位 --si 使用1000而不使用1024进位 -t, --total 显示总计行 输出详解 [root@zhujipeng /]# free -m total used free shared buffers cached Mem: 1999 268 1730 161 5 166 -/+ buffers/cache: 97 1901 Swap: 3994 0 3994 输出 说明 total 物理内存总数 used 已经使用的内存数 free 空闲的内存数 shared 多个进程共享的内存数 buffers Buffer缓存内存数 cached Page缓存内存数 -buffers/cache 减去buffers/cache后使用的内存数 +buffers/cache 加上buffers/cache后剩余的内存数 Swap 交换分区，虚拟内存 free + buffers + cached + Swap 是实际可用的内存 参考 显示系统中空闲和已使用的内存Linux 内存 buffer 和 cache 的区别What is the difference between buffer vs cache memory in LinuxLinux Swap交换分区介绍总结Linux 内存中Page cache和buffer cache 的区别linux系统缓存机制Linux 内核的文件 Cache 管理机制介绍手工释放linux内存——/proc/sys/vm/drop_cache Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/disk-about/":{"url":"senior-chapter/disk-about/","title":"磁盘相关","keywords":"","body":"本章是关于磁盘相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/disk-about/ci-pan-xiang-guan-ming-ling.html":{"url":"senior-chapter/disk-about/ci-pan-xiang-guan-ming-ling.html","title":"磁盘相关命令","keywords":"","body":"dfdufdiskmountunmount/etc/fstab参考df df命令是用来查看文件系统的磁盘空间占用情况的 格式如下 df [选项] [文件...] 选项 说明 -a, --all 全部文件系统的列表 -B, --block-size=SIZE 指定区块大小 -h, --human-readable 以K，M，G为单位，更加易读 -H, --si 与-h参数相同，但是K，M，G是以1000为换算单位 -i, --inodes 显示inode信息，而不是大小 -k 以KB为单位输出，等同于--block-size=1K -m 以MB为单位输出，等同于--block-size=1M --no-sync 在取得磁盘信息前，不执行sync命令 --sync 在取得磁盘信息前，先执行sync命令 -t 文件系统类型 显示选定文件系统的磁盘信息 -T, --print-type 显示文件系统类型 -x, --exclude-type=TYPE 排除指定类型的文件系统 --help 显示帮助信息 --version 显示版本信息 命令示例 显示磁盘使用情况df 列出文件系统的类型df -T 更易读的方式显示目前磁盘空间和使用情况df -h 以inode模式来显示磁盘使用情况df -i 显示指定类型磁盘df -t ext3 du du命令是用来查看文件和目录的磁盘空间占用情况的 格式如下 du [选项] [文件...] 选项 说明 -a, -all 显示目录中文件的大小，而不仅仅是目录本身 -B, --block-size=SIZE 指定区块大小 -b, -bytes 显示目录或文件大小时，以byte为单位 -c, --total 除了显示目录或文件的大小外，同时也显示所有目录和文件的总和 -D, --dereference-args 显示命令行中指定软链接源文件大小 -d, --max-depth=N 指定目录的最大深度 -h, --human-readable 以K，M，G为单位，更加易读 -i, --inodes 显示inode信息，而不是大小 -k 以KB为单位输出，等同于--block-size=1K -L, --dereference 显示软链接源文件大小 -l, --count-links 重复计算硬件链接的文件 -m 以MB为单位输出，等同于--block-size=1M -P, --no-dereference 显示软链接本身的大小，是默认的选项 -S, --separate-dirs 显示目录的大小时，不含其子目录的大小 --si 与-h参数相同，但是K，M，G是以1000为换算单位 -s, --summarize 仅显示总计，列出最后加总的值 -X FILE, --exclude-from=FILE 排除文件中指定目录或文件 --exclude=PATTERN 排除指定的目录或文件 -x, --one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过 --help 显示帮助信息 --version 显示版本信息 fdisk fdisk可以添加、删除、转换磁盘分区，指定磁盘后就会进入交互模式 格式如下 fdisk [选项] fdisk -l [-u] [设备] fdisk -p fdisk -l可以查看硬盘的详细信息，交互命令如下，详情参见这里 交互命令 说明 m 列出帮助信息 n 创建一个分区 d 删除一个分区 p 列出分区表 q 不保存退出 t 改变分区类型 w 保存退出 mount mount命令是用来挂载设备的，详情参考这里 格式如下 mount [选项] 选项 说明 -a 安装在/etc/fstab文件中列出的所有文件系统 -f 测试mount，检查设备和目录的而不真正挂载文件系统 -n 不把安装信息记录在/etc/mtab文件中 -r, --read-only 将文件系统安装为只读 -v 显示详细安装信息 -w, --rw, --read-write 将文件系统安装为可写，为命令默认情况 -t, --types VFS_TYPE 指定设备的文件系统类型，参见文件系统类型表 -o, --options opts 指定挂载文件系统时的选项，参见挂载选项表 文件系统类型表如下 文件系统类型 说明 ext2 linux目前常用的文件系统 etx3 对ext2增加日志功能后的扩展文件系统 msdos MS-DOS的fat16文件系统 vfat windows98的fat32文件系统 ntfs windows NT/2000/XP 的文件系统 nfs 网络文件系统 iso9660 CD-ROM光盘标准文件系统 auto 自动检测文件系统 挂载选项类表如下 挂载选项 说明 defaults 使用所有选项的默认值（auto、nouser、rw、suid） auto/noauto 允许/不允许以–a选项进行安装 user/nouser 允许/不允许一般用户挂载 ro 以只读方式挂载 rw 以读写方式挂载 exec/noexec 允许/不允许执行二进制代码 suid/nosuid 确认/不确认suid和sgid位 dev/nodev 对/不对文件系统上的特殊设备进行解释 codepage=XXX 代码页 iocharset=XXX 字符集 remount 重新安装已经安装了的文件系统 loop 挂载环回设备 挂载示例（挂载点需要先创建） 挂载硬盘mount -t auto /dev/cdrom /mnt/cdrom 挂载iso文件mount -o loop linuxsetup.iso /mnt/iso1 挂载u盘（假设u盘的路径是/dev/sda1）mount /dev/sda1 /mnt/upan unmount unmount命令是用来卸载设备的，详情参考这里 格式如下 unmount [选项] 选项 说明 -l 不马上卸载设备，空闲时再卸载 /etc/fstab fstab记录了开机启动时加载的文件系统，详情参考这里 参考 每天一个linux命令：df 命令每天一个linux命令：du 命令linux下使用fdisk工具快速挂载新硬盘linux里挂载（mount）和取消挂载（umount）命令的使用Linux中的loop设备linux之fstab文件详解Linux查看磁盘剩余空间方法玩转 Linux 之：磁盘分区、挂载知多少 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/":{"url":"senior-chapter/process-about/","title":"进程相关","keywords":"","body":"本章是关于进程相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/jin-cheng-ji-chu-zhi-shi.html":{"url":"senior-chapter/process-about/jin-cheng-ji-chu-zhi-shi.html","title":"进程基础知识","keywords":"","body":"进程和线程基本简介指令（instruction）程序（program）进程（process）线程（thread）协程（coroutine）区别和联系线程资源共享的资源独有的资源生命周期进程结构进程标识信息内部标志符外部标识符进程调度信息进程的状态进程优先级其他的信息进程控制信息程序和数据地址进程同步和通信机制资源清单线程结构地址空间参考进程和线程 基本简介 指令（instruction） 计算机可以做的事情实际上非常简单，比如计算和寻址等等，这些最基础的计算机动作被称为指令 程序（program） 程序是指能够完成某些复杂操作和功能的指令集合 进程（process） 进程是一个程序关于某个数据集合的一次运行活动 线程（thread） 线程是系统调度的基本单元以及更加轻量级的进程 协程（coroutine） 协程是多入口调度的子程序以及更加轻量级的线程 区别和联系 详情参考Linux进程与线程的区别 进程是分配资源的基本单位，线程是调度的基本单位 进程至少有一个主线程，线程是更加轻量级的进程 进程之间各自独占资源，线程之间可以共享资源 进程与线程的一个简单解释可以参考这里 线程资源 详情参考同一进程的线程共享的资源和独有的资源 共享的资源 进程代码段 进程的公有数据 进程打开的文件描述符 进程的当前目录 进程用户ID 进程组ID 信号的处理器 独有的资源 线程ID 每个线程都有自己的线程ID并且这个ID在本进程中是唯一的 寄存器的值 线程必须有自己的寄存器组来保存和恢复线程切换似的状态 线程的堆栈 线程必须有自己的堆栈来保证线程之间独立运行而互不干扰 错误返回码 线程必须有自己的错误返回码来避免错误被其他线程所覆盖 线程优先级 线程必须有自己的优先级来表明线程间不同线程的重要程度 信号屏蔽码 由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理 但所有的线程都共享同样的信号处理器 生命周期 新建（New） 就绪（Runnable） 运行（Running） 阻塞（Blocked） 死亡（Dead） Java线程阻塞的情况 线程在请求一个被其他线程持有的锁 线程调用了一个阻塞式IO的操作 线程调用了sleep方法暂停执行 线程调用了wait方法等待唤醒 线程调用了suspend方法挂起 suspend容易导致死锁，不推荐 Java线程死亡的情况 run方法结束，线程正常结束 线程抛出一个了未被捕获的异常 调用线程的stop方法来结束线程 stop容易导致死锁，不推荐 进程结构 进程结构由进程控制块（PCB）（process control block）描述，详情参见这里 主要包含以下几部分 进程标识信息 进程调度信息 进程控制信息 处理机的状态 进程的数据段 进程标识信息 内部标志符 由操作系统为每个进程生成的一个唯一的数字标识符，称为进程号（pid）（process identity descriptor） 外部标识符 由创建者产生的附加信息，是由字母和数字组成的字符串，例如进程名 进程调度信息 进程的状态 标识进程的当前状态（就绪、运行、阻塞） 进程优先级 表示进程获得处理机使用权的优先程度 其他的信息 为进程调度算法提供依据的其他信息 例如进程等待时间、进程已经获得处理器的总时间和进程占用内存的时间等 进程控制信息 程序和数据地址 组成进程的程序和数据所在内存或外存中的首地址以及相关段信息 进程同步和通信机制 指实现进程同步和通信时所采取的机制，如消息队列指针和信号量等 资源清单 列出了进程所需的全部资源及已经分配给该进程的资源，但不包括CPU 线程结构 详情参见内核线程与用户线程的一点小总结 地址空间 详情参见浅谈进程地址空间与虚拟存储空间 参考 操作系统 - 进程的概念Linux进程基础 Linux进程关系Linux从程序到进程关于进程、线程生命周期的总结进程、进程组、作业、会话进程与线程的一个简单解释进程控制块、进程上下文数据段、代码段、堆栈段、BSS段的区别关于 Linux 进程你所需要知道的一切 Linux进程与线程的区别Unix / Linux 线程的实质同一进程的线程共享的资源和独有的资源内核线程与用户线程的一点小总结浅谈进程地址空间与虚拟存储空间what-is-the-difference-between-a-thread-process-taskLinux多线程与同步 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/jin-cheng-gao-ji-zhi-shi.html":{"url":"senior-chapter/process-about/jin-cheng-gao-ji-zhi-shi.html","title":"进程高级知识","keywords":"","body":"进程管理进程组作业会话进程类型后台进程nohup守护进程进程信号信号的响应常见的信号信号快捷键进程信息fork参考进程管理 进程组 一个或多个进程 的集合 作业 一个或多个进程 的集合 shell可以进行作业控制，可以运行一个前台作业和多个后台作业 如果作业中的某个进程又创建了子进程，则子进程不属于该作业 作业运行结束后如果前台进程不存在，shell就把自己提到前台 会话 一个或多个进程组 的集合 通常一个会话开始于用户登录，终止于用户退出，在此期间该用户运行的所有进程都属于这个会话期 会话包括控制进程（会话首进程），一个前台进程组和任意多个后台进程组 一个会话只能有一个控制终端 ，控制终端上的输入和信号将发送给会话的前台进程组中的所有进程 进程类型 进程状态，详情参见这里 状态 说明 D Uninterruptible sleep (usually IO) R Running or runnable (on run queue) S Interruptible sleep (waiting for an event to complete) T Stopped, either by a job control signal or because it is being traced W paging (not valid since the 2.6.xx kernel) X dead (should never be seen) Z Defunct (\"zombie\") process, terminated but not reaped by its parent 前台进程 一般默认在shell中启动的进程就是前台进程 后台进程 脱离终端在后台执行的程序，通常以d结尾 僵尸进程 父进程没有获取子进程退出状态信息的子进程 详情参考 这里 和 这里 后台进程 使用ctrl + z快捷键可以将前台进程变为后台进程 [root@zhujipeng /]# sleep 60 ^Z [1]+ Stopped sleep 60 [root@zhujipeng /]# jobs [1]+ Stopped sleep 60 [root@zhujipeng /]# bg [1]+ sleep 60 & [root@zhujipeng /]# fg sleep 60 ^C 命令后面使用 & 符号可以将进程变为后台进程 [root@zhujipeng /]# sleep 60 & [1] 28 [root@zhujipeng /]# jobs [1]+ Running sleep 60 & [root@zhujipeng /]# kill -9 %1 [root@zhujipeng /]# jobs [1]+ Killed sleep 60 nohup 会话中前台进程会收到SIGHUP信号而终止，后台进程则由huponexit参数决定 [root@zhujipeng /]# shopt | grep huponexit huponexit off SIGHUP会在以下3种情况下被发送给相应的进程，详见这里 终端关闭时，该信号被发送到session首进程以及作为job提交的进程（&提交的进程） session首进程收到信号退出时，该信号被发送到该session前台进程组中的每一个进程 若进程组是孤儿进程组并且有进程处于停止状态，该信号被发送到该进程组中的每一个进程 进程处于停止状态是收到了SIGSTOP或SIGTSTP信号 守护进程 守护进程是指忽略了SIGHUP信号的进程，启动方法参见这里和这里 进程信号 信号(signal)就是一种向进程传递信息的方式，详见这里 [root@zhujipeng /]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX 0号信号是测试信号，可以检测进程是否存在 信号的响应 中止进程(Term) 忽略信号(Ign) 中止进程并保存内存信息(Core) 停止进程(Stop) 继续运行进程(Cont) 常见的信号 信号名 信号值 动作 说明 SIGHUP 1 Term 终止进程（可以被捕获、阻塞或忽略） SIGINT 2 Term 中断 (INTERRUPT) 进程（可以被捕获、阻塞或忽略） SIGQUIT 3 Core 退出 (QUIT) 进程（可以被捕获、阻塞或忽略） SIGILL 4 Core 非法指令(程序错误、试图执行数据段、栈溢出等) SIGABRT 6 Core 调用abort函数触发 SIGFPE 8 Core 算术运行错误(浮点运算错误、除数为零等) SIGKILL 9 Term 杀死（KILL）进程(不能被捕获、阻塞或忽略) SIGSEGV 11 Core 无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作) SIGPIPE 13 Term 消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作) SIGALRM 14 Term 时钟定时信号 SIGTERM 15 Term 结束(TERMINAL)进程(可以被捕获、阻塞或忽略) SIGUSR1 30,10,16 Term 用户保留 SIGUSR2 31,12,17 Term 用户保留 SIGCHLD 20,17,18 Ign 子进程结束(由父进程接收) SIGCONT 19,18,25 Cont 继续执行已经停止的进程(不能被阻塞) SIGSTOP 17,19,23 Stop 停止进程(不能被捕获、阻塞或忽略) SIGTSTP 18,20,24 Stop 停止进程(可以被捕获、阻塞或忽略) SIGTTIN 21,21,26 Stop 后台程序从终端中读取数据时触发 SIGTTOU 22,22,27 Stop 后台程序向终端中写数据时触发 信号快捷键 [root@zhujipeng /]# stty -a speed 38400 baud; rows 26; columns 115; line = 0; intr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = ; eol2 = ; swtch = ; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0; -parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts -cdtrdsr -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany -imaxbel -iutf8 opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke 信号 快捷键 SIGINT CTRL+C SIGQUIT CTRL+\\ SIGTSTP CRTL+Z CRTL+D 是发送特殊的 EOF 字符 进程信息 /proc下存在一些以进程id命名的文件，详情参见这里 [root@zhujipeng /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 12:03 pts/0 00:00:00 /bin/bash root 235 0 0 13:14 ? 00:00:00 /sbin/udevd -d root 248 0 0 13:16 pts/2 00:00:00 bash root 288 248 0 14:38 pts/2 00:00:00 ps -ef [root@zhujipeng /]# ls /proc/1 attr comm fd maps ns projid_map smaps task autogroup coredump_filter fdinfo mem oom_adj root stack timers auxv cpuset gid_map mountinfo oom_score sched stat timerslack_ns cgroup cwd limits mounts oom_score_adj schedstat statm uid_map clear_refs environ loginuid mountstats pagemap sessionid status wchan cmdline exe map_files net personality setgroups syscall fork 由fork创建的新进程被称为子进程（child process），详情见fork出的子进程和父进程 参考 进程、进程组、作业、会话戏说守护、僵尸、孤儿进程孤儿进程与僵尸进程 Linux后台任务的运行、查看和关闭Linux 守护进程的启动方法让进程在后台可靠运行的几种方法Linux 守护进程的实现Linux ssh exit，启动的后台进程不会停止SIGHUP信号与控制终端Linux信号基础 linux内核中异步通知机制--信号处理机制Linux信号处理机制Linux中ctrl-c, ctrl-z, ctrl-d 区别Linux进程的Uninterruptible sleepLinux查看进程的启动和运行相关的文件fork出的子进程和父进程 shell中的fork、source和exec总结What does kill -0 do Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/jin-cheng-ji-chu-ming-ling.html":{"url":"senior-chapter/process-about/jin-cheng-ji-chu-ming-ling.html","title":"进程基础命令","keywords":"","body":"ps选项详解简单选择列表选择输出控制排序输出使用详解基本示例输出详解top输出详解交互命令参考ps 查看进程某一时刻的快照信息 ps [选项] 选项风格 UNIX 风格，选项可以组合在一起，并且选项前必须有-连字符 BSD 风格，选项可以组合在一起，但是选项前不能有-连字符 GNU 风格，长选项前有两个“-”连字符，值用空格或等号分割 选项详解 简单选择 选项 说明 a 显示包含终端的所有进程，ax显示所有进程 x 显示当前用户的所有进程，ax显示所有进程 -a 显示包含终端的除了会话领导者以外的所有进程 -A 显示所有进程 -d 显示除了会话领导者以外的所有进程 -e 显示所有进程 e 显示环境变量 -N, --deselect 反向选择进程 r 只显示正在运行的进程 [root@zhujipeng ~]# ps a -o tty | sort -u pts/0 pts/1 TT tty1 [root@zhujipeng ~]# ps -e -o tty | sort -u ? pts/0 pts/1 TT tty1 [root@zhujipeng ~]# ps x -o user | sort -u root USER [root@zhujipeng ~]# ps -e -o user | sort -u avahi dbus dig ntp polkitd postfix root USER zabbix 列表选择 列表的值用空格或逗号分割，形如ps -p \"1 2 3\" -p 4,5,6 选项 说明 -123 等同于--pid 123 123 等同于--pid 123 \"1 2 3\" 等同于-p 1 -p 2 -p 3 1,2,3 等同于-p 1 -p 2 -p 3 -C cmdlist 指定命令列表 -G grplist 指定真实用户组列表 -g grplist 指定有效用户组列表 --Group grplist 等同于-G --group grplist 等同于-g p pidlist 指定进程id列表 -p pidlist 指定进程id列表 --pid pidlist 指定进程id列表 --ppid pidlist 指定父进程id列表 q pidlist 指定进程id列表（快速模式） -q pidlist 指定进程id列表（快速模式） --quick-pid pidlist 指定进程id列表（快速模式） -s sesslist 指定会话id列表 --sid sesslist 指定会话id列表 t ttylist 指定终端列表 -t ttylist 指定终端列表 --tty ttylist 指定终端列表 U userlist 指定有效用户列表 -U userlist 指定真实用户列表 -u userlist 指定有效用户列表 --User userlist 指定真实用户列表 --user userlist 指定有效用户列表 注意：小写的单词需要替换为实际值 输出控制 输出格式请参照man ps中的STANDARD FORMAT SPECIFIERS章节 选项 说明 -f 显示所有列 -F 显示更多的额外列 --format 指定输出格式，等同于-o o format 指定输出格式 o format 指定输出格式 注意：小写的单词需要替换为实际值 排序输出 --sort可以指定排序，格式为[+|-]key[,[+|-]key[,...]] 值请参照man ps中的STANDARD FORMAT SPECIFIERS章节 使用详解 基本示例 标准语法 [root@zhujipeng /]# ps -e PID TTY TIME CMD 1 pts/0 00:00:00 bash 15 pts/1 00:00:00 bash 40 pts/1 00:00:00 ps [root@zhujipeng /]# ps -ef UID PID PPID C STIME TTY TIME CMD root 1 0 0 09:23 pts/0 00:00:00 /bin/bash root 15 0 0 09:23 pts/1 00:00:00 bash root 33 15 0 10:19 pts/1 00:00:00 ps -ef [root@zhujipeng /]# ps -eF UID PID PPID C SZ RSS PSR STIME TTY TIME CMD root 1 0 0 3258 2776 0 09:23 pts/0 00:00:00 /bin/bash root 15 0 0 3258 3052 1 09:23 pts/1 00:00:00 bash root 38 15 0 3727 2252 1 10:24 pts/1 00:00:00 ps -eF BSD语法 [root@zhujipeng /]# ps -ax Warning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQ PID TTY STAT TIME COMMAND 1 pts/0 Ss+ 0:00 /bin/bash 15 pts/1 Ss 0:00 bash 36 pts/1 R+ 0:00 ps -ax [root@zhujipeng /]# ps -aux Warning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQ USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.1 13032 2776 pts/0 Ss+ 09:23 0:00 /bin/bash root 15 0.0 0.1 13032 3052 pts/1 Ss 09:23 0:00 bash root 34 0.0 0.1 14912 2260 pts/1 R+ 10:20 0:00 ps -aux [root@zhujipeng /]# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.1 13032 2776 pts/0 Ss+ 09:23 0:00 /bin/bash root 15 0.0 0.1 13032 3052 pts/1 Ss 09:23 0:00 bash root 35 0.0 0.1 14912 2280 pts/1 R+ 10:20 0:00 ps aux 注意 - 对 aux的影响不同，-aux代表筛选名为x的用户 指定输出列 [root@zhujipeng /]# ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm PID TID CLS RTPRIO NI PRI PSR %CPU STAT WCHAN COMMAND 1 1 TS - 0 19 0 0.0 Ss+ - bash 15 15 TS - 0 19 1 0.0 Ss - bash 48 48 TS - 0 19 0 0.0 R+ - ps [root@zhujipeng /]# ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm STAT EUID RUID TT TPGID SESS PGRP PPID PID %CPU COMMAND Ss+ 0 0 pts/0 1 1 1 0 1 0.0 bash Ss 0 0 pts/1 49 15 15 0 15 0.0 bash R+ 0 0 pts/1 49 15 49 15 49 0.0 ps [root@zhujipeng /]# ps -Ao pid,tt,user,fname,tmout,f,wchan PID TT USER COMMAND TMOUT F WCHAN 1 pts/0 root bash - 4 - 15 pts/1 root bash - 4 - 50 pts/1 root ps - 0 - 指定命令名 [root@zhujipeng /]# ps -C bash -o pid,cmd PID CMD 1 /bin/bash 15 bash 指定排序列 [root@zhujipeng /]# ps -ef --sort=%cpu UID PID PPID C STIME TTY TIME CMD root 1 0 0 13:14 pts/0 00:00:00 /bin/bash root 16 0 0 13:14 pts/1 00:00:00 bash root 41 16 0 13:28 pts/1 00:00:00 ps -ef --sort=%cpu [root@zhujipeng /]# ps -ef --sort=%mem UID PID PPID C STIME TTY TIME CMD root 1 0 0 13:14 pts/0 00:00:00 /bin/bash root 16 0 0 13:14 pts/1 00:00:00 bash root 42 16 0 13:28 pts/1 00:00:00 ps -ef --sort=%mem [root@zhujipeng /]# ps -ef --sort -pcpu UID PID PPID C STIME TTY TIME CMD root 1 0 0 13:14 pts/0 00:00:00 /bin/bash root 16 0 0 13:14 pts/1 00:00:00 bash root 48 16 0 13:30 pts/1 00:00:00 ps -ef --sort -pcpu [root@zhujipeng /]# ps -ef --sort -pmem UID PID PPID C STIME TTY TIME CMD root 1 0 0 13:14 pts/0 00:00:00 /bin/bash root 16 0 0 13:14 pts/1 00:00:00 bash root 49 16 0 13:30 pts/1 00:00:00 ps -ef --sort -pmem 输出详解 列的含义 列名 说明 UID 用户id PID 进程id PPID 父进程id STIME 开始时间 TTY 终端 TIME CPU使用时间 CMD 命令 %CPU cpu使用率 %MEM 内存使用率 VSZ 虚拟内存使用大小 RSS 内存使用大小 STAT 进程的状态 进程状态 状态 说明 D 不可中断的静止 R 正在执行中 S 静止状态 T 暂停执行 Z 不存在但暂时无法消除 W 没有足够的记忆体分页可分配 高优先序的行程 N 低优先序的行程 L 有记忆体分页分配并锁在记忆体内 s 会话首进程 l 多线程进程 top 实时查看进程的信息 top [选项] 选项 说明 -d 指定每两次屏幕信息刷新之间的时间间隔，默认为5s -p 通过指定监控进程ID来仅仅监控某个进程的状态 -q 使top尽可能没有任何延迟的进行刷新 -S 指定累计模式 -s 在安全模式中运行，不支持交互 -i 不显示任何闲置或者僵死进程 -c 显示整个命令行而不只是显示命令名 输出详解 top - 13:47:56 up 1:06, 0 users, load average: 0.00, 0.00, 0.00 Tasks: 3 total, 1 running, 2 sleeping, 0 stopped, 0 zombie Cpu(s): 0.2%us, 0.0%sy, 0.0%ni, 99.7%id, 0.2%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 2047048k total, 275400k used, 1771648k free, 5144k buffers Swap: 4090876k total, 0k used, 4090876k free, 170424k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 13032 2776 2516 S 0.0 0.1 0:00.05 bash 16 root 20 0 13032 3104 2732 S 0.0 0.2 0:00.11 bash 53 root 20 0 14952 1964 1756 R 0.0 0.1 0:00.01 top 第一行（top） 输出 说明 13:47:56 当前时间 up 系统启动了多久 users 用户数 load average 最近1分钟前、5分钟前、15分钟前的平均负载 第二行（Tasks） 输出 说明 total 系统总进程数 running 运行中的进程数 sleeping 睡眠中的进程数 stoped 停止的进程数 zombie 僵尸进程数 第三行（Cpu） 输出 说明 us （user）用户空间占用CPU的百分比 sy （system）内核空间占用CPU的百分比 ni （nice）改变过优先级的进程占用CPU的百分比 id （idle）空闲CPU百分比 wa （wait）IO等待占用CPU的百分比 hi （Hardware IRQ）硬中断占用CPU的百分比 si （Software IRQ）软中断占用CPU的百分比 st 虚拟机占用百分比 IRQ全称为Interrupt Request，即是“中断请求”的意思 第四行（Mem） 输出 说明 total 物理内存总量 used 已使用的内存总量 free 空闲的内存总量 buffers 缓存使用的内存量 第五行（Swap） 输出 说明 total 交换区总量 used 使用的交换区总量 free 空闲交换区总量 cached 缓冲使用的交换区总量 第七行 输出 说明 PID 进程id USER 进程所有者 PR 进程优先级 NI nice值。负值表示高优先级，正值表示低优先级 VIRT 进程使用的虚拟内存总量，单位kb RES 进程使用的未被换出的物理内存大小，单位kb SHR 共享内存大小，单位kb S 进程状态 %CPU CPU占用百分比 %MEM 物理内存百分比 TIME+ 进程使用的CPU时间总计，单位1/100秒 COMMAND 进程名称（命令名/命令行） 交互命令 详情参这里或者在top中使用h按键 参考 10个重要的Linux ps命令实战Linux中ps命令详解使用top命令查看CPU负载 Linux top命令的用法详细详解linux下查看最消耗CPU、内存的进程理解Linux的性能理解Linux系统负荷Linux中CPU负载和CPU使用率表示的含意浅谈Linux下CPU利用率和CPU负载及其代码实现原理 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/jin-cheng-zhong-ji-ming-ling.html":{"url":"senior-chapter/process-about/jin-cheng-zhong-ji-ming-ling.html","title":"进程中级命令","keywords":"","body":"killlsofpidofbgfgscreennmon参考kill 用于像进程发送信号，主要用于杀死进程，详情参考这里 [root@zhujipeng /]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX 信号可以使用上面的数字或单词去掉SIG的部分，详情参见 lsof 列出打开的文件（list open files），详情参考这里 pidof 找出正在运行的程序的进程id，详情参考这里 bg 将后台停止的进程变为运行，详情参考这里 fg 将后台运行的进程变为前台进程，详情参考这里 screen 用于命令行终端切换的自由软件，详情参考这里 nmon 分析AIX和Linux性能的免费工具，详情参考这里 参考 linux kill命令详解Linux 命令神器：lsof 入门 lsof在Linux中的10个例子lsof print numeric ports我使用过的Linux命令之pidofLinux的bg和fg命令screen命令使用 screen 管理你的远程会话分析 AIX 和 Linux 性能的免费工具invalid signal specification error in bash script Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/jin-cheng-gao-ji-ming-ling.html":{"url":"senior-chapter/process-about/jin-cheng-gao-ji-ming-ling.html","title":"进程高级命令","keywords":"","body":"runuserpstreepstackstracejpsdaemonize参考runuser 以其他用户身份运行程序，详情参考这里 pstree 显示进程树和具体的线程，详情参考这里 pstack 显示进程执行的栈跟踪信息，详情参考这里 strace 跟踪进程执行时的系统调用，详情参考这里 jps 查看Java继承信息，详情参考这里 daemonize 将进程变为守护进程运行，详情参考这里 参考 Linux下以其他用户身份运行程序 Linux下多线程查看工具(pstree、ps、pstack)如何使用strace+pstack利器分析程序性能自助Linux之问题诊断工具stracelinux 调试利器gdb, strace, pstack, pstree, lsof线上应用故障排查之一：高CPU占用一次服务器CPU占用率高的定位分析 JVM性能调优监控工具jps出现– process information unavailable解决方法Linux守护进程运行命令daemonize各种工具使用手册-strace使用truss、strace或ltrace诊断软件的\"疑难杂症\" Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/jin-cheng-wen-jian-du-xie.html":{"url":"senior-chapter/process-about/jin-cheng-wen-jian-du-xie.html","title":"进程文件读写","keywords":"","body":"磁盘IO缓存I/O直接IO文件读写虚拟文件系统（VFS）系统主要模块内核数据结构进程文件表打开文件表文件节点表操作的原子性并发数据冲突多进程单线程，每个进程打开一个fd单进程多线程，单个进程打开一个fd单进程多线程，每个线程打开一个fd参考磁盘IO 详情参见 磁盘IO：缓存IO与直接IO 缓存I/O 缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O 在Linux的缓存I/O机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间 读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中 写操作：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令 直接IO 直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区 文件读写 虚拟文件系统（VFS） 一个操作系统可以支持多种底层不同的文件系统（比如NTFS, FAT, ext3, ext4），为了给内核和用户进程提供统一的文件系统视图，Linux在用户进程和底层文件系统之间加入了一个抽象层，即虚拟文件系统(Virtual File System, VFS)，进程所有的文件操作都通过VFS，由VFS来适配各种底层不同的文件系统，完成实际的文件操作 系统主要模块 详情参考从内核文件系统看文件读写过程 模块 说明 super_block 超级块，用于保存一个文件系统的所有元数据 dir_entry 目录项模块，管理路径的的文件和目录项 inode 指向一个具体的文件，是文件的唯一标识 open_files 打开的文件列表模块，包含所有内核已经打开的文件 file_operations 一系列文件操作函数指针的集合 address_space 记录了文件在页缓存中已经缓存了的物理页 内核数据结构 详情参考linux下多进程/多线程文件操作详解 文件节点在unix中是vnode，linux中是inode 进程文件表 每个进程都有一张进程文件表，其中的每一项都指向了某一个打开的文件 子进程会共享父进程的进程文件表 打开文件表 内核为所有打开文件维持一张文件表，其中的每一项都指向了真正的文件 打开文件表是系统级别的，和进程无关 文件节点表 文件节点表记录了文件的相关信息，包括所有者，长度，所在设备等信息 两个打开文件表项可以指向同一个文件，使得文件被进程共享 操作的原子性 创建文件的操作是原子性的 read()/write()函数的调用是原子性 lseek()可以设置偏移量，是原子性的 并发数据冲突 对于write()操作，我们可以通过open文件时指定O_APPEND选项来解决 多进程单线程，每个进程打开一个fd 这种情况下数据冲突的本质是存在多个fd 每个fd指向不同的打开文件表项 也就是拥有多个不同的文件偏移量 可能会导致写入文件的数据相互覆盖 单进程多线程，单个进程打开一个fd 这种情况下线程间共用同一个fd 只有一个文件表项，也就是只有一个文件偏移量 如果不需要调用lseek，那么并没有数据冲突的危险 单进程多线程，每个线程打开一个fd 这种情况下线程间各自打开一个fd 每个fd指向不同的打开文件表项 也就是拥有多个不同的文件偏移量 可能会导致写入文件的数据相互覆盖 参考 磁盘IO：缓存IO与直接IOLinux 内核详解以及内核缓冲区技术从内核文件系统看文件读写过程linux下多进程/多线程文件操作详解Linux中的文件描述符与打开文件之间的关系Linux系统环境下关于多进程并发写同一个文件的讨论 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/jin-cheng-tong-xin-fang-shi.html":{"url":"senior-chapter/process-about/jin-cheng-tong-xin-fang-shi.html","title":"进程通信方式","keywords":"","body":"进程通信IPC进程通行方式线程通信方式RPC参考进程通信 有时候进程间需要协作来完成某项功能，典型的如Master-Worker模型，这时候就需要进行进程间通信 IPC 进程间通信（Inner Process Communication） 进程通行方式 进程间采用的通信方式要么需要切换内核上下文，要么要与外设访问(有名管道，文件)，所以速度会比较慢 共享内存（shared memory） 消息队列（message queue） 有名管道（named pipe） 无名管道（pipe） 信号量（semaphore） 信号（signal） 文件（file） 套接字（socket） 线程通信方式 除了可以使用进程的通信方式，还可以使用 全局变量 条件变量 线程信号 互斥量 读写锁 自旋锁 RPC 远程过程调用（Remote Procedure Call），详情参考这里 参考 python使用master worker管理模型开发服务端并行程序设计模式--Master-Worker模式进程间、线程间通信方式小结深刻理解Linux进程间通信（IPC）Linux进程与线程的区别Linux进程间通信——使用共享内存Linux进程间通信——使用消息队列Linux进程间通信——使用命名管道Linux进程间通信——使用匿名管道Linux进程间通信——使用信号量Linux进程间通信——使用信号Linux进程间通信——使用流套接字浅析线程间通信一：互斥量和条件变量浅析线程间通信二：读写锁和自旋锁Linux线程编程之信号处理RPC综述 - PB, Thrift, Avro谁能用通俗的语言解释一下什么是 RPC 框架 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/jin-cheng-xin-xi-cai-ji.html":{"url":"senior-chapter/process-about/jin-cheng-xin-xi-cai-ji.html","title":"进程信息采集","keywords":"","body":"vmstat输出格式iostat输出格式sar(System Activity Reporter)参考vmstat 采集进程的相关信息 vmstat [options] [delay [count]] 选项 说明 -n, --one-header 只显示一次头部信息 -s, --stats 显示统计信息 -S, --unit 指定k或m来更友好的显示 输出格式 [root@zhujipeng /]# vmstat procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 3 0 2253612 2016736 256864 8466484 0 1 27 230 0 1 5 1 94 0 0 字段 说明 r 处于运行态和就绪态的进程 b 处于阻塞态的进程 swpd 交换内存已使用的大小 free 空闲的物理内存的大小 buff 系统的缓存内存 cache 文件的缓存内存 si 每秒从磁盘读入虚拟内存的大小 so 每秒从虚拟内存写入磁盘的大小 bi 块设备每秒接收的块数量 bo 块设备每秒发送的块数量 in 每秒CPU的中断次数 cs 每秒上下文切换次数 us 用户CPU时间 sy 系统CPU时间 id 空闲CPU时间 wa 等待IO完成的CPU时间 iostat 采集磁盘的统计信息 iostat [ -c ] [ -d ] [ -h ] [ -k | -m ] [ -N ] [ -t ] [ -V ] [ -x ] [ -y ] [ -z ] [ -j { ID | LABEL | PATH | UUID | ... } ] [ [ -T ] -g group_name ] [ -p [ device [,...] | ALL ] ] [ device [...] | ALL ] [ interval [ count ] ] 选项 说明 -c 显示cpu相关的信息 -d 显示设备相关的信息 -h 设备信息的显示结果对人类更友好 -k 以千字节为单位显示 -m 以兆字节为单位显示 -t 输出时间信息 -x 显示额外的信息 -z 不显示不活跃的设备的信息 输出格式 [root@zhujipeng /]# iostat -m Linux 3.10.0-327.36.3.el7.x86_64 (zhujipeng) 2017年10月25日 _x86_64_ (12 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 5.14 0.00 0.90 0.29 0.03 93.64 Device: tps MB_read/s MB_wrtn/s MB_read MB_wrtn vda 2.50 0.01 0.02 46194 101982 vdb 0.20 0.00 0.01 15674 33398 vdc 71.84 0.30 2.62 1476509 12934514 [root@zhujipeng /]# iostat -x Linux 3.10.0-327.36.3.el7.x86_64 (mty-004) 2017年10月25日 _x86_64_ (12 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 5.14 0.00 0.90 0.29 0.03 93.64 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util vda 0.00 0.07 0.22 2.29 9.57 21.13 24.54 0.00 1.32 1.94 1.26 0.48 0.12 vdb 0.69 1.64 0.12 0.09 3.25 6.92 99.77 0.01 35.71 0.48 83.86 0.92 0.02 vdc 0.00 104.90 13.16 58.68 305.90 2680.04 83.12 0.49 6.81 1.52 7.99 0.31 2.26 字段 说明 %user 用户cpu时间百分比 %nice 改变过优先级的进程的占用CPU的百分比 %system 系统cpu时间百分比 %iowait 等待IO完成cpu时间百分比 %steal Hypervisor分配给运行在其它虚拟机上的任务的实际cpu时间 %idle 空闲cpu时间百分比 tps io吞吐量 MB_read/s 每秒读取速度（本例中单位为兆） MB_wrtn/s 每秒写入速度（本例中单位为兆） MB_read 已读取的数据大小（本例中单位为兆） MB_wrtn 已写入的数据大小（本例中单位为兆） rrqm/s 每秒读请求被文件系统合并的数量 wrqm/s 每秒写请求被文件系统合并的数量 r/s 每秒读请求的数量 w/s 每秒写请求的数量 rkB/s 每秒读取数据的大小（单位为千字节） wkB/s 每秒写入数据的大小（单位为千字节） avgrq-sz 请求扇区的平均大小 avgqu-sz 请求队列的平均长度 await IO请求响应的平均时间（单位是毫秒） r_await IO读请求响应的平均时间（单位是毫秒） w_await IO写请求响应的平均时间（单位是毫秒） svctm 每次设备I/O操作的服务时间（单位是毫秒） %util 统计时间内所有处理IO时间比率 %util 暗示了设备的繁忙程度，如果是多磁盘，即使%util是100%，磁盘使用未必就到了瓶颈 sar(System Activity Reporter) 监控Linux系统的活动状况，详情参见这里 参考 Linux vmstat命令实战详解Linux CPU实时监控mpstat命令详解Linux IO实时监控iostat命令详解Linux 运行进程实时监控pidstat命令详解使用vmstat和iostat命令进行Linux性能监控剖析 Linux hypervisor虚拟化 - KVM 和 Xen 比较对比Xen和KVM：Linux虚拟化技术选择KVM详解，太详细太深入了，经典LXC(Linux containers)快速入门谈谈 OpenStack 与 Docker 的落地方案选择 Docker学习笔记 — Docker与LXC的区别Docker学习笔记1——为啥要用DockerDocker学习笔记2——Docker Toolbox是啥Docker学习笔记3——Docker vs KVMDocker学习笔记4——Docker VolumeDocker Toolbox利器让你更愉快地使用容器Docker Machine、Swarm、ComposeLinux使用sar进行性能分析 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/process-about/jin-cheng-diao-shi-ji-zhu.html":{"url":"senior-chapter/process-about/jin-cheng-diao-shi-ji-zhu.html","title":"进程调试技术","keywords":"","body":"gdb参考gdb GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具 gdb [选项] gdb [选项] gdb [选项] program也就是你的执行文件，一般在当前目录下 选项 说明 -s FILE 指定符号表 -symbols=FILE 指定符号表 -c FILE 指定core dump文件 -core=FILE 指定core dump文件 -d DIRECTORY 指定源文件搜索目录 -directory=DIRECTORY 指定源文件搜索目录 gdb交互命令请参考用GDB调试程序 参考 用GDB调试程序使用truss、strace或ltrace诊断软件的\"疑难杂症\"使用 gdb 调试运行中的 Python 进程 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/":{"url":"senior-chapter/network-about/","title":"网络相关","keywords":"","body":"本章是关于网络相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/wang-luo-ji-chu-ming-ling.html":{"url":"senior-chapter/network-about/wang-luo-ji-chu-ming-ling.html","title":"网络基础命令","keywords":"","body":"pingtelnettelnet交互ifconfig输出格式lsof显示连接信息显示所有连接仅获取IPv6流量仅显示TCP/UDP连接显示指定端口的连接显示指定主机的连接显示指定主机和端口的连接显示监听端口hostnamenslookupdigarpip参考ping 用来测试主机之间网络的连通性 ping [选项] 地址可以是ip，主机名（hostname），域名（domain） 选项 说明 -c COUNT 指定发送请求的次数 -D 在结果前面显示unix时间戳 -i INTERVAL 指定发送请求的时间间隔 -I 指定发送使用的网络接口 -n 显示ip而不是域名 -q 不显示中间信息 -R 记录路由过程 -v 输出详细过程 -V 显示版本 有时候无法ping，有可能是被管理员或防火墙禁用了 telnet 用于登录远程主机，对远程主机进行管理 telnet因为采用明文传送报文，安全性不好，现在基本都不开放telnet服务，而改用更安全的ssh方式了 telnet [选项] 地址可以是ip，主机名（hostname），域名（domain） telnet交互 telnet远程后会进入输入模式，此时无法退出，使用Ctrl + ] 可以切换到交互模式，输入quit后可以退出 [root@zhujipeng /]# telnet 192.168.8.192 12345 Trying 192.168.8.192... Connected to 192.168.8.192. Escape character is '^]'. ^] telnet> ? Commands may be abbreviated. Commands are: close close current connection logout forcibly logout remote user and close the connection display display operating parameters mode try to enter line or character mode ('mode ?' for more) open connect to a site quit exit telnet send transmit special characters ('send ?' for more) set set operating parameters ('set ?' for more) unset unset operating parameters ('unset ?' for more) status print status information toggle toggle operating parameters ('toggle ?' for more) slc change state of special charaters ('slc ?' for more) z suspend telnet ! invoke a subshell environ change environment variables ('environ ?' for more) ? print help information telnet> quit Connection closed. ifconfig 查看和设置网络接口 ifconfig [-v] [-a] [-s] [interface] ifconfig [-v] interface [aftype] options | address ... 选项 说明 -a 显示所有的网络接口，包括未启用的 -s 显示简短的信息，和netstat -i一样 -v 显示详细的信息 options 说明 up 激活指定网口 down 关闭指定网口 [-]arp 开启或关闭arp协议 [-]promisc 开启或关闭混杂模式 [-]allmulti 开启或关闭多播模式 mtu N 设置最大传输单元 netmask ADDR 设置网络掩码 add ADDR/PREFIXLEN 添加IPv6地址到指定网口 add ADDR/PREFIXLEN 删除指定网口的IPv6地址 输出格式 [root@zhujipeng /]# ifconfig eth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:02 inet addr:172.17.0.2 Bcast:0.0.0.0 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:24 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:1704 (1.6 KiB) TX bytes:0 (0.0 b) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:0 (0.0 b) TX bytes:0 (0.0 b) 每行的含义 Link - 连接信息 inet - 网络信息 网卡状态标识 RX - 接收数据包情况统计 TX - 发送数据包情况统计 网络信号冲突和传输缓冲区信息 接收、发送数据字节数统计信息 字段 说明 eth0 表示第一块网卡 lo 表示主机的回环地址 encap 网络类型（encapsulation） HWaddr 物理网卡的地址（hardware address） addr 网络地址（address） Bcast 广播地址（broadcast） Mask 网络掩码 UP 启用 BROADCAST 广播 MULTICAST 多播 RUNNING 运行中 MTU 最大传输单元 Metric 路由度量值，缺省值是0 collisions 网络信号冲突的情况 txqueuelen 传输缓冲区Metric大小 lsof 查看所有打开的文件，也可查看网络的信息，详情参考这里 linux下一切皆文件，网络也用文件表示 显示连接信息 显示所有连接 lsof -i 仅获取IPv6流量 lsof -i 6 仅显示TCP/UDP连接 lsof -iTCP lsof -iUDP 显示指定端口的连接 lsof -i:22 lsof -i :22 显示指定主机的连接 lsof -i@172.16.12.5 显示指定主机和端口的连接 lsof -i@172.16.12.5:22 显示监听端口 lsof -i -sTCP:LISTEN lsof -i | grep -i LISTEN hostname 显示和设置主机名 hostname [选项] [主机名] 选项 说明 -a, --alias 显示主机别名 -A, --all-fqdns 显示完全限定名FQDN（Fully Qualified Domain Name）和主机名 --d, --domain 显示域名部分 -f, --fqdn, --long 显示完全限定名FQDN（Fully Qualified Domain Name） -i, --ip-address 显示主机对应的ip -I, --all-ip-addresses 显示主机对应的所有ip -s, --short 显示主机名在第一个点号前面的部分 关于如何修改主机名请参考这里，FQDN的知识参考这里 nslookup 查询DNS，详情参考这里 dig 查询DNS，详情参考这里 arp 操作主机的arp缓冲区，详情参考这里 ip ip命令和ifconfig类似，但功能更强大，详情参考这里 参考 每天一个linux命令 ping命令配置Linux禁止ping和请允许pingLinux禁止ping以及开启ping的方法每天一个linux命令 telnet命令linux下怎么退出telnetCentos 开启telnet-service服务每天一个linux命令 ifconfig命令Linux 命令神器：lsof 入门hostname命令深入理解Linux修改hostnameFQDN 是什么Linux设置FQDNnslookup命令linux下DNS解析（nslookup、dig、host）Linux命令：使用dig命令解析域名域名解析中A记录、CNAME、MX记录、NS记录的区别和联系常用域名记录解释arp命令试试Linux下的ip命令，ifconfig已经过时了 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/wang-luo-gao-ji-ming-ling.html":{"url":"senior-chapter/network-about/wang-luo-gao-ji-ming-ling.html","title":"网络高级命令","keywords":"","body":"netstatss(socket statistics)tcpdump参考netstat 查看系统的网络连接信息 netstat [address_family_options] [--tcp|-t] [--udp|-u] [--udplite|-U] [--raw|-w] [--listening|-l] [--all|-a] [--numeric|-n] [--numeric-hosts] [--numeric-ports] [--numeric-users] [--symbolic|-N] [--extend|-e[--extend|-e]] [--timers|-o] [--program|-p] [--verbose|-v] [--continuous|-c] [--wide|-W] [delay] netstat {--route|-r} [address_family_options] [--extend|-e[--extend|-e]] [--verbose|-v] [--numeric|-n] [--numeric-hosts] [--numeric-ports] [--numeric-users] [--continuous|-c] [delay] netstat {--interfaces|-I|-i} [--all|-a] [--extend|-e] [--verbose|-v] [--program|-p] [--numeric|-n] [--numeric-hosts] [--numeric-ports] [--numeric-users] [--continuous|-c] [delay] netstat {--groups|-g} [--numeric|-n] [--numeric-hosts] [--numeric-ports] [--numeric-users] [--continu‐ ous|-c] [delay] netstat {--masquerade|-M} [--extend|-e] [--numeric|-n] [--numeric-hosts] [--numeric-ports] [--numeric-users] [--continuous|-c] [delay] netstat {--statistics|-s} [--tcp|-t] [--udp|-u] [--udplite|-U] [--raw|-w] [delay] netstat {--version|-V} netstat {--help|-h} address_family_options: [-4|--inet] [-6|--inet6] [--protocol={inet,inet6,unix,ipx,ax25,netrom,ddp, ... } ] [--unix|-x] [--inet|--ip|--tcpip] [--ax25] [--x25] [--rose] [--ash] [--ipx] [--netrom] [--ddp|--appletalk] [--econet|--ec] 选项 说明 --route , -r 显示路由表 --interfaces=iface , -I=iface , -i 指定网络接口 --masquerade , -M 显示伪装的连接 --statistics , -s 显示统计信息 --verbose , -v 显示更加详细的信息 --wide , -W 显示ip的所有部分 --numeric , -n 显示数字而不是名称 --numeric-hosts 主机部分显示为ip --numeric-ports 端口部分显示为数字 --numeric-users 用户部分显示用户id --protocol=family , -A 指定协议族 -c, --continuous 持续性的输出信息 -e, --extend 输出额外的信息 -p, --program 显示进程id -l, --listening 只显示监听的网络 -a, --all 显示所有的连接 -t 显示tcp连接协议的 -u 显示udp连接协议的 ss(socket statistics) 查看系统的网络连接信息 ss [options] [ FILTER ] 选项 说明 -n, --numeric 显示数字而不是名称 -r, --resolve 解析数字为名称 -a, --all 显示所有的套接字 -l, --listening 显示监听的套接字（默认不显示） -o, --options 显示时间信息 -e, --extended 显示额外的信息 -m, --memory 显示内存使用 -p, --processes 显示进程信息 -i, --info 显示内部Tcp信息 -s, --summary 显示统计信息 -4, --ipv4 显示ipv4的套接字 -6, --ipv6 显示ipv6的套接字 -t, --tcp 显示tcp的套接字 -u, --udp 显示udp的套接字 -x, --unix 显示Unix domain的套接字 -f FAMILY, --family=FAMILY 指定协议族 FILTER := [ state STATE-FILTER ] [ EXPRESSION ] 状态 说明 listen 参考三次握手的状态 syn-sent 参考三次握手的状态 syn-recv 参考三次握手的状态 established 参考三次握手的状态 fin-wait-1 参考三次握手的状态 fin-wait-2 参考三次握手的状态 last-ack 参考三次握手的状态 time-wait 参考三次握手的状态 close-wait 参考三次握手的状态 closing 参考三次握手的状态 closed 参考三次握手的状态 all 所有的状态 connected 除了listen和closed的状态 synchronized 除了syn-sent的connected状态 表达式部分请参考文档末尾的链接 tcpdump 抓取网络上的数据包 tcpdump [ -AbdDefhHIJKlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ] [ -C file_size ] [ -G rotate_seconds ] [ -F file ] [ -i interface ] [ -j tstamp_type ] [ -m module ] [ -M secret ] [ -P in|out|inout ] [ -r file ] [ -V file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -E spi@ipaddr algo:secret,... ] [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ] [ expression ] 选项 说明 -A 使用ASCII码输出 -B 指定buffer大小，单位为KB -c 达到指定大小的包后退出 -D 显示可以监听的网络接口 -i 指定监听的网络接口 -n 显示ip而不是主机名 -nn 显示主机，协议和端口的数字而不是名称 -N 不显示域名部分 -v 显示详细的输出 -vv 显示详细的输出 -vvv 显示详细的输出 -S 输出Tcp序列号的绝对值而不是相对值 -x 显示头信息 -xx 显示头信息 -X 用16进制和ASCII码显示头信息 -XX 用16进制和ASCII码显示头信息 想要监听发送到本地端口的数据包需要指定-i lo0 表达式部分请参考文档末尾的链接 参考 每天一个linux命令 netstat命令每天一个linux命令 ss命令netstat命令netstat 的10个基本用法Linux tcpdump命令详解tcpdump命令tcpdump使用技巧tcpdump不能抓本机程序向本机端口发送的包吗 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/wang-luo-qing-qiu-ming-ling.html":{"url":"senior-chapter/network-about/wang-luo-qing-qiu-ming-ling.html","title":"网络请求命令","keywords":"","body":"curlURL说明选项说明普通选项参数选项加密选项认证选项代理选项文件选项调试选项参考curl 模拟网络请求和传输 curl [options] [URL...] URL说明 url 支持 glob 通配符的形式 http://site.{one,two,three}.com ftp://ftp.numericals.com/file[1-100].txt ftp://ftp.numericals.com/file[001-100].txt ftp://ftp.letters.com/file[a-z].txt http://www.numericals.com/file[1-100:10].txt http://www.letters.com/file[a-z:2].txt 选项说明 普通选项 选项 说明 -#, --progress-bar 显示一个简单的进度条来代替标准的输出 -0, --http1.0 使用 HTTP 1.0 -4, --ipv4 只解析 ipv4 -6, --ipv6 只解析 ipv6 -b, --cookie 指定Cookie键值或文件（只有name部分时） -c, --cookie-jar 保存返回结果的Cookie到指定的文件 --compressed 指定返回结果是解压后的 --connect-timeout 指定连接超时，重复指定时最后一个生效 -D, --dump-header 保存返回结果的请求头 -f, --fail 忽略服务器导致的错误 -i, --include 在输出结果中显示头信息 -I, --head 只请求HTTP头信息 --interface 指定网络接口 -j, --junk-session-cookies 从文件读取Cookie时忽略会话Cookie --keepalive-time 指定发送keepalive的时间间隔 --limit-rate 限制传输速率 --local-port 指定请求时本地使用的端口 -m, --max-time 指定整个操作的超时时间 --no-keepalive 不使用keepalive --raw 显示返回结果未解码的内容 -s 不显示进度条和错误信息 -S 和 -s 一起显示错误信息 --tcp-nodelay 使用TCP_NODELAY选项 -w, --write-out 指定输出格式 keepalive 详情参考这里 tcp-nodelay 详情参考这里 参数选项 选项 说明 -A, --user-agen 设置用户代理标识 -B, --use-ascii 使用ASCII编码传输 -d, --data HTTP POST 方式指定请求参数，和 --data-ascii 一样 --data-ascii 使用ascii的方式传递请求参数 --data-binary 　 使用二进制的方式传递请求参数 --data-urlencode 对请求参数进行url编码 -e, --referer URL 指定请求来源url -F, --form HTTP FORM 方式指定请求参数 --form-string 和 --form，只是' @ '、' -g, --globoff 关闭url部分的glob解析 -G, --get 使得-d类参数变为Get请求的参数，重复指定时第一个生效 -H, --header 指定HTTP头信息 --ignore-content-length 忽略 Content-Length 头信息 -K, --config 指定读取请求参数的配置文件 -X, --request 指定请求方法类型 用户代理标识 详情参考这里 浏览器的编码 详情参考这里 http post -d 的 Content-Type 为 application/x-www-form-urlencoded -F 的 Content-Type 为 multipart/form-data -F 支持使用分号分割多个参数，值的@前缀代表上传文件 POST提交数据方式请参考这里 http header 详情参考这里 http method 详情参考这里 加密选项 选项 说明 -1, --tlsv1 使用 TLS 1 --tlsv1.0 使用 TLS 1.0 --tlsv1.1 使用 TLS 1.1 --tlsv1.2 使用 TLS 1.2 -2, --sslv2 使用 SSL 2 -3, --sslv3 使用 SSL 3 --ciphers 指定SSL通信使用的密钥 -E, --cert 指定SSL证书文件和密码 --cert-type > 指定SSL证书文件类型 (DER/PEM/ENG) --cacert 指定CA证书 --capath 指定CA证书目录 -k, --insecure 允许不使用证书访问SSL站点 --key 指定SSL私钥文件 --key-type 指定SSL私钥文件类型(DER/PEM/ENG) --pass 指定SSL私钥文件的密码 TLS和SSL 详情参考这里 认证选项 选项 说明 -anyauth 由curl来决定最好的身份验证方式 --basic 使用 HTTP basic 验证身份 --digest 使用 HTTP digest 验证身份 -u, --user 指定认证使用的用户名和密码 --krb FTP指定Kerberos认证级别 http认证 详情参考这里 Kerberos认证 详情参考这里 代理选项 选项 说明 --noproxy 指定访问不需要使用代理的主机列表 --proxy-anyauth 在代理中由curl来决定最好的身份验证方式 --proxy-basic 在代理中使用 HTTP basic 验证身份 --proxy-digest 在代理中使用 HTTP digest 验证身份 -U, --proxy-user 指定代理使用的用户名和密码 --socks4 使用socks4代理 --socks5 使用socks5代理 http代理 详情参考这里 socks代理 详情参考这里 文件选项 选项 说明 -a, --append (FTP/SFTP)上传文件时使用追加模式 -C, --continue-at 指定断点续传位置 --create-dirs 保存下载时创建不存在的目录 --crlf 上传时将 LF（换行） 转换为CRLF（回车换行） -J, --remote-header-name 保存下载时使用Content-Disposition头来决定文件名 -o, --output 将结果保存到指定的文件中 -O, --remote-name 将结果保存到指定的文件中 -l, --list-only FTP只列出文件和目录 调试选项 选项 说明 --trace 记录所有的输入输出数据 --trace-ascii 记录所有的输入输出数据的ASCII部分 --trace-time 在记录中显示时间 参考 Linux curl命令详解curl网站开发指南HTTP Keep-Alive是什么？TCP_NODELAY 和 TCP_NOPUSH的解释总结整理时下流行的浏览器User-Agent大全说说http协议中的编码和解码四种常见的 POST 提交数据方式HTTP头部详解HTTP的请求方法TLS和SSL详解SSL与TLS的区别以及介绍WEB 中的认证方式Kerberos认证流程详解什么是代理服务器http请求细节和代理HttpTunnel技术介绍tcp和udp包穿透防火墙-HttptunnelShadowsocks原理和搭建SOCKS5代理原理探索 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/wang-luo-jiao-hu-ming-ling.html":{"url":"senior-chapter/network-about/wang-luo-jiao-hu-ming-ling.html","title":"网络交互命令","keywords":"","body":"nc(ncat)选项说明协议选项连接选项监听选项加密选项代理选项参考nc(ncat) 读取或发送网络数据 nc [options] [hostname] [port] 选项说明 协议选项 选项 说明 -4 指定使用IPv4 -6 指定使用IPv6 -U, --unixsock 使用Unix domain sockets -u, --udp 使用udp 连接选项 选项 说明 -p port, --source-port port 指定连接时使用的本地端口 -s host, --source host 指定连接时使用的本地IP 监听选项 选项 说明 -l, --listen 在本地监听连接 -k, --keep-open 客户端关闭连接时也保持监听 加密选项 选项 说明 --ssl 使用ssl（连接模式） --ssl-verify 同时校验服务端（客户端模式） --ssl-cert certfile.pem 指定ssl证书 --ssl-key keyfile.pem 指定ssl密钥 --ssl-trustfile 指定信任证书列表 代理选项 选项 说明 --proxy host[:port] 指定代理主机和端口 --proxy-type proto 指定代理协议 --proxy-auth user[:pass] 指定代理用户名和密码 更多的选项请参考 nc 的 man 手册 参考 nc/netcat命令 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/wang-luo-lu-you-ming-ling.html":{"url":"senior-chapter/network-about/wang-luo-lu-you-ming-ling.html","title":"网络路由命令","keywords":"","body":"routelinux的route查看路由示例mac的路由查看路由示例windows的路由参考route 查看和操作网络的路由信息 linux的route route [-CFvnNee] [-A family |-4|-6] route [-v] [-A family |-4|-6] add [-net|-host] target [netmask Nm] [gw Gw] [metric N] [mss M] [window W] [irtt I] [reject] [mod] [dyn] [reinstate] [[dev] If] route [-v] [-A family |-4|-6] del [-net|-host] target [gw Gw] [netmask Nm] [metric N [[dev] If] route [-V] [--version] [-h] [--help] 选项 说明 -A family 指定协议族 -n 显示ip而不是主机名 -e 使用 netstat 的格式显示 del 删除路由表项 add 添加路由表项 target 目的地址 -net 目的地址是一个网络 -host 目的地址是一个主机 netmask NM 指定子网掩码（目的地址是网络时） gw GW 指定网关地址 mss M 指定最大传输单元MTU (Maximum Transmission Unit) window W 指定TCP窗口大小 irtt 设置初始的RTT（round trip time） dev 指定网络设备 查看路由 [root@zhujipeng ~]# route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default gateway 0.0.0.0 UG 0 0 0 eth1 10.0.0.0 172.16.0.1 255.0.0.0 UG 0 0 0 eth0 101.236.56.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1 link-local 0.0.0.0 255.255.0.0 U 1002 0 0 eth0 link-local 0.0.0.0 255.255.0.0 U 1003 0 0 eth1 169.254.169.254 gateway 255.255.255.255 UGH 0 0 0 eth1 172.16.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0 172.16.0.0 172.16.0.1 255.240.0.0 UG 0 0 0 eth0 198.18.0.0 172.16.0.1 255.254.0.0 UG 0 0 0 eth0 [root@zhujipeng ~]# netstat -nr Kernel IP routing table Destination Gateway Genmask Flags MSS Window irtt Iface 0.0.0.0 101.236.56.1 0.0.0.0 UG 0 0 0 eth1 10.0.0.0 172.16.0.1 255.0.0.0 UG 0 0 0 eth0 101.236.56.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1 169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0 169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth1 169.254.169.254 101.236.56.1 255.255.255.255 UGH 0 0 0 eth1 172.16.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0 172.16.0.0 172.16.0.1 255.240.0.0 UG 0 0 0 eth0 198.18.0.0 172.16.0.1 255.254.0.0 UG 0 0 0 eth0 输出格式详解 字段 说明 Destination 目的地址 Gateway 网关地址 Genmask 网络掩码 Flags 路由标识 Metric 路由距离 Ref 路由表项引用的次数 Use 被路由软件查找的次数 Iface 网络接口 MSS 最大报文段长度 Window TCP窗口大小 路由标志详解 标志 说明 U 路由是活动的 H 目的地址是一个主机 N 目的地址是一个网络 G 目的地址是一个网关 R 恢复动态路由产生的表项 D 由路由的后台程序动态地安装 M 由路由的后台程序修改 示例 添加主机路由 route add -host 10.1.0.1 dev eth0 route add -host 10.1.0.1 gw 10.2.1.128 添加网络路由 route add -net 10.1.0.0 netmask 255.255.0.0 eth0 route add -net 10.1.0.0 netmask 255.255.0.0 gw 10.2.1.128 route add -net 10.1.0.0/16 eth1 添加默认路由 route add default gw 10.2.1.128 删除主机路由 route del -host 10.1.0.1 dev eth0 route del -host 10.1.0.1 gw 10.2.1.128 删除网络路由 route del -net 10.1.0.0 netmask 255.255.0.0 eth0 route del -net 10.1.0.0 netmask 255.255.0.0 gw 10.2.1.128 route del -net 10.1.0.0/16 eth1 删除默认路由 route del default gw 10.2.1.128 mac的路由 route [-dnqtv] command [[modifiers] args] route add [ host | network ] %s: gateway %s flags %x route delete [ host | network ] %s: gateway %s flags %x 选项 说明 -d 使用调试模式，不实际修改 -t 使用测试模式 -v 输出详细信息 -q 禁止所有输出 命令 说明 add 添加路由 flush 清空路由 delete 删除指定路由 change 改变路由规则 get 显示路由规则 monitor 监视路由变化 查看路由 ➜ Downloads netstat -nr Routing tables Internet: Destination Gateway Flags Refs Use Netif Expire default 192.168.9.254 UGSc 20 0 en0 127 127.0.0.1 UCS 0 0 lo0 127.0.0.1 127.0.0.1 UH 38 11175096 lo0 169.254 link#4 UCS 0 0 en0 192.168.8/23 link#4 UCS 6 0 en0 192.168.8.68 b4:b:44:b5:ff:1b UHLWI 0 2 en0 192.168.8.79 f4:f:24:3f:c9:ad UHLWI 0 0 en0 675 192.168.8.192/32 link#4 UCS 0 0 en0 192.168.8.206 34:36:3b:c8:90:3e UHLWI 0 18 en0 1144 192.168.8.254 c:d6:bd:47:27:be UHLWI 0 0 en0 239 192.168.9.23 50:68:a:d1:80:38 UHLWI 0 0 en0 293 192.168.9.254/32 link#4 UCS 1 0 en0 192.168.9.254 3c:8c:40:2:f:4c UHLWIir 22 24 en0 1162 Internet6: Destination Gateway Flags Netif Expire ::1 ::1 UHL lo0 fe80::%lo0/64 fe80::1%lo0 UcI lo0 fe80::1%lo0 link#1 UHLI lo0 fe80::%en0/64 link#4 UCI en0 fe80::3636:3bff:fec6:4144%en0 34:36:3b:c6:41:44 UHLI lo0 fe80::%awdl0/64 link#9 UCI awdl0 fe80::50b8:92ff:fe08:7c3b%awdl0 52:b8:92:8:7c:3b UHLI lo0 ff01::%lo0/32 ::1 UmCI lo0 ff01::%en0/32 link#4 UmCI en0 ff01::%awdl0/32 link#9 UmCI awdl0 ff02::%lo0/32 ::1 UmCI lo0 ff02::%en0/32 link#4 UmCI en0 ff02::%awdl0/32 link#9 UmCI awdl0 示例 添加主机路由 route add 10.1.0.1 10.2.1.128 route add -host 10.1.0.1 10.2.1.128 添加网络路由 route add -net 10.1.0.0 10.2.1.128 255.255.0.0 route add -net 10.1.0.0/16 10.2.1.128 添加默认路由 route add default 10.2.1.128 删除主机路由 route delete 10.1.0.1 10.2.1.128 route delete -host 10.1.0.1 10.2.1.128 删除网络路由 route delete -net 10.1.0.0 10.2.1.128 255.255.0.0 route delete -net 10.1.0.0/16 10.2.1.128 删除默认路由 route delete default 10.2.1.128 windows的路由 详情参见这里 参考 route route命令traceroute命令linux 多网卡路由问题mac osx修改mac地址和管理路由表的方法windows route 命令详解关于个人对TCP/IP协议簇的理解 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/wang-luo-ji-chu-zhi-shi.html":{"url":"senior-chapter/network-about/wang-luo-ji-chu-zhi-shi.html","title":"网络基础知识","keywords":"","body":"网络简介网络知识网络原理网络编程网络传输参考网络简介 网络看似是非常简单的，利用工具可以查看相关的信息，各大编程语言也提供丰富的接口，但是网络的细节其实是相当复杂的，要想熟练掌握网络相关的知识，需要阅读许多相关的书籍和丰富网络经验 -《计算机网络原理》 -《通信原理》 -《TCP/IP详解卷1》 -《TCP/IP详解卷2》 -《TCP/IP详解卷3》 -《UNIX网络编程 卷1》 -《UNIX网络编程 卷2》 -《UNIX环境高级编程》 -《HTTP权威指南》 unp（Unix Network Programming）：UNIX网络编程 apue（Advanced Programming Unix Environment）：UNIX环境高级编程 知乎上有一个有趣的问题，为什么部分看起来不太复杂的网站，比如Facebook，需要大量顶尖高手来开发，我觉得很值得思考，详情参考这里 网络知识 网络学习需要掌握很多的基础知识，我所了解的大致如下，通信方向的需要了解更多的知识 网络原理 网络体系结构 网络传输过程 网络拥塞机制 ip协议相关知识 tcp/udp相关知识 操作系统实现的细节 网络编程 socket相关知识 网络io相关知识 http相关知识 网络传输 数据传输过程 网络延时估算 网络通信原理 参考 为什么部分看起来不太复杂的网站，比如Facebook，需要大量顶尖高手来开发网络的各种时延初探网络性能测试 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/wang-luo-ti-xi-jie-gou.html":{"url":"senior-chapter/network-about/wang-luo-ti-xi-jie-gou.html","title":"网络体系结构","keywords":"","body":"体系结构网络协议网络模型OSI模型TCP/IP模型TCP/IP模型和OSI模型的对应关系各层的作用和协议网络分层的好处参考体系结构 计算机网络的各层及其协议的集合，称为网络的体系结构 网络协议 为进行网络中的数据交换而建立的规则、标准或约定称为网络协议 网络协议主要由以下三要素组成： 语法，即数据与控制信息的结构或格式 语义，即需要发出何种控制信息，完成何种动作以及做出何种相应 同步，即事件实现顺序的详细说明 网络协议的主要模型为以下两种： OSI模型（7层） TCP/IP模型（5层） 网络模型 OSI模型 OSI模型主要由7层组成 应用层（Application Layer） 表示层（Presentation Layer） 会话层（Session Layer） 传输层（Transport Layer） 网络层（Network Layer） 数据链路层（Data Link Layer） 物理层（Pyhsical Layer） 传输层也叫运输层，我个人觉得传输层比较顺口 TCP/IP模型 应用层 传输层 网络层 数据链路层 物理层 网络层也叫网际层，数据链路层和物理层有时也合称为网络接口层 TCP/IP模型和OSI模型的对应关系 应用层对应OSI模型的应用层、表示层、会话层 传输层对应OSI模型的传输层 网际层对应OSI模型的网络层 网络接口层对应OSI模型的数据链路层、物理层 各层的作用和协议 应用层 解决进程之间的消息传递 协议或应用 说明 FTP（21) 文件传输协议（File Transfer Protocol） SSH （22） 远程会话协议（Secure Shell） SMTP（25） 简单邮件协议（Simple Mail Transfer Protocol） DNS（53） 域名解析系统（Domain Name System） DHCP（68） 动态主机配置协议（Dynamic Host Configuration Protocol） TFTP（69） 简单文件传输协议（Trivial File Transfer Protocol） HTTP（80） 超文本传输协议（HyperText Transfer Protocol） POP3（110） 邮局管理协议（Post Office Protocol 3） SFTP（115） 安全文件传送协议（Secure File Transfer Protocol） IMAP4（143） 邮件访问协议（Internet Message Access Protocol 4） SNMP（161） 简单网络管理协议（Simple Network Management Protocol） LDAP（389） 轻型目录访问协议（Lightweight Directory Access Protocol） HTTPS（443） 加密的超文本传输协议（Hyper Text Transfer Protocol over Secure Socket Layer） 传输层 解决主机之间的消息传递 协议或应用 说明 TCP 传输控制协议（Transmission Control Protocol） UDP 用户数据报协议（User Datagram Protocol） 网络层 解决主机之间的发现识别 协议或应用 说明 IP 网络互联协议（Internet Protocol） ICMP 网络控制报文协议（Internet Control Message Protocol） IGMP 网络组组管理协议（Internet Group Management Protocol） IGP 内部网关协议（Interior Gateway Protocol） RIP 路由信息协议（Routing Information Protocol） OSFP 开放式最短路径优先（Open Shortest Path First） BGP 边界网关协议（Border Gateway Protocol） 数据链路层 解决网络传输相关的问题 协议或应用 说明 ARP 地址解析协议（Address Resolution Protocol） RARP 逆地址解析协议（Reverse Address Resolution Protocol） SLIP 串行线路网际协议（Serial Line Internet Protocol） CSLIP 压缩的串行线路网际协议（Compressed Serial Line Internet Protocol） PPP 点对点协议（Point to Point Protocol） 物理层 解决比特流的传输和电平信号等问题 网络分层的好处 功能分工：分层之后各层逻辑清晰以便实现、维护和问题排查 服务复用：避免上一层的每一种协议都得去实现下一层的功能 统一透明：上层不用关心下层是如何实现的和不同实现的细节 参考 计算机网络体系结构详解（图文）计算机网络之路由协议详解OSI网络体系结构TCP/UDP 常用端口列表FTP主动模式和被动模式的比较SMTP、IMAP和POP3的区别和联系DHCP协议详解SNMP原理与实战详解ldap介绍DHCP原理及配置ICMP协议详解DHCP协议详解 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/wang-luo-chuan-shu-guo-cheng.html":{"url":"senior-chapter/network-about/wang-luo-chuan-shu-guo-cheng.html","title":"网络传输过程","keywords":"","body":"数据包传输过程发送过程接收过程名词介绍TCP传输三次握手客户端状态变化服务端状态变化为什么需要三次握手四次挥手主机1状态变化主机2状态变化为什么需要四次挥手为什么连接需要三次握手而释放需要四次握手为什么需要等2MSLTIME_WAIT和CLOSE_WAIT分片机制MTUIP分片TCP分片UDP分片窗口机制拥塞机制失败重传信息校验UDP传输消息边界UDP缓冲参考数据包传输过程 发送过程 程序的数据（Data）通过Socket调用从应用层发送到传输层 TCP传输时，传输层为数据添加TCP头信息形成数据段（Segment），并发送到网络层 UDP传输时，传输层为数据添加UDP头信息形成数据报（Datagram），并发送到网络层 网络层为数据段或数据报添加IP头信息形成数据包（Packet），并发送到数据链路层 数据链路层为数据包添加Frame头信息形成数据帧（Frame），并发送到物理层 物理层负责将数据帧转化为比特流（Bit Stream），并发送出去 接收过程 物理层负责将接收到的比特流（Bit Stream）化为数据帧转，并发送到数据链路层 数据链路层去掉数据帧（Frame）中的Frame头信息形成数据包，并发送到网络层 网络层去掉数据包（Packet）中的IP头信息形成数据段或数据报，并发送到传输层 TCP传输时，传输层去掉数据段（Segment）中的TCP头信息，并返回给应用层 UDP传输时，传输层去掉数据报（Datagram）中的UDP头信息，并返回给应用层 程序通过Socket调用从应用层获得需要的数据（Data） 整个过程大致是这样的，但是每一层的处理都隐含了非常多的细节 名词介绍 缩写 翻译 名词 PDU （Protocol Data Unit）协议数据单元 PDU是发送机器上每层发送到接收机器上相应层的信息的称呼 SDU （Service Data Unit）服务数据单元 SDU是在同一机器上的两层之间传送的信息的称呼 Message 报文 应用层数据的称呼 Segment 数据段 TCP传输时传输层数据的称呼 Datagram 数据报 UDP传输时传输层数据的称呼 Packet 数据包 网络层数据的称呼 Frame 数据帧 数据链路层的数据的称呼 MTU （Maximum Transmission Unit）最大传输单元 数据链路层的最大传输单元（不包含头信息） MSS （Maximum Segment Size） 最大传输段大小 TCP提交给IP层最大分段大小 TCP传输 tcp是面向连接的流式传输协议，具有以下特点 面向连接：通信双方都需要建立连接和释放链接 传输可靠：能够保证数据的完整性、顺序性、正确性 流量可控：通过滑动窗口和拥塞机制来进行流量的控制 三次握手 三次握手是指TCP建立连接的过程 通常发送请求的一方称为客户端，响应请求的一方称为服务端 第一次握手 客户端A获得服务端B的地址后 向服务端B发送连接信息，SYN=1，seq=x（x为随机产生的值） 然后客户端A进入SYN_SEND状态 第二次握手 服务端B收到客户端A的连接请求，确认SYN=1后 向客户端A发送确认信息，SYN=1，ACK=1，ack=x+1，seq=y（y为随机产生的值） 然后服务端B从LISTEN状态进入到SYN_RCVD状态 第三次握手： 客户端A收到服务端B的确认消息，确认ACK=1后 检查ack是否是第一次握手是发送的seq的值加1 验证通过则向B发送确认信息，ACK=1，ack=y+1，seq=x+1 然后客户端A从SYN_SEND状态进入到ESTABLISHED状态 服务端B收到客户端A的确认信息，确认ACK=1后 检查ack是否是第二次握手是发送的seq的值加1 验证通过则从SYN_RCVD状态进入到ESTABLISHED状态 三次握手中的任何一次没有成功，都要重新发送 客户端状态变化 None-> SYN_SEND -> ESTABLISHED 服务端状态变化 LISTEN-> SYN_RCVD -> ESTABLISHED 为什么需要三次握手 在连接时可能会出现这样的情况，客户端发送了连接请求，但是该信息在某个网络节点滞留时间过长，客户端已经连接超时释放了该连接后，该连接请求到达服务端后 该信息其实是一个过时失效的信息，所以当服务端收到信息后，以为客户端需要建立连接，于是服务端会向客户端发送确认信息 如果不进行第三次握手，就会出现服务端认为是连接并且建立连接，等待客户端发送数据，但是客户端并没有要求建立连接，是不会向服务端发送数据的，所以服务端就会白白的等待客户端发送数据，这样就浪费了服务端的资源 四次挥手 四次挥手是指TCP释放连接的过程 第一次挥手 主机1向主机2发起释放连接请求 发送释放请求信息，FIN=1，seq=u 然后主机1从ESTABLISHED状态进入到FIN_WAIT_1状态 第二次挥手 主机2收到主机1的释放连接请求后 回复确认信息，ACK=1，ack=u+1 然后主机2从ESTABLISHED状态进入到CLOSE_WAIT状态 主机1收到主机2的确认信息后 从FIN_WAIT_1状态进入到FIN_WAIT_2状态 第三次挥手 主机2向主机1发起释放连接请求 发送释放请求信息，FIN=1，seq=v 然后主机2从CLOSE_WAIT状态进入到LAST_ACK状态 第四次挥手 主机1收到主机2的释放连接请求后 回复确认信息，ACK=1，ack=v+1 然后主机1从FIN_WAIT_2状态进入到TIME_WAIT状态 主机2收到主机1的确认信息后 从LAST_ACK状态进入到CLOSED状态 主机1经过2MSL(最大报文生存时间)后从TIME_WAIT状态进入到CLOSED状态 主机1状态变化 ESTABLISHED-> FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT -> CLOSED 主机2状态变化 ESTABLISHED-> CLOSE_WAIT -> LAST_ACK -> CLOSED 为什么需要四次挥手 第一次挥手 主机1告诉主机2，我没有数据需要发送了或数据已全部发送完毕 但是此时主机1还可以接收主机2发送的消息 第二次挥手 主机2回复确认信息，此时主机2知道主机1没有数据发送了 但是主机2可能还有数据需要发送 第三次挥手 主机2告诉主机1，我也没有数据需要发送了或数据已全部发送完毕 此时主机1和主机2都没有数据发送 第四次挥手 主机1回复确认信息，主机1知道了主机2也没有数据发送了 但是主机1需要等待2MSL(最大报文生存时间)后才能释放连接 为什么连接需要三次握手而释放需要四次握手 第二次挥手时主机2可能还有数据要发送给，所以不能回复释放连接信息，只能回复确认信息 建立连接的时候服务端收到建立连接的SYN请求后，将ACK和SYN放在一个报文里发送给客户端了。而释放的时候，当收到对方的FIN报文的时候，仅仅表示对方不在发送数据了，但是还可以接收数据，而己方可能还有数据发送，所以己方可以立即close连接或者发送一些数据给对方后再发送FIN报文给对方，表示可以释放连接，所以释放的时候ACK和FIN是分开发送的，所以需要四次挥手 为什么需要等2MSL 保证TCP的双全工连接能够可靠关闭 如果直接进入CLOSE状态，由于IP协议的不可靠性或者因为网络原因，主机2没有收到主机1最后回复的ACK，在超时后主机2会继续发送FIN，因为主机1已经没有了与之相对应的连接，最后主机2就会收到RST而不是ACK，主机2会将问题报告给上层处理。虽然这样不会造成数据的丢失，但是这不符合TCP的可靠性要求，所以需要等待，此时主机1进入TIME_WAIT状态，当再次收到FIN的时候，确保主机2能够收到ACK，最后正常的关闭连接 保证这个连接的重复数据在网络中消失 如果直接进入了CLOSE状态，然后有向服务端发送新的连接请求。因为不能保证两次连接请求的端口是否一样。如果出现特殊情况，两次端口都一样，旧的连接数据还存在网络中，新的连接建立后，就连接的数据到达服务端，服务端会将其视为新连接传输的数据，这就导致新旧连接的数据混淆了。所以需要等待2MSL的时间，这样才能保证数据从网络中消失 TIME_WAIT和CLOSE_WAIT TIME_WAIT TIME_WAIT是主动关闭连接的一方保持的状态 服务器保持大量TIME_WAIT状态，这种情况比较常见 一些爬虫服务器，没有做内核优化的话经常会遇到这个问题 爬虫服务器本质上就是一个客户端，任务后会主动的关闭连接 CLOSE_WAIT CLOSE_WAIT是被动关闭连接的一方保持的状态 是对方主动关闭连接后服务器没有发出FIN信号导致的 应该是程序没有检测对方的关闭请求到或者忘记了关闭连接 这种情况无法通过调节内核参数解决，只能查代码然后关闭连接 举例说明 服务器A是一台爬虫服务器 它使用简单的HttpClient去请求资源服务器B上面的apache获取文件资源 正常情况下如果请求成功，那么在抓取完资源后服务器A会主动发出关闭连接的请求 这个时候就是主动关闭连接，服务器A的连接状态就是TIME_WAIT 如果一旦发生异常呢 ？ 假设请求的资源服务器B上并不存在 那么这个时候就会由服务器B发出关闭连接的请求，服务器A就是被动的关闭了连接 如果程序员忘了让HttpClient释放连接，那就会造成CLOSE_WAIT的状态了 分片机制 MTU 在以太网上，由于电气限制，一帧不能超过1518字节，除去以太网帧头14字节（mac地址等）和帧尾4字节校验，还剩1500字节，这个大小称为MTU（最大传输单元） 而1492的MTU值的来源，是因为PPPoE协议（TCP/IP以太网无此功能） PPPoE协议是宽带运营商用于对用户认证计费而设计的 PPPoE头尾一共8字节，所以有效载荷实际为1492 IP分片 如果你的IP包大于1500字节，IP层就会分片了，详见这里 TCP分片 MSS是TCP每次能够传输的最大数据分段，不能超过1460（1500 - 20 - 20），如果数据段大于MSS就会进行TCP分片，所以TCP传输通常不会进行IP分片 TCP和IP的头信息都是20字节，详情参见这里 UDP分片 UDP不会分片，如果数据报大于1472（1500 - 20 - 8），就会进行IP分片，由于UDP是不可靠的传输协议，如果分片丢失就会导致重组失败和数据包被丢弃 UDP的头信息都是8字节，详情参见这里 窗口机制 详情参见这里 拥塞机制 详情参见这里 失败重传 详情参见这里 信息校验 详情参见这里 UDP传输 udp是面向无连接的报文传输协议，具有以下特点 面向无连接：通信双方不需要建立连接和释放链接 不可靠传输：只管将数据发送出去和尽最大努力交付数据 有大小限制：UDP协议规定UDP能够发送最大数据包是64K 消息边界 详情参见这里 UDP缓冲 详情参见这里 参考 细说OSI七层协议模型及OSI参考模型中的数据封装过程Socket与HTTP解析TCP、UDP、IP 协议分析数据帧frame，数据包packet，数据报datagram和数据段segmentTCP、UDP区别以及TCP传输原理、拥塞避免、连接建立、连接释放总结TCP分段与IP分片TCP粘包/拆包问题 TCP和UDP的\"保护消息边界\"TCP、UDP数据包大小的限制MTU、MSS、缓存区大小理解TCP序列号（Sequence Number）和确认号（Acknowledgment Number)TCP三次握手四次挥手详解TCP协议中的三次握手和四次挥手(图解)简析TCP的三次握手与四次分手处于CLOSE_WAIT和TIME_WAIT状态连接的原因及解决HTTP TCP UDP Socket 关系ip头、tcp头、udp头详解及定义计算机网络【七】：可靠传输的实现TCP错误恢复特性之一TCP重传TCP新手误区--数据校验的意义TCP的可靠性有多高UDP 和 TCP 的 socket 分别一般用在什么地方TCP与UDP的不同接包处理方式浅谈UDP(数据包长度，收包能力，丢包及进程结构选择) 告知你不为人知的UDP-疑难杂症和使用又见CLOSE_WAIT什么是TCP WindowIP数据报分片——Fragmentation和重组TCP 的那些事儿（上）TCP 的那些事儿（下）浅谈TCP/IP网络编程中socket的行为计算机网络信道复用技术 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/network-about/wang-luo-IP-di-zhi.html":{"url":"senior-chapter/network-about/wang-luo-IP-di-zhi.html","title":"网络IP地址","keywords":"","body":"IPIP地址类分类地址的缺点CIDR（Classless Inter-Domain Routing）私有IP广播地址MAC地址子网掩码NAT转换更多知识IP IP是32位二进制数据，通常以十进制表示，并以“.”分隔，用来标识网络中一个个主机 IP地址类 早期的IP是按网络号和主机号来划分的，把所有IP地址分为五类 类别 开始位 网络号 主机号 范围 主机个数 A 0 7 24 0.0.0.0 - 127.255.255.255 16777214(224 - 2) B 10 14 16 128.0.0.0 - 191.255.255.255 65534(216 - 2) C 110 21 8 192.0.0.0 - 223.255.255.255 254(28 - 2) 1 主机号全为0表示某网络的网络地址，全为1表示某网络的广播地址 类别 开始位 剩余位 剩余位说明 范围 D 1110 28 多播组号 224.0.0.0 - 239.255.255.255 E 11110 27 留待后用 240.0.0.0 - 255.255.255.255 分类地址的缺点 随着Internet的飞速发展，分类地址方案的局限性很快显现出 C类主机太少，大多数组织都申请B类网络地址，导致B类地址很快就分配完了 A类的网络位数较少，生成的网络地址不够用，主机地址却很，多造成了浪费 大量C类网络的出现，路由器需要检索的路由表越来越庞大，负担越来越重 CIDR（Classless Inter-Domain Routing） CIDR，无类别域间路由，是一种通过子网掩码来划分网络的技术 IP地址与子网掩码做与运算能够得到网络地址 私有IP 私有IP地址仅用于内部网络使用，不能通过公网访问 类别 范围 A 10.0.0.0 - 10.255.255.255 B 172.16.0.0 - 172.31.255.255 C 192.168.0.0 - 192.168.255.255 小的局域网通常都是192.168开头的，详情见这里 广播地址 详情参见这里 MAC地址 MAC地址，也称作硬件地址，烧录在NIC(网卡)之中，永远不会变 有了IP地址，为什么还要用MAC地址 IP地址是动态的，可以给任何一张网卡用，只有IP地址无法确定到主机 MAC地址是固定的，烧录到了网卡之中，永远不会变，可以确定到主机 IP地址用于表示同意逻辑上的目标，MAC地址则是标识物理上的目标 IP地址和MAC地址的关系类似于内存中的虚拟地址和物理地址关系 子网掩码 详情参见这里 NAT转换 详情参见这里 更多知识 更多的知识请参考末尾的链接 IP地址，子网掩码，默认网关，DNS服务器详解IP地址与路由单播、广播和多播IP地址子网掩码MAC地址表、ARP缓存表以及路由表IP地址和MAC地址的区别和联系是什么有了IP地址，为什么还要用MAC地址同一网段内的两台主机通信是否需要路由器内网和外网之间的通信为什么局域网的IP普遍是192.168开头UNIX网络编程socket绑定INADDR_ANY，那会怎样想了解下数据是如何分发到子进程的中继器、集线器(HUB)、网桥、交换机、路由器比较localhost、127.0.0.1 和 本机IP 三者的区别IP地址，子网掩码，子网划分看完后，搞懂ARP的工作原理，其实并不难MAC地址详解网络地址转换NAT原理及其作用 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/":{"url":"senior-chapter/system-about/","title":"系统相关","keywords":"","body":"本章是关于linux系统相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/kai-ji-qi-dong.html":{"url":"senior-chapter/system-about/kai-ji-qi-dong.html","title":"开机启动","keywords":"","body":"启动过程BIOS硬件自检启动顺序主引导记录主引导记录的结构分区表硬盘启动卷引导记录扩展分区和逻辑分区启动管理器操作系统参考启动过程 从打开电源到开始操作，计算机的启动是一个非常复杂的过程 第一阶段：BIOS 第二阶段：主引导记录 第三阶段：硬盘启动 第四阶段：操作系统 BIOS 上个世纪70年代初，\"只读内存\"（read-only memory，缩写为ROM）发明 开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它 这块芯片里的程序叫做\"基本输入输出系统\"，简称为BIOS 基本输入输出系统（Basic Input/Output System） 硬件自检 BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做\"硬件自检\"（Power-On Self-Test），缩写为POST 启动顺序 硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备，这种排序叫做\"启动顺序\"（Boot Sequence） 主引导记录 启动程序会读取启动设备的第一个扇区，也就是读取最前面的512个字节，这最前面的512个字节，就叫做\"主引导记录\"（Master boot record，缩写为MBR） 主引导记录的结构 第1-446字节：调用操作系统的机器码 第447-510字节：分区表（Partition table） 第511-512字节：主引导记录签名（0x55和0xAA） 分区表 考虑到每个区可以安装不同的操作系统，\"主引导记录\"因此必须知道将控制权转交给哪个区 分区表的长度只有64个字节，每个主分区的16个字节，所以只能有4个主分区 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。 第5个字节：主分区类型。 第6-8个字节：主分区最后一个扇区的物理位置。 第9-12字节：该主分区第一个扇区的逻辑地址。 第13-16字节：主分区的扇区总数。 硬盘启动 这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况 卷引导记录 四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做\"卷引导记录\"（Volume boot record，缩写为VBR） 扩展分区和逻辑分区 随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。 但是，分区表只有四项，因此规定有且仅有一个区可以被定义成\"扩展分区\"（Extended partition） 所谓\"扩展分区\"，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做\"逻辑分区\"（Logical partition） 计算机先读取扩展分区的第一个扇区，叫做\"扩展引导记录\"（Extended boot record，缩写为EBR） 启动管理器 在这种情况下，计算机读取\"主引导记录\"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的\"启动管理器\"（boot loader），由用户选择启动哪一个操作系统 操作系统 控制权转交给操作系统后，操作系统的内核首先被载入内存，然后是一系列初始化工作 操作系统的初始化流程参考Linux的启动流程 参考 计算机是如何启动的Linux的启动流程Linux守护进程详解(init.d和xinetd)Linux学习之/etc/init.d/functions详解linux下的initloglinux开机脚本示例 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/xi-tong-xin-xi.html":{"url":"senior-chapter/system-about/xi-tong-xin-xi.html","title":"系统信息","keywords":"","body":"相关命令unamelscpulsblklsscsilsmodlsb_release查看cpu查看物理CPU的个数查看每个CPU的核数查看逻辑CPU的个数查看CPU的型号查看CPU的频率查看内存参考相关命令 uname 显示系统内核相关信息 uname [OPTION]... 选项 说明 -a, --all 显示所有信息 -s, --kernel-name 显示内核名称 -n, --nodename 显示主机名 -r, --kernel-release 显示内核发行信息 -v, --kernel-version 显示内核版本 -m, --machine 显示机器名 -p, --processor 显示cpu -i, --hardware-platform 显示硬件平台 -o, --operating-system 显示操作系统 lscpu 查看cpu相关的信息 lsblk 查看块设备相关的信息 lsscsi 查看控制器相关的信息 lsmod 显示内核中的模块的状态信息 lsb_release 查看linux的发行版本信息 查看cpu 总核数 = 物理CPU个数 X 每颗物理CPU的核数 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数 查看物理CPU的个数 cat /proc/cpuinfo| grep \"physical id\"| sort -u | wc -l 查看每个CPU的核数 cat /proc/cpuinfo| grep \"cpu cores\"| uniq 查看逻辑CPU的个数 cat /proc/cpuinfo| grep \"processor\"| wc -l 查看CPU的型号 cat /proc/cpuinfo | grep name | cut -f2 -d: 查看CPU的频率 cat /proc/cpuinfo | grep MHz | cut -f2 -d: 查看内存 [root@localhost ~]# cat /proc/meminfo MemTotal: 1016232 kB MemFree: 762864 kB MemAvailable: 749112 kB Buffers: 2108 kB Cached: 101048 kB SwapCached: 0 kB Active: 104772 kB Inactive: 76760 kB Active(anon): 78672 kB Inactive(anon): 6408 kB Active(file): 26100 kB Inactive(file): 70352 kB Unevictable: 0 kB Mlocked: 0 kB SwapTotal: 2097148 kB SwapFree: 2097148 kB Dirty: 0 kB Writeback: 0 kB AnonPages: 78408 kB Mapped: 22852 kB Shmem: 6704 kB Slab: 41240 kB SReclaimable: 18988 kB SUnreclaim: 22252 kB KernelStack: 1584 kB PageTables: 3828 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 2605264 kB Committed_AS: 292864 kB VmallocTotal: 34359738367 kB VmallocUsed: 5944 kB VmallocChunk: 34359729728 kB HardwareCorrupted: 0 kB AnonHugePages: 12288 kB HugePages_Total: 0 HugePages_Free: 0 HugePages_Rsvd: 0 HugePages_Surp: 0 Hugepagesize: 2048 kB DirectMap4k: 57280 kB DirectMap2M: 991232 kB 参考 uname命令Linux下lshw,lsscsi,lscpu,lsusb,lsblk硬件查看命令 lsmod命令查看linux版本及lsb_release安装及一些想法Debian 拋弃 Linux 标准规范（LSB）Linux查看物理CPU个数、核数、逻辑CPU个数 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/xi-tong-ming-ling.html":{"url":"senior-chapter/system-about/xi-tong-ming-ling.html","title":"系统命令","keywords":"","body":"系统情况uptimewlast关机重启shutdownhaltpoweroffreboot参考系统情况 uptime 查看系统的运行时间和平均负载 [root@localhost ~]# uptime 08:10:40 up 5 min, 2 users, load average: 0.00, 0.03, 0.03 w 查看登录的用户和用户的活动 [root@localhost ~]# w 08:11:54 up 6 min, 2 users, load average: 0.00, 0.02, 0.03 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root tty1 08:05 6:34 0.01s 0.01s -bash root pts/0 192.168.8.192 08:07 2.00s 0.04s 0.03s w last 显示用户最近登录信息 last [-R] [-num] [ -n num ] [-adFiowx] [ -f file ] [ -t YYYYMMDDHHMMSS ] [name...] [tty...] lastb [-R] [-num] [ -n num ] [ -f file ] [-adFiowx] [name...] [tty...] 选项 说明 -num 显示行数 -R 不显示主机列 -a 在最后列显示主机名 -d 显示非本地登录的 -F 详细的登录和登出时间 -i 和-F大致显示，主机显示为ip -w 显示完全的用户名和域名 -x 显示关机和级别转换的信息 关机重启 不同关机命令的区别请参考这里 shutdown 关闭操作系统，详情这里 halt 关闭操作系统，详情这里 poweroff 关闭计算机，详情参考这里 reboot 重启操作系统，详情这里 参考 uptime命令w命令last命令shutdown命令halt命令poweroff命令reboot命令shutdown、halt、poweroff、reboot小结w、who、whoami和which、whereis、tty小结Linux中tty、pty、pts的概念区别 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/shi-yong-ming-ling.html":{"url":"senior-chapter/system-about/shi-yong-ming-ling.html","title":"实用命令","keywords":"","body":"watchtime参考watch 周期性的方式执行给定的指令，并将结果输出到屏幕 watch [options] command 选项 说明 -d, --differences [permanent] 高亮显示输出中的变化部分 -n, --interval seconds 指定刷新时间间隔 -p, --precise 时间更精确一些 -t, --no-title 不显示标题 -b, --beep 非正常退出时发出响声 -e, --errexit 出错时停止刷新 -g, --chgexit 当输出有变化后退出 -c, --color 显示颜色 -x, --exec 指定命令 time 统计给定命令所花费的总时间 time [options] args 选项 说明 -o 将结果写入到文件 -a 将结果追加到文件 -f 控制输出结果格式 格式控制符 控制符 说明 %E real时间，显示格式为[小时:]分钟:秒 %U user时间 %S sys时间 %C 进行计时的命令名称和命令行参数 %D 进程非共享数据区域，以KB为单位。 %x 命令退出状态 %k 进程接收到的信号数量 %w 进程被交换出主存的次数 %Z 系统的页面大小，这是一个系统常量，不用系统中常量值也不同 %P 进程所获取的CPU时间百分百，这个值等于user+system时间除以总共的运行时间 %K 进程的平均总内存使用量（data+stack+text），单位是KB %w 进程主动进行上下文切换的次数，例如等待I/O操作完成 %c 进程被迫进行上下文切换的次数（由于时间片到期） 参考 watch命令time命令 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/ding-shi-ren-wu.html":{"url":"senior-chapter/system-about/ding-shi-ren-wu.html","title":"定时任务","keywords":"","body":"任务调度系统任务调度用户任务调度时间格式时间示例周期执行时间冲突脚本添加参考任务调度 Linux下的任务调度分为两类 系统任务调度 用户任务调度 系统任务调度 系统任务的调度信息位于/etc/crontab，需要通过修改文件来添加 [root@localhost ~]# cat /etc/crontab SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 字段 说明 SHELL 运行时使用的shell PATH 命令的搜索路径 MAILTO 接收电子邮件的用户 列 说明 minute 指定分钟(0 - 59) hour 指定小时(0 - 23) day of month 指定一月中的第几天(1 - 31) month 指定月份(1 - 12) day of week 指定星期几(0 - 6) user-name 指定用户名 command to be executed 需要执行的命令 用户任务调度 用户任务的调度信息位于/var/spool/cron，文件名为用户名，可以通过crontab命令来配置 crontab [-u user] file crontab [-u user] [-l | -r | -e] [-i] [-s] 注意：crontab指定文件时会覆盖原来的定时任务 选项 说明 -u 指定用户 -l 显示定时任务 -r 清空定时任务 -e 编辑定时任务 -i 提示用户选择 crontab每行的语法和系统任务调度一样，只是没有用户列 时间格式 定时任务的时间除了使用数字，还可以使用以下特殊字符 *： 该时间字段的所有值 ,： 指定列表范围 -： 指定连续范围 /： 指定时间频率 时间示例 每小时的第1分钟执行一次 1 * * * * 每天的0点第1分钟执行一次 1 0 * * * 每1分钟执行一次 * * * * * 每15分钟执行一次 */15 * * * * 每小时的第7分和13分执行一次 7,13 * * * * 每天的第8点到第12点第7分和13分执行一次 7,13 8-12 * * * 每3个小时的第7分和13分执行一次 7,13 */3 * * * 每周六的第7分和13分执行一次 7,13 * * * 6 每季度的周六的第7分和13分执行一次 7,13 * * */3 6 周期执行 可以将脚本放到/etc中crontab相关的目录下执行 [root@localhost ~]# ls /etc/cron.d /etc/cron*ly -d -1 /etc/cron.d /etc/cron.daily /etc/cron.hourly /etc/cron.monthly /etc/cron.weekly 比如logrotate的定时任务文件 [root@localhost ~]# cat /etc/cron.daily/logrotate #!/bin/sh /usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf EXITVALUE=$? if [ $EXITVALUE != 0 ]; then /usr/bin/logger -t logrotate \"ALERT exited abnormally with [$EXITVALUE]\" fi exit 0 上面的cron相关的文件下面的文件中被调度的 [root@localhost ~]# cat /etc/cron.d/0hourly # Run the hourly jobs SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root 01 * * * * root run-parts /etc/cron.hourly [root@localhost ~]# cat /etc/anacrontab # /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL=/bin/sh PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # the maximal random delay added to the base delay of the jobs RANDOM_DELAY=45 # the jobs will be started during the following hours only START_HOURS_RANGE=3-22 #period in days delay in minutes job-identifier command 1 5 cron.daily nice run-parts /etc/cron.daily 7 25 cron.weekly nice run-parts /etc/cron.weekly @monthly 45 cron.monthly nice run-parts /etc/cron.monthly 时间冲突 crontab表达式中，前面4项的关系之间为与的关系，需要同时满足才执行，星期列跟其他是或的关系 脚本添加 可以通过脚本将定时任务追加到/var/spool/cron下对应用户的文件中去 参考 crontab命令每天一个linux命令：crontab命令请问centos系统/etc/cron.daily/下的脚本，是在哪里设置的定时执行呢crontab 如果日期和星期冲突时,会如何执行linux下利用shell脚本实现添加crontab任务 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/ri-zhi-sou-ji.html":{"url":"senior-chapter/system-about/ri-zhi-sou-ji.html","title":"日志搜集","keywords":"","body":"系统日志日志切割日志采集日志采集机器数据网络数据日志分析技术特点采集工具linux日志采集工具rsyslogsyslog-nglogstashwindows日志采集工具nxlogrsyslog参考系统日志 系统日志对于问题追踪和安全防护非常重要，通常在 /var/log 目录下面，详情参考参考中的链接 日志切割 日志每时每刻都在产生，需要在某个时刻或达到指定大小后进行切割和备份，详情参考参考中的链接 日志采集 日志采集 日志采集是指利用日志搜集工具将机器数据和网络数据采集到统一的地方进行分析和处理 机器数据 机器数据是指软件所能够产生的各种数据 日志文件 指标数据 业务数据 网络数据 网络数据是指对网络流量进行抓包和解析 日志分析 日志分析是对日志数据进行解析，并结合实际业务进行分析和处理 故障排查 异常告警 趋势预测 性能监控 业务分析 安全审计 技术特点 日志集中分析，处理和存储 全文检索，字段检索，关联分析 可视化展示，及时预警 采集工具 linux日志采集工具 rsyslog rsyslog 是大多数linux系统的默认采集工具，具有以下特点 基于c语言开发的，支持多线程的高性能采集工具 支持可靠的tcp传输，并且可以使用ssl加密 模块化设计，支持按需加载模块使用 支持基于内存和文件缓冲队列 支持kafka等多种输出 支持日志压缩 rsyslog的基础知识可以参照这里，官网参考这里，Github参考这里 syslog-ng syslog-ng 也是linux上比较好的采集工具，和 rsyslog 类似 SUSE Linux和 OpenSUSE默认使用syslog-ng，详情参照这里 logstash logstash是新兴的开源日志采集工具，是ELK中重要的一员 缩写 说明 E Elasticsearch（日志存储和检索引擎） L Logstash（日志采集工具） K Kibana（可视化展示工具） 但是由于logstash非常消耗性能，所以衍生了更加轻量的采集工具 工具 说明 Filebeat 采集文件数据 Metricbeat 采集指标数据 Packetbeat 采集网络数据 Winlogbeat 采集Windows系统日志 Heartbeat 监测应用存活状态 rsyslog，syslog-ng，logstash的对比可以参照这里 windows日志采集工具 nxlog nxlog是windows平台上比较常用的日志采集工具，详情参照这里 rsyslog rsyslog也有windows平台的客户端 参考 rsyslog官方文档slog介绍(一) ：BSD syslog协议的格式Linux环境下使用rsyslog管理日志rsyslog使用详解在CentOS和RHEL 5上使用rsyslog构建中央日志主机-Howtoing运维教程使用rsyslog集中管理日志HowTo Configure Mac OS X Syslog To Forward DataConfiguring System Message LoggingIBM PASE for System i and Syslog / SyslogdRemote SYSLOGD from AS400 to UNIX or Linux Servers使用Evtsys和Nxlog搭建syslog日志服务器-烂泥行天下ELK 5.x 搭建大规模日志实时处理系统rsyslog 的 TCP 转发性能测试Flume日志采集系统——初体验（Logstash对比版）Flume(NG)架构设计要点及配置实践关于Logstash中grok插件的正则表达式例子OpenSUSE - rsyslog wikiUnderstand logging in LinuxWhat is the difference between syslogd and klogd daemon in Linux? - QuoraUnix/Linux system logging, log files, kernel messagesRHEL7: 系统日志(rsyslog, journal)Rsyslog configuration for changing source interfacereopenOnTruncate is not obeyed unless a state file was loaded · Issue #1090ELK+Filebeat 集中式日志解决方案详解syslog及syslog-ng详解Troubleshooting and debugging syslog-ng[syslog-ng] Cannot find init.d.AIX in contrib folderAIX mkssys CommandAIX rmssys CommandAIX lssrc Command[syslog-ng] How to install syslog-ng on AIX 5.3 [English]ELKstack 中文指南 · GitBookElasticsearch官网Elasticsearch社区aix系统下怎么收集日志 - Elastic中文社区ELK-install-in-AIX-and-Windows基于Flume的美团日志收集系统(一)架构和设计Logstash 最佳实践logstash-forwarder logstash-forwarder-javaHow to create a java keystoreELK 性能(1) — Logstash 性能及其替代方案 - Richaaaard - 博客园Logstash Forwarder 配置详解Logstash Forwarder 长期运行Add setting to enable string escaping in Logstash pipeline configWhat is the best date/time parsing library in any language? - Quoralogstash-forwarder-java javax.net.ssl.SSLHandshakeExceptionrsyslog, Using Wildcards with rsyslog's File Monitor imfile每秒百万级流式日志处理架构的开发运维调优笔记Linux中rsyslog日志系统详解rsyslog 队列介绍Linux中syslog-ng日志系统 – 运维那点事‘Afsql’ error on syslog-ng resolvedsyslog-ng on vServer with Debian LennyTroubleshooting syslog-ng日志易：IT 运维分析及海量日志搜索的实践之路（上）日志易：IT 运维分析及海量日志搜索的实践之路（下） 日志易官网Loggly官网Splunk官网如何查看linux系统下的各种日志文件 linux 系统日志的分析大全/var/log目录下的20个Linux日志文件功能详解Linux系统中‘dmesg’命令处理故障和收集系统信息的7种用法Linux中logrotate日志管理工具详解被遗忘的Logrotatelogrotate机制和原理Linux日志文件总管——logrotate/dev/random和/dev/urandom的一点备忘怎么使用 /dev/urandom 生成固定长度的随机数？ Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/yu-yan-he-ri-qi.html":{"url":"senior-chapter/system-about/yu-yan-he-ri-qi.html","title":"语言和日期","keywords":"","body":"localedate时间戳与日期转换MacLinuxcal参考locale 显示地区和语言 [root@localhost ~]# locale LANG=zh_CN.UTF-8 LC_CTYPE=zh_CN.UTF-8 LC_NUMERIC=\"zh_CN.UTF-8\" LC_TIME=\"zh_CN.UTF-8\" LC_COLLATE=\"zh_CN.UTF-8\" LC_MONETARY=\"zh_CN.UTF-8\" LC_MESSAGES=\"zh_CN.UTF-8\" LC_PAPER=\"zh_CN.UTF-8\" LC_NAME=\"zh_CN.UTF-8\" LC_ADDRESS=\"zh_CN.UTF-8\" LC_TELEPHONE=\"zh_CN.UTF-8\" LC_MEASUREMENT=\"zh_CN.UTF-8\" LC_IDENTIFICATION=\"zh_CN.UTF-8\" LC_ALL= 字段 说明 LC_CTYPE 语言符号分类 LC_NUMERIC 数字显示格式 LC_TIME 时间显示格式 LC_COLLATE 排序比较习惯 LC_MONETARY 货币基本单位 LC_MESSAGES 提示信息格式 LC_PAPER 默认纸张大小 LC_NAME 姓名书写方式 LC_ADDRESS 地址书写方式 LC_TELEPHONE 电话书写方式 LC_MEASUREMENT 度量计算方式 LC_IDENTIFICATION 自身包含信息的概述 LC_ALL 其他选项的默认设置 字段的优先级顺序为 LC_ALL > LC_* >LANG locale就是某一个地域内的人们的语言习惯和思维方式的表现，系统支持的locale可使用如下命令查看 ls /usr/share/i18n/locales zh_CN 就是简体中文的意识 locale显示地区和语言，local则是用来定义局部变量的 [root@localhost ~]# local -bash: local: 只能在函数中使用 date 显示和修改时间 date [OPTION]... [+FORMAT] date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] 选项 说明 -d, --date=STRING 指定显示格式 -f, --file=DATEFILE 从文件中读取显示格式 -I[TIMESPEC], --iso-8601[=TIMESPEC] 以ISO 8601格式显示 -r, --reference=FILE 显示文件的最后修改时间 -R, --rfc-2822 以RFC 2822格式显示 --rfc-3339=TIMESPEC 以RFC 3339格式显示 -s, --set=STRING 设置时间 -u, --utc, --universal 显示UTC时间 输出格式控制符 控制符 说明 %% 转义百分号 %a 简写的星期名 %A 完整的星期名 %b 简写的月份名 %B 完整的月份名 %c 本地日期和时间 %C 年份的前两位（世纪） %d 一月中的第几天 %D 同%m/%d/%y %F 同%Y-%m-%d %g 一年中的第几个星期时的年份后两位，参考%G %g 一年中的第几个星期时的年份，配合%V %h 同%b %H 24小时制 %I 12小时制 %j 一年中的第几天 %m 月份 %M 分钟 %n 换行符 %N 纳秒 %p 显示AM或PM %P 显示am或pm %s 1970-01-01 00:00:00以来的秒数 %S 秒 %t TAB符号 %T 同%H:%M:%S %u 一周中的第几天（1..7），1是星期一 %U 一年中的第几周（00..53），星期天是一周的的第一天 %V ISO标准中的一周中的第几周（00..53），星期一是一周的的第一天 %w 一周中的第几天（0..6），0是星期天 %W 一年中的第几周（00..53），星期一是一周的的第一天 %y 年份的后两位 %Y 完整的年份 %z 显示时区 时间戳与日期转换 Mac ➜ Downloads date +%s 1509719840 ➜ Downloads date -r 1509719840 2017年11月 3日 星期五 22时37分20秒 CST ➜ Downloads date -j -f '%Y-%m-%d %H:%M:%S' '1992-10-25 10:10:10' +%s 719979010 ➜ Downloads date -r 719979010 +\"%F %T\" 1992-10-25 10:10:10 Linux [root@localhost ~]# date +%s 1509719840 [root@localhost ~]# date -d @1509719840 2017年 11月 03日 星期五 10:37:20 EDT [root@localhost ~]# date -d '1992-10-25 10:10:10' +%s 720025810 [root@localhost ~]# date -d @720025810 +\"%F %T\" 1992-10-25 10:10:10 cal 显示日历 cal [options] [[[day] month] year] 选项 说明 -1, --one 只显示当前月 -3, --three 显示当前月和上下两个月 -s, --sunday 星期天为一周的第一天 -m, --monday 星期一为一周的第一天 -j, --julian 显示一年中的第几天 -y, --year 显示年份 [root@localhost ~]# cal -s 十月 2017 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 [root@localhost ~]# cal -m 十月 2017 一 二 三 四 五 六 日 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 -s和-m并不会影响某一天的星期，只是影响展示效果 参考 locale的设定及LANG、LC_CTYPE、LC_ALL环境变量每个国家对应的语言Locale和国家代码对照表linux系统locale的设定十分钟搞清字符集和字符编码字符串，那些你不知道的事VIM 文件编码识别与乱码处理Python字符编码详解PYTHON-进阶-编码处理小结Python2 中的编码问题立即停止使用setdefaultencoding('utf-8')，以及为什么每天一个linux命令：date命令date命令使用beego/go mysql /JavaScript 遇到的时间坑以及ISO-8601标准 UTC 和ISO 8601时间格式的一些疑问关于“时间”的一次探索一周的第一天是周一还是周日？由来是什么JAVA Calendar类setFirstDayOfWeek和setMinimalDaysInFirstWeek每天一个linux命令（38）：cal 命令cal命令日历查询的算法 如何计算某一天是星期几历史上第一个星期一是从哪天开始的,为什么是那一天 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/fang-huo-qiang-ji-chu.html":{"url":"senior-chapter/system-about/fang-huo-qiang-ji-chu.html","title":"防火墙基础","keywords":"","body":"防火墙参考防火墙 防火墙的知识比较多，请参考参考部分的链接里面的内容 参考 inux平台下防火墙iptables原理iptables（一）详细教程：基础、架构、清空规则、追加规则、应用实例iptables（二），常用规则：屏蔽IP地址、禁用ping、协议设置、NAT与转发、负载平衡、自定义链深入浅出Netfilter/iptables防火墙框架（基础篇）深入浅出Netfilter/iptables防火墙框架（入门篇）iptables规则链执行顺序如何查看IPTABLES的默认策略centos7下部署iptables环境纪录（关闭默认的firewalle）通过iptables实现端口转发和内网共享上网iptables学习笔记：端口转发之“内网访问外网”iptables学习笔记：端口转发之“外网访问内网”用iptables实现同机器和不同机器间的端口转发Linux防火墙（iptables ）的功能详解一Linux防火墙（iptables ）的功能详解二CentOS 7 下使用 FirewallCentOS 上的 FirewallD 简明指南你真的理解防火墙吗用活firewalld防火墙中的zone用活firewalld防火墙之serviceFirewalld防火墙与ICMP攻击 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"senior-chapter/system-about/fang-huo-qiang-shi-yong.html":{"url":"senior-chapter/system-about/fang-huo-qiang-shi-yong.html","title":"防火墙使用","keywords":"","body":"防火墙防火墙 防火墙的知识比较多，请参考防火墙基础章节 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"zong-he-pian/zi-liao-tui-jian/":{"url":"zong-he-pian/zi-liao-tui-jian/","title":"资料推荐","keywords":"","body":"本章是关于资料推荐相关的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"zong-he-pian/zi-liao-tui-jian/wang-zhan-tui-jian.html":{"url":"zong-he-pian/zi-liao-tui-jian/wang-zhan-tui-jian.html","title":"网站推荐","keywords":"","body":"Linux中国开源社区Linux命令大全运维生存时间运维那点事rpm包查找 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"zong-he-pian/zi-liao-tui-jian/shu-ji-tui-jian.html":{"url":"zong-he-pian/zi-liao-tui-jian/shu-ji-tui-jian.html","title":"书籍推荐","keywords":"","body":"基础学习基础学习 Linux权威指南 Ubuntu_Linux从入门到精通 Shell脚本学习指南 Linux Shell脚本攻略 高级bash脚本编程指南6 Linux服务器搭建实战详解 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"zong-he-pian/gong-ju-ji-qiao/":{"url":"zong-he-pian/gong-ju-ji-qiao/","title":"工具技巧","keywords":"","body":"本章是关于资料工具技巧的介绍 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"zong-he-pian/gong-ju-ji-qiao/macbi-ji-ben.html":{"url":"zong-he-pian/gong-ju-ji-qiao/macbi-ji-ben.html","title":"Mac笔记本","keywords":"","body":"Mac全局快捷键Mac软件推荐小工具网站Mac全局快捷键 快捷键 说明 Command + Q 退出应用程序 Command + W 关闭当前页面 Command + R 刷新当前页面 Command + T 新建页面 Command + P 打印 Command + A 全选 Command + S 保存 Command + F 查找 Enter 查找下一个 Command + H 隐藏当前窗口 Command + Z 撤销 Shift + Command + Z 重做 Command + X 前切 Command + C 复制 Command + V 粘贴 Shift + Command + V 粘贴并保留样式 Command + M 最小化到Dock Command + , 打开设置界面（逗号） Command + TAB 快速切换程序 Command + SPACE 切换输入法 Command + SPACE 呼出搜索框 Command + ← 向左切换屏幕 Command + → 向右切换屏幕 Command + ↑ 显示任务管理界面 Command + ↓ 显示应用程序界面 Shift一般是对Command进行增强，Alt则是辅助 Mac软件推荐 用途 软件 浏览器 chrome 记笔记 evernote 编辑器 sublime shell终端 item2 http模拟请求 postman mysql客户端 sequel pro 抓包工具 Charles Markdown编辑器 macdown 虚拟机 virtualbox 应用容器引擎 docker 词典 欧陆词典 截图 QQ截图 快速切换程序 snap 快捷键提示 CheatSheet 思维导图 xmind rar解压 unarchiver 运行exe文件 WrappeK 自动点击 AutoClicker Windows登录客户端 microsoft remote desktop java开发编辑器 intellij idea python开发编辑器 pycharm 小工具网站 json解析ip地址查看在线工具箱 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"zong-he-pian/gong-ju-ji-qiao/chromeliu-lan-qi.html":{"url":"zong-he-pian/gong-ju-ji-qiao/chromeliu-lan-qi.html","title":"Chrome浏览器","keywords":"","body":"快捷键文件快捷键窗口快捷键视图快捷键插件快捷键 文件快捷键 快捷键 说明 Command + T 新建标签页页 Shift + Command + T 重新打开关闭的标签页 Command + N 打开新的窗口 Command + O 打开文件 Command + L 定位到地址栏 窗口快捷键 快捷键 说明 Command + + 放大 Command + - 缩小 Command + 0 还原 Command + [ 后退 Command + ] 前进 Alt + Command + → 向右切换标签页 Alt + Command + ← 向左切换标签页 Shift + Command + ] 向右切换标签页 Shift + Command + [ 向左切换标签页 Space 向下翻屏 视图快捷键 快捷键 说明 Command + Y 显示历史纪录 Alt + Command + U 显示源代码 Alt + Command + I 显示开发者工具 Alt + Command + J JavaScript控制台 插件 Postman Postman Interceptor EditThisCookie Axure RP Extension for Chrome JetBrains IDE Support 印象笔记·剪藏 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"zong-he-pian/gong-ju-ji-qiao/sublimebian-ji-qi.html":{"url":"zong-he-pian/gong-ju-ji-qiao/sublimebian-ji-qi.html","title":"Sublime编辑器","keywords":"","body":"快捷键通用快捷键文件快捷键编辑快捷键选择快捷键查找快捷键查找快捷键插件快捷键 通用快捷键 快捷键 说明 Command + + 放大 Command + - 缩小 文件快捷键 快捷键 说明 Command + N 新建文件 Command + O 打开文件 Shift + Command + T 打开关闭的文件 编辑快捷键 快捷键 说明 Command + ] 向右缩进 Command + [ 向左缩进 Control + Command + ↑ 和上面一行交换 Control + Command + ↑ 和下面一行交换 Command + J 合并下面一行 Command + / 添加删除注释 选择快捷键 快捷键 说明 Command + D 选中单词 Command + L 选中整行 查找快捷键 快捷键 说明 Control + Command + G 查找所有单词 查找快捷键 快捷键 说明 Alt + Command + 1 1个竖屏 Alt + Command + 2 2个竖屏 插件 Emmet SideBar Enhancements Themr Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "},"zong-he-pian/gong-ju-ji-qiao/ideabian-ji-qi.html":{"url":"zong-he-pian/gong-ju-ji-qiao/ideabian-ji-qi.html","title":"Idea编辑器","keywords":"","body":"快捷键通用快捷键编辑快捷键查找快捷键视图快捷键导航快捷键运行快捷键参考快捷键 通用快捷键 快捷键 说明 Command + , 打开软件设置界面 Command + ; 打开工程设置界面 Command + K 打开代码提交界面 编辑快捷键 快捷键 说明 Shift + Command + C 复制文件路径 Command + D 复制当前行 Shift + Enter 开始新的行 Command + N 快速生成代码 Control + T 选择重构方式 Control + O 选择重载方法 Control + I 选择实现方法 Command + J 插入模版代码 Command + / 添加删除注释 Command + + 快速展开代码 Command + - 快速折叠代码 Shift + Command + ↑ 向上移动语句 Shift + Command + ↓ 向下移动语句 Shift + Command + U 大小写转换 Alt + Enter 快速修复错误 Alt + Command + L 格式化代码 Control + Alt + I 自动缩进代码 Control + Alt + O 清除无用导入 查找快捷键 快捷键 说明 Command + F 当前文件查找 Shift + Command + F 更大范围查找 Control + Command + G 选中所有查找 Shift + Shift 查找所有地方 Command + R 当前文件替换 Shift + Command + R 更大范围替换 视图快捷键 快捷键 说明 Command + Y 快速查看定义 Command + P 查看参数提示 Control + J 查看方法定义 Command + D 比较两个文件 Command + E 最近使用文件 Shift + Command + E 最近改变文件 Shift + Control + P 表达式类型 Shift + Control + Q 上下文信息 导航快捷键 快捷键 说明 Command + [ 后退 Command + ] 前进 Command + L 跳转到指定行 Command + O 搜索类 Shift + Command + O 搜索文件 Alt + Command + O 搜索符号 Command + U 跳转到父类的方法 Command + B 跳转到使用的地方 Alt + Command + B 查看方法实现的类 Shift + Command + B 查看变量对应的类 Shift + Command + T 新建或选择测试类 Control + H 类型层次 Shift + Command + H 方法层次 Control + Alt + H 调用层次 F2 下一个错误 Shift + F2 上一个错误 运行快捷键 快捷键 说明 Control + R 运行选中程序 Control + D 调试选中程序 Control + Alt + R 选择运行程序 Control + Alt + D 选择调试程序 Command配合鼠标悬停可以实现信息查看 Command配合鼠标点击可以实现定义跳转 参考 Intellij IDEA 一些不为人知的技巧Intellij IDEA 的一些使用技巧IntelliJ IDEA For Mac 快捷键 Copyright © zhujipeng 2017 all right reserved，powered by Gitbook 该文件修订时间： 2018-03-17 13:41:33 "}}